title: Оптимизация AngularJS: 1200ms к 35ms
date: 2014-01-06
author: Илья Овсянников
gravatarMail: webhunter1987@gmail.com
tags: [AngularJS, Javascript]
---

В Scalyr мы недавно погрузились в полное переписывание нашего веб клиента. Наше приложение- это в широком смысле контроль и инструмент для анализирования журналов. Наша доморощенная база журналов выполняет большинство запросов за десятки миллисекунд, но каждое взаимодействие требует загрузки страницы, отнимая у пользователя несколько секунд.

Архитектура [одностраничного приложения](http://en.wikipedia.org/wiki/Single-page_application) пообещала разблокировать сверкающий исполнением backend, итак мы искали подходящий framework и определили AngularJS как многообещающего кандидата. Следуя принципу “быстрый провал”, мы начали с нашей самой сложной проблемы- вид журнала.

Это по-настоящему серьезное испытание для структуры приложения. Пользователь может нажать на любое слово, чтобы найти, связанные с ним сообщения в логах, итак здесь могут быть сотни интерактивных элементов на странице, еще мы хотим мгновенный ответ для перелистывания страниц журнала. Мы уже предварительно выбрали следующую страницу данных журнала, итак обновление пользовательского интерфейса- это настоящее испытание. Наивная имплементация вида журнала в AngularJS заняла 1,2 секунды для перемещения на следующую страницу, но некоторые осторожные оптимизации мы смогли уменьшить до 35 миллисекунд. Эти оптимизации доказали, что могут быть полезными в других частях приложения, и хорошо вписались в философию AngularJS, хотя нам пришлось нарушить несколько правил для их реализации. В этой статье мы обсудим методы, которые мы использовали.

Журнал Github изменений, из нашей [демо версии](https://www.scalyr.com/logStart)

###Наблюдатель AngularJS журнала

В сущности, Вид Журнала- это просто список сообщений журнала. Каждое слово интерактивно и поэтому должно быть помещено в его собственный Dom элемент. Простая реализация в AngularJS может выглядеть так:

```js
<span class=’logLine’ ng-repeat=’line in logLinesToShow’><span class=’logToken’ ng-repeat=’token in line’>{{token | formatToken}} </span><br></span>
```
Одна страница может просто иметь несколько десятков символов. В наших простых тестах, мы нашли, что  продвижение на следующую страницу журнала может занять несколько мучительных секунд Javascript выполнения. Хуже того, из-за несвязанных действий (такими, как нажатие на выпадающее меню навигации) были заметные задержки. Здравый смысл для AngularJS говорит, что вам следует держать количество элементов с ограниченными данными ниже 200. С элементом на каждое слово мы значительно превысили этот уровень.

### Анализ

Используя профайлер js в хроме, мы быстро определяем два источника лага. В первом источнике, каждое обновление потратило много времени на создание и уничтожение Dom элементов. Если у нового вида есть разное количество линий или у любой линии разное количество слов, то соответственно директива Angular `ng-repeat` создаст или уничтожит Dom элементы. Это обойдется вам достаточно дорого.

Во втором источнике, у каждого слова был свой собственный наблюдатель за изменениями, который AngularJS мог запускать при каждом нажатии мышки. Это сподвигло лаг на несвязанные действия, такие как всплывающее окно навигации.

### Оптимизация #1: Кеширование Dom элементов

Мы создали вариант директивы `ng-repeat`. В нашей версии, когда количество элементов данных уменьшено, избыточные DOM элементы спрятаны, но не удалены. Позже если количество элементов увеличивается, то прежде чем создавать новые, мы повторно используем эти кешированные элементы.

### Оптимизация #2: Комбинирование вотчеров

Все время, которое мы потратили на вызов функций вотчеров было потрачено впустую. В нашем приложении данные, связанные с конкретным словом могут никогда не поменяться, пока меняется общий массив журнала сообщений. С этим изменением, мы избежали вызова тысячи наблюдателей изменений за словами, нажатиями мыши и других незначительных событий. (Чтобы этого достичь, мы должны были слегка нарушить уровень абстракции в AngularJS. В заключении мы расскажем об этом чуть-чуть больше)

### Оптимизация #3: Откладывание создания элементов

Как отмечалось, мы создаем отдельный Dom элемент для каждого слова в журнале. Мы могли получить то же визуальное представление с единым Dom элементом в строке; дополнительные элементы нужны только для взаимодействия с мышкой. Следовательно, мы решили отложить создание элементов на каждое слово для конкретной линии, пока мышка движется по этой линии.

Чтобы это осуществить, мы создаем 2 версии каждой линии. Первая версия- это простой текстовый элемент, показывающий полную запись в журнале. Другая версия- это шаблон, который, в конечном счете, будет заполнен элементом в слове. Изначально плейсхолдер спрятан. Как описано дальше, плейсхолдер заполняется при отображении текстовыми элементами.

### Оптимизация #4: Обходной путь вотчеров для спрятанных элементов

Мы создали еще одну директиву, которая не позволяют вотчерам быть исполненными для конкретного элемента (или их детей), когда элемент спрятан. Это поддерживает Оптимизацию #1, устраняя любую издержку для дополнительных Dom нод, которые были спрятаны, поскольку у нас теперь есть больше Dom нод, чем элементов с данными. Это так же поддерживает Оптимизацию #3, что позволяет легко откладывать создание нод для каждых слов, пока размеченная версия линии не будет показана.

Вот как выглядит код со всеми примененными оптимизациями. Наши пользовательские директивы выделены жирным шрифтом:

```js
<span class=’logLine’ sly-repeat=’line in logLinesToShow’ sly-evaluate-only-when=’logLines’><div ng-mouseenter=”mouseHasEntered = true”><span ng-show=’!mouseHasEntered’>{{logLine | formatLine }} </span><div ng-show=’mouseHasEntered’ sly-prevent-evaluation-when-hidden><span class=’logToken’ sly-repeat=’tokens in line’>{{token | formatToken }}</span></div>
</div>
<br>
</span>
```

`sly-repeat`- наш вариант `ng-repeat`, который скорее прячет дополнительные Dom элементы, чем разрушает их. 
`sly-evaluate-only-when` препятствует внутренним изменяющимся наблюдателям из выполнения, пока меняется переменная `logLines`, показывая, что пользователь продвинулся к новой части журнала. 

И `sly-prevent-evaluation-when-hidden` препятствует внутреннему вызову ‘repeat’ из 
Это показывает силу AngulsrJS для инкапсуляции и разделении интересов. Мы применили несколько весьма сложных оптимизаций без сильного влияния на структуру шаблона (Это не тот самый код, который мы используем в продакшене, но он захватывает все важные элементы).

### Результаты

Для оценки производительности, мы добавили код, чтобы измерить время от нажатия мыши до окончания цикла `$digest` в AngularJS ( а это означает, что мы закончили обновление DOM). Пройденное время показано в виджите на стороне страницы. Мы оценили исполнение кнопки “Следующая страница”, во время просматривания журнала доступа к Tomcat, используя Chrome в последнем Macbook Pro. Здесь результаты (каждое число- это среднее значение за 10 попыток):

<table>
	<thead>
		<tr>
		   <th>&nbsp;</th>
		   <th>Data already cached</th>
		   <th>Data fetched from server</th>
		</tr>
	</thead>
	<tbody>
		<tr>
		   <td>Simple AngularJS</td>
		   <td>1190 ms</td>
		   <td>1300 ms</td>
		</tr>
		<tr>
		   <td>With Optimizations</td>
		   <td>35 msS</td>
		   <td>201 ms</td>
		</tr>
	</tbody>
</table>

Data already cached
Data fetched from server
Simple AngularJS
1190 ms
1300 ms
With Optimizations
35 ms
201 ms

Эти цифры не включают время, которое браузер тратит на DOM верстку и перерисовку (после завершения Javascript выполенения), которых около 30 миллисекунд в каждой реализации. Тем не менее, разница существенна; время Следующей страницы снизилось с “величественных” 1,2 секунд  до незаметных 35 мс (65 мс с отображением).
Графики,  “скаченные данные с сервера” включают в себя время, потраченное на AJAX вызов, для нашего бэкенда, чтобы скачать данные журнала. Это не свойственно для кнопки “Следующая страница”, потому что мы предварительно выбираем следующую страницу журналов, но может быть применимо для другого UI взаимодействия. Но даже здесь, оптимизированная версия обновляется практически мгновенно.
### Заключение
Этот код находился в продакшн версии 2 месяца и мы удовлетворены результатами. Вы можете это увитеть в действии в  [Scalyr Logs demo site](https://www.scalyr.com/logStart). После ввода демо версии, нажмите на ссылку “Log View”  и играйте со Следующими/Предыдущими кнопками. Это очень быстро, трудно поверить, что вы видите реальные данные с настоящего сервера.
На реализацию этих оптимизаций без грязных хаков ушло много времени и сил. Было бы проще создать единую пользовательскую директиву, которая непосредственно сформирует все HTML для просмотра журнала, обходя `ng-repeat`. Тем не менее, это было бы не в стиле AngularJS, неся в себе цену ухудшения поддерживаемости(???) кода, возможности его тестирования и других важных вещей. Так как вид журнала был нашим тестовым проектом для AngularJS, мы захотели подтвердить, что элегантное решение возможно. К тому же, новые директивы, созданные нами, уже использовались в других частях нашего приложения.
Мы сделали все возможное, чтобы следовать философии Ангуляра, но мы действительно должны были подчинить слой абстракции, чтобы осуществить некоторые из этих оптимизаций. Мы перезаписали метод `$watch` класса Scope для перехватывания объявления вотчеров, а потом нам потребовалось аккуратно управлять инстанс переменными класса Scope, для того, чтобы определять какие из вотчеров будут обрабатываться во время $digest цикла.
 ####В следующий раз
Эта статья охватила множество техник, которые мы использовали для оптимизации времени исполнения Javascript кода в нашем экземпляре AngularJS. Мы уверены в том, что следует максимально увеличивать производительность и это только часть трюков, которые мы использовали. В следующих статьях мы опишем техники уменьшения запросов сети, задержки сети, и времени выполнения кода на сервере. Мы так же можем обсудить наш основной опыт с AngularJS и подход, который мы использовали для структурирования нашего кода приложения. Если вам стало интересно, напишите нам в комментариях.

По мотивам Steve Newman

