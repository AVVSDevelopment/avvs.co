<!DOCTYPE html><!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="ru"> <![endif]--><!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8" lang="ru"> <![endif]--><!--[if IE 8]>         <html class="no-js lt-ie9" lang="ru"> <![endif]--><!--[if gt IE 8]><!--> <html class="no-js" lang="ru"> <!--<![endif]--><head prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb# article: http://ogp.me/ns/article#"> <meta charset="utf-8">  <title>Работа с потоками в node.js | Блог Makeomatic: разработка сайтов и мобильных приложений</title> <meta name="author" content="Makeomatic">  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"> <!-- For third-generation iPad with high-resolution Retina display: --> <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144x144-precomposed.png"> <!-- For iPhone with high-resolution Retina display running iOS ≥ 7: --> <link rel="apple-touch-icon-precomposed" sizes="120x120" href="/apple-touch-icon-120x120-precomposed.png"> <!-- For iPhone with high-resolution Retina display running iOS ≤ 6: --> <link rel="apple-touch-icon-precomposed" sizes="114x114" href="/apple-touch-icon-114x114-precomposed.png"> <!-- For first- and second-generation iPad: --> <link rel="apple-touch-icon-precomposed" sizes="72x72" href="/apple-touch-icon-72x72-precomposed.png"> <!-- For non-Retina iPhone, iPod Touch, and Android 2.1+ devices: --> <link rel="apple-touch-icon-precomposed" href="/apple-touch-icon-precomposed.png"> <meta name="description" content="Данный документ является вольным переводом stream-handbook и охватывает основы создания node.js приложений с использованием потоков. По сравнению с источником - обновлены некоторые главы с учетом 2">
<meta name="keywords" content="Node.js,Javascript">
<meta property="og:type" content="article">
<meta property="og:title" content="Работа с потоками в node.js">
<meta property="og:url" content="https://makeomatic.ru/blog/2016/08/22/Streams_handbook/index.html">
<meta property="og:site_name" content="Блог Makeomatic: разработка сайтов и мобильных приложений">
<meta property="og:description" content="Данный документ является вольным переводом stream-handbook и охватывает основы создания node.js приложений с использованием потоков. По сравнению с источником - обновлены некоторые главы с учетом 2">
<meta property="og:image" content="https://makeomatic.ru/blog/images/Streams_node.png">
<meta property="og:image" content="https://makeomatic.ru/blog/images/mcilroy.png">
<meta property="og:image" content="https://makeomatic.ru/blog/images/kernighan.png">
<meta property="og:updated_time" content="2017-03-08T17:52:58.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Работа с потоками в node.js">
<meta name="twitter:description" content="Данный документ является вольным переводом stream-handbook и охватывает основы создания node.js приложений с использованием потоков. По сравнению с источником - обновлены некоторые главы с учетом 2">
<meta name="twitter:image" content="https://makeomatic.ru/blog/images/Streams_node.png">
<meta name="twitter:creator" content="@makeomatic">
<link rel="publisher" href="https://plus.google.com/+MakeomaticRu">   <link href='//fonts.googleapis.com/css?family=Roboto:300,700&subset=latin,cyrillic,cyrillic-ext' rel='stylesheet' type='text/css'>  <link rel="stylesheet" href="/css/app.min.2.3.1.css">  <script src="/js/vendor/modernizr-2.6.2-respond-1.1.0.min.js"></script> <!-- place this in your head tag --> <!-- <script src='https://js.tito.io/v1' async></script> --> <!-- <link rel="stylesheet" type="text/css" href='https://css.tito.io/v1' /> --></head><body data-spy="scroll" data-target=".navbar" data-offset="150"><!--[if lt IE 8]><p class="chromeframe">Вы используете <strong>устаревший</strong> браузер. Пожалуйста <a href="http://browsehappy.com/">обновите ваш браузер</a> или <a href="http://www.google.com/chromeframe/?redirect=true">активируйте Google Chrome Frame</a>, чтобы улучшить ваши впечатления от посещения сайта.</p><![endif]--><header class="navbar navbar-inverse navbar-fixed-top"> <div class="navbar-inner"> <div class="container"> <div class="social-desktop"> <a class="fcb" href="https://www.facebook.com/makeomatic"> <i class="fa fa-facebook"></i> </a> <a class="vk" href="https://vk.com/makeomatic"> <i class="fa fa-vk"></i> </a> <a class="twt" href="https://twitter.com/MakeOmatic"> <i class="fa fa-twitter"></i> </a> <a class="gp" href="https://google.com/+MakeomaticRu"> <i class="fa fa-google-plus-square"></i> </a> </div> <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </a> <a class="brand" href="/">makeomatic</a> <div class="nav-collapse collapse"> <ul class="nav">   <li class='active '> <a href="/blog" > Блог  </a>  </li>   <li class=' dropdown'> <a href="/team" data-target="#" class="dropdown-toggle" data-toggle="dropdown"> Команда  <b class='caret'></b>  </a>  <ul class='dropdown-menu'>   <li> <a href="/team#vyacheslavgusev">Вячеслав Гусев</a> </li>   <li> <a href="/team#vitaliiaminev">Виталий Аминев</a> </li>   <li> <a href="/team#annaamineva">Анна Аминева</a> </li>   <li> <a href="/team#andreiafoninskii">Андрей Афонинский</a> </li>   <li> <a href="/team#aleksandrkremenets">Александр Кременец</a> </li>   <li> <a href="/team#dmitriigorbunov">Дмитрий Горбунов</a> </li>   <li> <a href="/team#evgeniipoyarkov">Евгений Поярков</a> </li>   <li> <a href="/team#ilyaovsyannikov">Илья Овсянников</a> </li>  </ul>  </li>   <li class=' '> <a href="/#about" > О нас  </a>  </li>   <li class=' dropdown'> <a href="/#portfolio" data-target="#" class="dropdown-toggle" data-toggle="dropdown"> Портфолио  <b class='caret'></b>  </a>  <ul class='dropdown-menu'>   <li> <a href="/#Distribut.io">Distribut.io</a> </li>   <li> <a href="/#Recordi">Recordi</a> </li>   <li> <a href="/#Photobot">Photobot</a> </li>   <li> <a href="/#BrainsApp">BrainsApp</a> </li>   <li> <a href="/#FabrikaTepla">FabrikaTepla</a> </li>   <li> <a href="/#SpeakGeo">SpeakGeo</a> </li>   <li> <a href="/#OpenInclude">OpenInclude</a> </li>   <li> <a href="/#LIVEONE">LIVEONE</a> </li>   <li> <a href="/#FitCafe">FitCafe</a> </li>  </ul>  </li>   <li class=' '> <a href="/#tech" > Технологии  </a>  </li>   <li class=' '> <a href="#contacts" > Контакты  </a>  </li>  </ul> </div><!--/.nav-collapse --> <div class='send-brief' > <a href='#brief' role='button' data-toggle='modal'> <i class='background'></i> <span>Заполнить бриф</span> </a> </div> <h4 class='phone-desktop'> Звоните: +7 (495) 79-222-44 </h4> </div> </div></header><div class="icon-up visible-desktop" id="up" title="наверх"></div><section class="container blog" id='blog'> <h1 class='outlined-caption text-center'> <a href='/blog'>Блог Makeomatic: разработка сайтов и мобильных приложений</a> </h1>  <div class='row'> <div class='span10'><article class="post"> <div class="post-content"> <header class='post-header'>   <h2 class="title">Работа с потоками в node.js</h2> <p class='muted'></p>   <div class="icon"></div> <time datetime="2016-08-22T07:00:00.000Z"> Aug 22 2016 </time>   <div class="tags"> | Категории: <a href="/blog/tags/Node-js/">Node.js</a>, <a href="/blog/tags/Javascript/">Javascript</a> </div> <span class='author'><img src='//www.gravatar.com/avatar/aa56bb7f5fa13a9df1cb2e3578c609bb?s=20' /> Andrey Afoninsky</span>  </header> <section class="body">  <div class="text-center"><br><img src="/blog/images/Streams_node.png" alt="Работа с потоками в node.js"><br></div>


<p>Данный документ является вольным переводом <a href="https://github.com/substack/stream-handbook" target="_blank" rel="external">stream-handbook</a> и охватывает основы создания <a href="http://nodejs.org/" target="_blank" rel="external">node.js</a> приложений с использованием <a href="http://nodejs.org/docs/latest/api/stream.html" target="_blank" rel="external">потоков</a>. По сравнению с источником - обновлены некоторые главы с учетом 2016 года, добавлено объяснение различий между разными версиями API, убраны устаревшие модули и добавлены новые, изменена структура повествования.</p>
<a id="more"></a>
<p>Таким образом, надеюсь, в результате получился актуальный современный учебник по потоковому API в node.js. Жду ваших комментариев и замечаний.</p>
<h3 id="Оглавление"><a href="#Оглавление" class="headerlink" title="Оглавление"></a>Оглавление</h3><ul>
<li><a href="#intro">Вступление</a></li>
<li><a href="#why">Почему мы должны использовать потоки</a></li>
<li><a href="#theory">Основы</a><ul>
<li><a href="#pipe">.pipe()</a></li>
<li><a href="#readable">Потоки на чтение (readable)</a><ul>
<li><a href="#readable-create">Создание потока на чтение</a></li>
<li><a href="#readable-usage">Использование потока на чтение</a></li>
</ul>
</li>
<li><a href="#writeable">Потоки на запись (writeable)</a><ul>
<li><a href="#writeable-create">Создание потока на запись</a></li>
<li><a href="#writeable-usage">Отправка данных в поток на запись</a></li>
</ul>
</li>
<li><a href="#duplex">Дуплексные потоки (duplex)</a></li>
<li><a href="#transform">Трансформирующие потоки (transform)</a></li>
<li><a href="#difference">Различия в реализации потоков</a><ul>
<li><a href="#streams1">streams1: устаревшее API</a></li>
<li><a href="#streams2">streams2: второе поколение</a></li>
<li><a href="#streams3">streams3: стабильная реализация</a></li>
</ul>
</li>
<li><a href="#additional">Дополнительно</a></li>
</ul>
</li>
<li><a href="#internal">Встроенные потоки</a></li>
<li><a href="#external">Сторонние потоки</a><ul>
<li><a href="#modules">Список модулей</a></li>
<li><a href="#examples">Примеры использования</a></li>
<li><a href="#cool">Мощные комбинации</a><ul>
<li><a href="#mesh">Создание распределенной сети</a></li>
<li><a href="#rpc">Клиент-серверный RPC</a></li>
<li><a href="#socket">Собственная реализация socket.io</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#conslusion">Заключение</a></li>
</ul>
<h1 id="Вступление"><a href="#Вступление" class="headerlink" title="Вступление "></a>Вступление <a name="intro"></a></h1><blockquote>
<p>Нам нужен способ взаимодействия между программами, наподобие того как садовый шланг можно подключать к разным сегментам и изменять направление воды. То же самое можно сделать с вводом-выводом данных</p>
</blockquote>
<p><a href="http://cm.bell-labs.com/who/dmr/mdmpipe.html" target="_blank" rel="external">Дуглас Макилрой. 11 октября 1964</a></p>
<p><img src="/blog/images/mcilroy.png" alt="doug mcilroy"></p>
<hr>
<p>Потоки пришли к нам из <a href="http://www.youtube.com/watch?v=tc4ROCJYbm0" target="_blank" rel="external">первых дней эпохи Unix</a> и зарекомендовали себя в течении многих десятилетий как надежный способ создания сложных систем из маленьких компонентов, которые <a href="https://ru.wikipedia.org/wiki/Философия_UNIX" target="_blank" rel="external">делают что-то одно, но делают это хорошо</a>. В Unix потоки реализуются в оболочке с помощью знака <code>|</code> (pipe). В node встроенный <a href="http://nodejs.org/docs/latest/api/stream.html" target="_blank" rel="external">модуль потоков</a> используется в базовых библиотеках, кроме этого его можно подключать в свой код. Подобно Unix, в node основной метод модуля потоков называется <code>.pipe()</code>. Он позволяет соединять потоки с разной скоростью передачи данных таким образом что данные не будут потеряны.</p>
<p>Потоки помогают <a href="https://ru.wikipedia.org/wiki/Разделение_ответственности" target="_blank" rel="external">разделять ответственность</a>, поскольку позволяют вынести все взаимодействие в отдельный интерфейс, который может быть <a href="http://www.faqs.org/docs/artu/ch01s06.html#id2877537" target="_blank" rel="external">использован повторно</a>. Вы сможете подключить вывод одного потока на ввод другого, и <a href="http://npmjs.org" target="_blank" rel="external">использовать библиотеки</a> которые будут работать с подобными интерфейсами на более высоком уровне.</p>
<p>Потоки - важный элемент микроархитектурного дизайна и философии UNIX, но кроме этого есть еще достаточное количество важных абстракций для рассмотрения. Всегда помните своего врага (<a href="http://c2.com/cgi/wiki?TechnicalDebt" target="_blank" rel="external">технический долг</a>) и ищите наиболее подходящие для решения задач абстракции.</p>
<p><img src="/blog/images/kernighan.png" alt="brian kernighan"></p>
<hr>
<h1 id="Почему-мы-должны-использовать-потоки"><a href="#Почему-мы-должны-использовать-потоки" class="headerlink" title="Почему мы должны использовать потоки "></a>Почему мы должны использовать потоки <a name="why"></a></h1><p>Ввод-вывод в node асинхронен, поэтому взаимодействие с диском и сетью происходит через различные способы управления асинхронным кодом (обещания, генераторы, функции обратного вызова и т.п.). Следующий код отдает файл браузеру через функцию обратного вызова (callback):</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">    fs.readFile(__dirname + <span class="string">'/data.txt'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</div><div class="line">        res.end(data);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div><div class="line">server.listen(<span class="number">8000</span>);</div></pre></td></tr></table></figure>
<p>Этот код работает, но он буферизирует весь <code>data.txt</code> в память при каждом запросе. Если <code>data.txt</code> достаточно большой, ваша программа начнет потреблять слишком много оперативной памяти, особенно при большом количестве подключений пользователей с медленными каналами связи.</p>
<p>При этом пользователи останутся недовольными, ведь им придется ждать пока весь файл не будет считан в память на сервере перед отправкой.</p>
<p>К счастью, оба аргумента <code>(req, res)</code> являются потоками, а это значит что мы можем переписать код с использованием <code>fs.createReadStream()</code> вместо <code>fs.readFile()</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> stream = fs.createReadStream(__dirname + <span class="string">'/data.txt'</span>);</div><div class="line">    stream.pipe(res);</div><div class="line">&#125;);</div><div class="line">server.listen(<span class="number">8000</span>);</div></pre></td></tr></table></figure>
<p>Теперь <code>.pipe()</code> самостоятельно слушает события <code>&#39;data&#39;</code> и<code>&#39;end&#39;</code> потока созданного через <code>fs.createReadStream()</code>. Этот код не только чище, но теперь и <code>data.txt</code> доставляется по частям по мере чтения его с диска.</p>
<p>Использование <code>.pipe()</code> имеет ряд других преимуществ, например автоматическая обработка скорости ввода-вывода - node.js не будет буферизировать лишние части файла в память пока предыдущие части не отправлены клиенту с медленным соединением.</p>
<p>А если мы хотим еще больше ускорить отправку файла? Добавим сжатие:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">var</span> oppressor = <span class="built_in">require</span>(<span class="string">'oppressor'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> stream = fs.createReadStream(__dirname + <span class="string">'/data.txt'</span>);</div><div class="line">    stream.pipe(oppressor(req)).pipe(res);</div><div class="line">&#125;);</div><div class="line">server.listen(<span class="number">8000</span>);</div></pre></td></tr></table></figure>
<p>Теперь наш файл cжимается для браузеров, которые поддерживают gzip или deflate! Мы просто отдаем модулю <a href="https://github.com/substack/oppressor" target="_blank" rel="external">opressor</a> всю логику обработки content-encoding и забываем про нее.</p>
<p>После того как вы ознакомитесь с API потоков, вы сможете писать потоковые модули и соединять их как кусочки лего, вместо того чтобы изобретать свои велосипеды и пытаться запомнить все способы взаимодействия между компонентами системы.</p>
<p>Потоки делают программирование в node.js простым, элегантным и компонуемым.</p>
<h1 id="Основы"><a href="#Основы" class="headerlink" title="Основы "></a>Основы <a name="theory"></a></h1><p>Существует 4 вида потоков:</p>
<ul>
<li>на чтение (<strong>readable</strong>)</li>
<li>на запись (<strong>writeable</strong>)</li>
<li>трансформирующие (<strong>transform</strong>)</li>
<li>дуплексные (<strong>duplex</strong>)</li>
</ul>
<p>Начиная с версии node.js v0.12 в стабильном состоянии заморожена версия APIv3 (<strong>streams3</strong>) - именно его описывает официальная документация. Все виды потоков, и различия в реализации API между ними будут рассмотрены ниже.</p>
<h2 id="pipe"><a href="#pipe" class="headerlink" title="pipe() "></a>pipe() <a name="pipe"></a></h2><p>Любой поток может использовать<code>.pipe()</code> для соединения входов с выходами.</p>
<p><code>.pipe()</code> это просто функция, которая берет поток на чтение <code>src</code> и соединяет его вывод с вводом потока на запись <code>dst</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">src.pipe(dst)</div></pre></td></tr></table></figure>
<p><code>.pipe(dst)</code> возвращает <code>dst</code>, так что вы можете связывать сразу несколько потоков:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.pipe(b).pipe(c).pipe(d)</div></pre></td></tr></table></figure>
<p>или то же самое:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a.pipe(b);</div><div class="line">b.pipe(c);</div><div class="line">c.pipe(d);</div></pre></td></tr></table></figure>
<p>Аналогично в Unix вы можете связать утилиты вместе:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a | b | c | d</div></pre></td></tr></table></figure>
<h2 id="Потоки-на-чтение-readable"><a href="#Потоки-на-чтение-readable" class="headerlink" title="Потоки на чтение (readable) "></a>Потоки на чтение (readable) <a name="readable"></a></h2><p>Поток на чтение производит данные, которые с помощью <code>.pipe()</code> могут быть переданы в поток на запись, трансформирующий или дуплексный поток:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">readableStream.pipe(dst)</div></pre></td></tr></table></figure>
<h3 id="Создание-потока-на-чтение"><a href="#Создание-потока-на-чтение" class="headerlink" title="Создание потока на чтение "></a>Создание потока на чтение <a name="readable-create"></a></h3><p>Давайте создадим считываемый поток!</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Readable = <span class="built_in">require</span>(<span class="string">'stream'</span>).Readable;</div><div class="line"></div><div class="line"><span class="keyword">var</span> rs = <span class="keyword">new</span> Readable;</div><div class="line">rs.push(<span class="string">'beep '</span>);</div><div class="line">rs.push(<span class="string">'boop\n'</span>);</div><div class="line">rs.push(<span class="literal">null</span>);</div><div class="line"></div><div class="line">rs.pipe(process.stdout);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ node read0.js</div><div class="line">beep boop</div></pre></td></tr></table></figure>
<p>Тут <code>rs.push(null)</code> сообщает потребителю, что <code>rs</code> закончил вывод данных.</p>
<p>Заметьте, мы отправили содержимое в поток на чтение <code>rs</code> ДО привязывания его к <code>process.stdout</code>, но сообщение все равно появилось в консоли. Когда вы посылаете с помощью <code>.push()</code> данные в поток на чтение, они буферизируются до тех пор пока потребитель не будет готов их прочитать.</p>
<p>Тем не менее, в большинстве случаев будет лучше если мы не будем их буферизировать совсем, вместо этого будем генерировать их только когда данные запрашиваются потребителем.</p>
<p>Мы можем посылать данные кусками, определив функцию <code>._read</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Readable = <span class="built_in">require</span>(<span class="string">'stream'</span>).Readable;</div><div class="line"><span class="keyword">var</span> rs = Readable();</div><div class="line"></div><div class="line"><span class="keyword">var</span> c = <span class="number">97</span>;</div><div class="line">rs._read = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    rs.push(<span class="built_in">String</span>.fromCharCode(c++));</div><div class="line">    <span class="keyword">if</span> (c &gt; <span class="string">'z'</span>.charCodeAt(<span class="number">0</span>)) rs.push(<span class="literal">null</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">rs.pipe(process.stdout);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ node read1.js</div><div class="line">abcdefghijklmnopqrstuvwxyz</div></pre></td></tr></table></figure>
<p>Теперь мы помещаем буквы  от <code>&#39;a&#39;</code> до <code>&#39;z&#39;</code> включительно, но только тогда когда потребитель будет готов их прочитать.</p>
<p>Метод <code>_read</code> также получает в первом аргументе параметр <code>size</code>, который указывает сколько байт потребитель хочет прочитать - он необязательный, так что ваша реализация потока может его игнорировать.</p>
<p>Обратите внимание, вы также можете использовать <code>util.inherits()</code> для наследования от базового потока, но такой подход может быть непонятен тому кто будет читать ваш код.</p>
<p>Чтобы продемонстрировать, что наш метод <code>_read</code> вызовется только когда потребитель запросит данные, добавим задержку в наш поток:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Readable = <span class="built_in">require</span>(<span class="string">'stream'</span>).Readable;</div><div class="line"><span class="keyword">var</span> rs = Readable();</div><div class="line"></div><div class="line"><span class="keyword">var</span> c = <span class="number">97</span> - <span class="number">1</span>;</div><div class="line"></div><div class="line">rs._read = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (c &gt;= <span class="string">'z'</span>.charCodeAt(<span class="number">0</span>)) <span class="keyword">return</span> rs.push(<span class="literal">null</span>);</div><div class="line"></div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        rs.push(<span class="built_in">String</span>.fromCharCode(++c));</div><div class="line">    &#125;, <span class="number">100</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">rs.pipe(process.stdout);</div><div class="line"></div><div class="line">process.on(<span class="string">'exit'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.error(<span class="string">'\n_read() called '</span> + (c - <span class="number">97</span>) + <span class="string">' times'</span>);</div><div class="line">&#125;);</div><div class="line">process.stdout.on(<span class="string">'error'</span>, process.exit);</div></pre></td></tr></table></figure>
<p>Запустив программу, мы увидим, что если мы запросим 5 байт - <code>_read ()</code> вызовется 5 раз:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ node read2.js | head -c5</div><div class="line">abcde</div><div class="line">_read() called 5 times</div></pre></td></tr></table></figure>
<p>Задержка через setTimeout необходима, так как операционной системе требуется определенное время чтобы послать сигнал о закрытии конвейера.</p>
<p>Обработчик <code>process.stdout.on(&#39;error&#39;, fn)</code> также необходим, поскольку операционная система пошлет SIGPIPE нашему процессу когда утилите <code>head</code> больше не будет нужен результат нашей программы (в этом случае будет вызвано событие EPIPE в потоке <code>process.stdout</code>).</p>
<p>Эти усложнения необходимы при взаимодействии с конвейером в операционной системе, но в случае реализации потоков чисто в коде они будут обработаны автоматически.</p>
<p>Если вы хотите создать читаемый поток, который выдает произвольные форматы данных вместо строк и буферов - убедитесь что вы его инициализировали с соответствующей опцией: <code>Readable ({ objectMode: true })</code>.</p>
<h3 id="Использование-потока-на-чтение"><a href="#Использование-потока-на-чтение" class="headerlink" title="Использование потока на чтение "></a>Использование потока на чтение <a name="readable-usage"></a></h3><p>В большинстве случаев мы будем подключать такой поток к другому потоку, созданному нами или модулями наподобие <a href="https://npmjs.org/package/through" target="_blank" rel="external">through</a>, <a href="https://npmjs.org/package/concat-stream" target="_blank" rel="external">concat-stream</a>. Но иногда может потребоваться использовать его напрямую.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">process.stdin.on(<span class="string">'readable'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> buf = process.stdin.read();</div><div class="line">    <span class="built_in">console</span>.dir(buf);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ (echo abc; sleep 1; echo def; sleep 1; echo ghi) | node consume0.js</div><div class="line">&lt;Buffer 61 62 63 0a&gt;</div><div class="line">&lt;Buffer 64 65 66 0a&gt;</div><div class="line">&lt;Buffer 67 68 69 0a&gt;</div><div class="line">null</div></pre></td></tr></table></figure>
<p>Когда данные становятся доступными, возникает событие <code>&#39;readable&#39;</code>, и вы можете вызвать <code>.read()</code> чтобы получить следующую порцию данных из буффера.</p>
<p>Когда поток завершится, <code>.read()</code> вернет <code>null</code>, потому что не останется доступных для чтения байтов.</p>
<p>Вы можете запросить определенное количество байтов: <code>.read(n)</code>. Указание необходимого размера носит рекомендательный характер, и не сработает для потоков возвращающих объекты. Однако, все базовые потоки обязаны поддерживать данную опцию.</p>
<p>Пример чтения в буффер порциями по 3 байта:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">process.stdin.on(<span class="string">'readable'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> buf = process.stdin.read(<span class="number">3</span>);</div><div class="line">    <span class="built_in">console</span>.dir(buf.toString());</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Но, при запуске этого примера мы получим не все данные:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ (echo abc; sleep 1; echo def; sleep 1; echo ghi) | node consume1.js</div><div class="line">&apos;abc&apos;</div><div class="line">&apos;\nde&apos;</div><div class="line">&apos;f\ng&apos;</div></pre></td></tr></table></figure>
<p>Это произошло потому что последняя порция данных осталась во внутреннем буфере, и нам надо “подопнуть” их. Сделаем мы это сообщив с помощью <code>.read(0)</code> что нам надо больше чем только что полученные 3 байта данных:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">process.stdin.on(<span class="string">'readable'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> buf = process.stdin.read(<span class="number">3</span>);</div><div class="line">    <span class="built_in">console</span>.dir(buf.toString());</div><div class="line">    process.stdin.read(<span class="number">0</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Теперь наш код работает как и ожидалось:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ (echo abc; sleep <span class="number">1</span>; echo def; sleep <span class="number">1</span>; echo ghi) | node consume2.js</div><div class="line"><span class="string">'abc'</span></div><div class="line"><span class="string">'\nde'</span></div><div class="line"><span class="string">'f\ng'</span></div><div class="line"><span class="string">'hi\n'</span></div></pre></td></tr></table></figure>
<p>В случае, если вы получили больше данных чем вам требуется - можно использовать <code>.unshift()</code> чтобы вернуть их назад. Использование <code>.unshift()</code> помогает нам предотвратить получение ненужных частей.</p>
<p>К примеру, создадим парсер который разделяет абзац на строки с делителем - переносом строки:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> offset = <span class="number">0</span>;</div><div class="line"></div><div class="line">process.stdin.on(<span class="string">'readable'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> buf = process.stdin.read();</div><div class="line">    <span class="keyword">if</span> (!buf) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">for</span> (; offset &lt; buf.length; offset++) &#123;</div><div class="line">        <span class="keyword">if</span> (buf[offset] === <span class="number">0x0a</span>) &#123;</div><div class="line">            <span class="built_in">console</span>.dir(buf.slice(<span class="number">0</span>, offset).toString());</div><div class="line">            buf = buf.slice(offset + <span class="number">1</span>);</div><div class="line">            offset = <span class="number">0</span>;</div><div class="line">            process.stdin.unshift(buf);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    process.stdin.unshift(buf);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ tail -n +50000 /usr/share/dict/american-english | head -n10 | node lines.js</div><div class="line">&apos;hearties&apos;</div><div class="line">&apos;heartiest&apos;</div><div class="line">&apos;heartily&apos;</div><div class="line">&apos;heartiness&apos;</div><div class="line">&apos;heartiness\&apos;s&apos;</div><div class="line">&apos;heartland&apos;</div><div class="line">&apos;heartland\&apos;s&apos;</div><div class="line">&apos;heartlands&apos;</div><div class="line">&apos;heartless&apos;</div><div class="line">&apos;heartlessly&apos;</div></pre></td></tr></table></figure>
<p>Код выше приведен только для примера, если вам действительно нужно будет разбить строку - лучше будет воспользоваться специализированным модулем <a href="https://npmjs.org/package/split" target="_blank" rel="external">split</a> и не изобретать велосипед.</p>
<h2 id="Потоки-на-запись-writeable"><a href="#Потоки-на-запись-writeable" class="headerlink" title="Потоки на запись (writeable) "></a>Потоки на запись (writeable) <a name="writeable"></a></h2><p>В поток на запись можно послать данные используя <code>.pipe()</code>, но прочитать их уже не получится:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">src.pipe(writableStream)</div></pre></td></tr></table></figure>
<h3 id="Создание-потока-на-запись"><a href="#Создание-потока-на-запись" class="headerlink" title="Создание потока на запись "></a>Создание потока на запись <a name="writeable-create"></a></h3><p>Просто определяем методом <code>._write(chunk, enc, next)</code>, и теперь в наш поток можно передавать данные:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Writable = <span class="built_in">require</span>(<span class="string">'stream'</span>).Writable;</div><div class="line"><span class="keyword">var</span> ws = Writable();</div><div class="line">ws._write = <span class="function"><span class="keyword">function</span> (<span class="params">chunk, enc, next</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.dir(chunk);</div><div class="line">    next();</div><div class="line">&#125;;</div><div class="line"></div><div class="line">process.stdin.pipe(ws);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ (echo beep; sleep 1; echo boop) | node write0.js</div><div class="line">&lt;Buffer 62 65 65 70 0a&gt;</div><div class="line">&lt;Buffer 62 6f 6f 70 0a&gt;</div></pre></td></tr></table></figure>
<p>Первый аргумент, <code>chunk</code>, это данные которые посылает отправитель.</p>
<p>Второй аргумент, <code>enc</code>, это строка с названием кодировки. Она используется только в случае когда опция <code>opts.decodeString</code> установлена в <code>false</code>, и вы отправляете строку.</p>
<p>Третий аргумент, <code>next(err)</code>, является функцией обратного вызова (callback), сообщающей отправителю что можно послать еще данные. Если вы вызовите ее с параметром <code>err</code>, в потоке будет создано событие <code>&#39;error&#39;</code>.</p>
<p>В случае если поток из которого вы читаете передает строки, они будут преобразовываться в <code>Buffer</code>. Чтобы отключить преобразование - создайте поток на запись с соответствующим параметром: <code>Writable({ decodeStrings: false })</code>.</p>
<p>Если поток на чтение передает объекты - явно укажите это в параметрах: <code>Writable({ objectMode: true })</code>.</p>
<h3 id="Отправка-данных-в-поток-на-запись"><a href="#Отправка-данных-в-поток-на-запись" class="headerlink" title="Отправка данных в поток на запись "></a>Отправка данных в поток на запись <a name="writeable-usage"></a></h3><p>Чтобы передать данные в поток на запись - вызовите <code>.write(data)</code>, где <code>data</code> это набор данных которые вы хотите записать.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">process.stdout.write(<span class="string">'beep boop\n'</span>);</div></pre></td></tr></table></figure>
<p>Если вы хотите сообщить что вы закончили запись - вызовите <code>.end()</code> (или <code>.end(data)</code> чтобы отправить еще немного данных перед завершением):</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">var</span> ws = fs.createWriteStream(<span class="string">'message.txt'</span>);</div><div class="line"></div><div class="line">ws.write(<span class="string">'beep '</span>);</div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    ws.end(<span class="string">'boop\n'</span>);</div><div class="line">&#125;, <span class="number">1000</span>);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ node writing1.js</div><div class="line">$ cat message.txt</div><div class="line">beep boop</div></pre></td></tr></table></figure>
<p>Не беспокойтесь о синхронизации данных и буферизации, <code>.write()</code> вернет <code>false</code> если в буфере скопилось данных больше чем указывалось в параметре <code>opts.highWaterMark</code> при создании потока. В этом случае следует подождать события <code>&#39;drain&#39;</code>, которое сигнализирует о том что данные можно снова писать.</p>
<h2 id="Дуплексные-потоки-duplex"><a href="#Дуплексные-потоки-duplex" class="headerlink" title="Дуплексные потоки (duplex) "></a>Дуплексные потоки (duplex) <a name="duplex"></a></h2><p>Дуплексные потоки наследуют методы как от потоков на чтение, так и от потоков на запись. Это позволяет им действовать в обоих направлениях - читать данные, и записывать их в обе стороны. В качестве аналогии можно привести телефон. Если вам требуется сделать что-нибудь типа такого:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.pipe(b).pipe(a)</div></pre></td></tr></table></figure>
<p>значит вам нужен дуплексный поток.</p>
<h2 id="Трансформирующие-потоки-transform"><a href="#Трансформирующие-потоки-transform" class="headerlink" title="Трансформирующие потоки (transform) "></a>Трансформирующие потоки (transform) <a name="transform"></a></h2><p>Трансформирующие потоки это частный случай дуплексных потоков (в обоих случаях они могут использоваться как для записи, так и чтения). Разница в том, что в случае трансформации отдаваемые данные так или иначе зависят от того что подается на вход.</p>
<p>Возможно, вы также встречали второе название таких потоков - “сквозные” (“through streams”). В любом случае, это просто фильтры которые преобразовывают входящие данные и отдают их.</p>
<h2 id="Различия-в-реализации-потоков"><a href="#Различия-в-реализации-потоков" class="headerlink" title="Различия в реализации потоков "></a>Различия в реализации потоков <a name="difference"></a></h2><h3 id="streams1-устаревшее-API"><a href="#streams1-устаревшее-API" class="headerlink" title="streams1: устаревшее API "></a>streams1: устаревшее API <a name="streams1"></a></h3><p>В первых версиях node.js существовал <em>классический</em> (<strong>streams1</strong>) интерфейс потоков. Интерфейс поддерживал добавление данных в поток (push-режим), однако потребитель мог только слушать события <code>data</code> и <code>end</code>, буферизация не поддерживалась и данные легко было потерять. Разработчики вручную контролировали поток вызывая <code>.pause()</code> и <code>.resume()</code>. На текущий момент его практически нигде не используют. Если вы все таки работаете с подобным потоком - вам пригодится несколько практик.</p>
<p>К примеру, чтобы избежать установки слушателей <code>&quot;data&quot;</code> и <code>&quot;end&quot;</code> подойдет модуль <a href="https://npmjs.org/package/through" target="_blank" rel="external">through</a>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> through = <span class="built_in">require</span>(<span class="string">'through'</span>);</div><div class="line">process.stdin.pipe(through(write, end));</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">write</span> (<span class="params">buf</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(buf);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">end</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'__END__'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ (echo beep; sleep 1; echo boop) | node through.js</div><div class="line">&lt;Buffer 62 65 65 70 0a&gt;</div><div class="line">&lt;Buffer 62 6f 6f 70 0a&gt;</div><div class="line">__END__</div></pre></td></tr></table></figure>
<p>а для буферизации всего содержимого потока сойдет <a href="https://npmjs.org/package/concat-stream" target="_blank" rel="external">concat-stream</a>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> concat = <span class="built_in">require</span>(<span class="string">'concat-stream'</span>);</div><div class="line">process.stdin.pipe(concat(<span class="function"><span class="keyword">function</span> (<span class="params">body</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(body));</div><div class="line">&#125;));</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ echo &apos;&#123;&quot;beep&quot;:&quot;boop&quot;&#125;&apos; | node concat.js</div><div class="line">&#123; beep: &apos;boop&apos; &#125;</div></pre></td></tr></table></figure>
<p><em>У классических потоков на чтение для остановки и продолжения есть методы <code>.pause()</code> и <code>.resume()</code>, но их использования следует избегать. Если вам необходим этот функционал - рекомендуется не создавать логику самостоятельно, а использовать модуль <a href="https://npmjs.org/package/through" target="_blank" rel="external">through</a>.</em></p>
<h3 id="streams2-второе-поколение"><a href="#streams2-второе-поколение" class="headerlink" title="streams2: второе поколение "></a>streams2: второе поколение <a name="streams2"></a></h3><p>В node.js v0.10 появилось второе поколение потоков (<strong>streams2</strong>). Эти потоки всегда запускаются в режиме паузы, и у потребителей уже есть возможность запросить данные вызвав <code>.read(numBytes)</code> (pull-режим), присутствует буферизация. Ключевая особенность данного API - поток автоматически переключается в <em>классический</em> режим в целях совместимости если назначить обработчики на <code>data</code> и <code>end</code>. При этом поток снимается с режима паузы и отключается возможность использовать pull-режим. На момент написания статьи (11.07.2016) многие неактуальные модули работают в данном режиме, однако активно развивающиеся модули перешли на третье поколение.</p>
<h3 id="streams3-стабильная-реализация"><a href="#streams3-стабильная-реализация" class="headerlink" title="streams3: стабильная реализация "></a>streams3: стабильная реализация <a name="streams3"></a></h3><p>Начиная с node.js v0.11, концепция потоков переработана и <em>признана стабильной</em> -  в официальной документации описывается именно поведение <strong>streams3</strong>. По умолчанию потоки все еще запускаются в режиме паузы а назначение обработчиков снимает их с паузы. Однако, если использовать <code>.pause()</code> и вызвать метод <code>.read()</code> - соответствующие данные будут возвращены. Таким образом, потоки поддерживают как pull режим, так и push. При этом, можно смело использовать модули с streams2 так как они совместимы.</p>
<h2 id="Дополнительно"><a href="#Дополнительно" class="headerlink" title="Дополнительно "></a>Дополнительно <a name="additional"></a></h2><p>Вы прочитали про базовые понятия касающиеся потоков, если вы хотите узнать больше - обратитесь к актуальной <a href="http://nodejs.org/docs/latest/api/stream.html#stream_stream" target="_blank" rel="external">документация по потокам</a>. В случае если вам понадобится сделать API <strong>streams2</strong> потоков совместимым с “классическим” API <strong>streams1</strong> (например, при использовании устаревших версий node.js)- используйте модуль <a href="https://npmjs.org/package/readable-stream" target="_blank" rel="external">readable-stream</a>. Просто подключите его в свой проект: <code>require(&#39;readable-stream&#39;)</code> вместо <code>require(&#39;stream&#39;)</code>.</p>
<h1 id="Встроенные-потоки"><a href="#Встроенные-потоки" class="headerlink" title="Встроенные потоки "></a>Встроенные потоки <a name="internal"></a></h1><p>Эти потоки поставляются с node.js и могут быть использованы без подключения дополнительных библиотек.</p>
<h2 id="process"><a href="#process" class="headerlink" title="process"></a>process</h2><h3 id="process-stdin"><a href="#process-stdin" class="headerlink" title="process.stdin"></a><a href="http://nodejs.org/docs/latest/api/process.html#process_process_stdin" target="_blank" rel="external">process.stdin</a></h3><p>Поток на чтение содержит стандартный системный поток ввода для вашей программы.</p>
<p>По умолчанию он находится в режиме паузы, но после первого вызова <code>.resume()</code> он начнет исполняться в<br><a href="http://nodejs.org/docs/latest/api/process.html#process_process_nexttick_callback" target="_blank" rel="external">следующем системном тике</a>.</p>
<p>Если process.stdin указывает на терминал (проверяется вызовом<br><a href="http://nodejs.org/docs/latest/api/tty.html#tty_tty_isatty_fd" target="_blank" rel="external"><code>tty.isatty()</code></a>), тогда входящие данные будут буферизироваться построчно. Вы можете выключить построчную буферизацию вызвав <code>process.stdin.setRawMode(true)</code>. Однако, имейте ввиду что в этом случае обработчики системных нажатий (таких как<code>^C</code> и <code>^D</code>) будут удалены.</p>
<h3 id="process-stdout"><a href="#process-stdout" class="headerlink" title="process.stdout"></a><a href="http://nodejs.org/api/process.html#process_process_stdout" target="_blank" rel="external">process.stdout</a></h3><p>Поток на запись, содержащий стандартный системный вывод для вашей программы. Посылайте туда данные, если вам нужно передать их в stdout.</p>
<h3 id="process-stderr"><a href="#process-stderr" class="headerlink" title="process.stderr"></a><a href="http://nodejs.org/api/process.html#process_process_stderr" target="_blank" rel="external">process.stderr</a></h3><p>Поток на запись, содержащий стандартный системный вывод ошибок для вашей программы. Посылайте туда данные, если вам нужно передать их в stderr.</p>
<h2 id="child-process-spawn"><a href="#child-process-spawn" class="headerlink" title="child_process.spawn()"></a><a href="https://nodejs.org/api/child_process.html" target="_blank" rel="external">child_process.spawn()</a></h2><p>Данная функция запускает процесс, и возвращает объект содержащий stderr/stdin/stdout потоки данного процесса.</p>
<h3 id="fs-createReadStream"><a href="#fs-createReadStream" class="headerlink" title="fs.createReadStream()"></a><a href="https://nodejs.org/api/fs.html#fs_fs_createreadstream_path_options" target="_blank" rel="external">fs.createReadStream()</a></h3><p>Поток на чтение, содержащий указанный файл. Используйте, если вам надо прочесть большой файл без больших затрат ресурсов.</p>
<h3 id="fs-createWriteStream"><a href="#fs-createWriteStream" class="headerlink" title="fs.createWriteStream()"></a><a href="https://nodejs.org/api/fs.html#fs_fs_createwritestream_path_options" target="_blank" rel="external">fs.createWriteStream()</a></h3><p>Поток на запись, позволяющий сохранить переданные данные в файл.</p>
<h2 id="net"><a href="#net" class="headerlink" title="net"></a>net</h2><h3 id="net-connect"><a href="#net-connect" class="headerlink" title="net.connect()"></a><a href="http://nodejs.org/docs/latest/api/net.html#net_net_connect_options_connectionlistener" target="_blank" rel="external">net.connect()</a></h3><p>Данная функция вернет дуплексный поток, который позволяет подключиться к удаленному хосту по протоколу tcp.</p>
<p>Все данные которые вы будете в него записывать будут буферизироваться до тех пор, пока не возникнет событие <code>&#39;connect&#39;</code>.</p>
<h3 id="net-createServer"><a href="#net-createServer" class="headerlink" title="net.createServer()"></a><a href="https://nodejs.org/api/net.html#net_net_createserver_options_connectionlistener" target="_blank" rel="external">net.createServer()</a></h3><p>Создает сервер для обработки входящих соединений. Параметром передается функция обратного вызова (callback), которая вызывается при создании соединения, и содержит поток на запись.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</div><div class="line"><span class="keyword">const</span> server = net.createServer(<span class="function">(<span class="params">c</span>) =&gt;</span> &#123;</div><div class="line">  <span class="comment">// 'connection' listener</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'client connected'</span>);</div><div class="line">  c.on(<span class="string">'end'</span>, () =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'client disconnected'</span>);</div><div class="line">  &#125;);</div><div class="line">  c.write(<span class="string">'hello\r\n'</span>);</div><div class="line">  c.pipe(c);</div><div class="line">&#125;);</div><div class="line">server.on(<span class="string">'error'</span>, (err) =&gt; &#123;</div><div class="line">  <span class="keyword">throw</span> err;</div><div class="line">&#125;);</div><div class="line">server.listen(<span class="number">8124</span>, () =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'server bound'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="http-request"><a href="#http-request" class="headerlink" title="http.request()"></a><a href="https://nodejs.org/api/http.html#http_http_request_options_callback" target="_blank" rel="external">http.request()</a></h3><p>Создает поток на чтение, позволяющий сделать запрос к веб-серверу и вернуть результат.</p>
<h3 id="http-createServer"><a href="#http-createServer" class="headerlink" title="http.createServer()"></a><a href="https://nodejs.org/api/http.html#http_http_createserver_requestlistener" target="_blank" rel="external">http.createServer()</a></h3><p>Создает сервер для обработки входящих веб-запросов. Параметром передается функция обратного вызова (callback), которая вызывается при создании соединения, и содержит поток на запись.</p>
<h3 id="zlib-createGzip"><a href="#zlib-createGzip" class="headerlink" title="zlib.createGzip()"></a><a href="https://nodejs.org/api/zlib.html#zlib_zlib_creategzip_options" target="_blank" rel="external">zlib.createGzip()</a></h3><p>Трансформирующий поток, который отдает на выходе запакованный gzip.</p>
<h3 id="zlib-createGunzip"><a href="#zlib-createGunzip" class="headerlink" title="zlib.createGunzip()"></a><a href="https://nodejs.org/api/zlib.html#zlib_zlib_creategunzip_options" target="_blank" rel="external">zlib.createGunzip()</a></h3><p>Трансформирующий поток, распаковывает gzip-поток.</p>
<h3 id="zlib-createDeflate"><a href="#zlib-createDeflate" class="headerlink" title="zlib.createDeflate()"></a><a href="https://nodejs.org/api/zlib.html#zlib_zlib_createdeflate_options" target="_blank" rel="external">zlib.createDeflate()</a></h3><h3 id="zlib-createInflate"><a href="#zlib-createInflate" class="headerlink" title="zlib.createInflate()"></a><a href="https://nodejs.org/api/zlib.html#zlib_zlib_createinflate_options" target="_blank" rel="external">zlib.createInflate()</a></h3><h1 id="Сторонние-потоки"><a href="#Сторонние-потоки" class="headerlink" title="Сторонние потоки "></a>Сторонние потоки <a name="external"></a></h1><h2 id="Список-модулей"><a href="#Список-модулей" class="headerlink" title="Список модулей "></a>Список модулей <a name="modules"></a></h2><p>Ниже приведен список npm-модулей, работающих с потоками. Список является далеко не полным, постоянно появляются новые модули и их нет возможности отслеживать. Цель данной таблицы - дать представление о “кирпичиках”, из которых вы можете собрать свое приложение. Не стесняйтесь проходить по ссылкам и изучать документацию, там есть более подробное описание и примеры использования.</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/dominictarr/through" target="_blank" rel="external">through</a></td>
<td>Простой способ создания дуплексного потока или конвертации “классического” в современный</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/dominictarr/from" target="_blank" rel="external">from</a></td>
<td>Аналог through, только для создания потока для чтения</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/dominictarr/pause-stream" target="_blank" rel="external">pause-stream</a></td>
<td>Позволяет буферизировать поток и получать результат буфера в произвольный момент</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/maxogden/node-concat-stream" target="_blank" rel="external">concat-stream</a></td>
<td>Буферизирует поток в один общий буфер. <code>concat(cb)</code> принимает параметром только один аргумент - функцию <code>cb(body)</code>, которая вернет <code>body</code> когда поток завершится</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/dominictarr/duplex" target="_blank" rel="external">duplex</a>, <a href="https://github.com/Raynos/duplexer" target="_blank" rel="external">duplexer</a></td>
<td>Создание дуплексного потока</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/substack/emit-stream" target="_blank" rel="external">emit-stream</a></td>
<td>Конвертирует события (event-emitter) в поток, и обратно</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/dominictarr/invert-stream" target="_blank" rel="external">invert-stream</a></td>
<td>Создает из двух потоков один, “соединяя” вход первого потока с выходом второго и наоборот</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/dominictarr/map-stream" target="_blank" rel="external">map-stream</a></td>
<td>Создает трансформирующий поток для заданной асинхронной функции</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/dominictarr/remote-events" target="_blank" rel="external">remote-events</a></td>
<td>Позволяет объединять несколько эмиттеров событий в единый поток</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/Raynos/buffer-stream" target="_blank" rel="external">buffer-stream</a></td>
<td>Дуплексный поток, буферизирующий проходящие через него данные</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/caolan/highland" target="_blank" rel="external">highland</a></td>
<td>Управление асинхронным кодом с использованием потоков</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/Raynos/auth-stream" target="_blank" rel="external">auth-stream</a></td>
<td>Добавление слоя авторизации для доступа к потокам</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/dominictarr/mux-demux" target="_blank" rel="external">mux-demux</a></td>
<td>Создание мультифункциональных потоков на основе любых текстовых.</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/Raynos/stream-router" target="_blank" rel="external">stream-router</a></td>
<td>Роутер для потоков, созданных с помощью <code>mux-demux</code></td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/Raynos/multi-channel-mdm" target="_blank" rel="external">multi-channel-mdm</a></td>
<td>Создание постоянных потоков (каналов) из потоков <code>mux-demux</code></td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/dominictarr/crdt" target="_blank" rel="external">crdt</a>, <a href="https://github.com/Raynos/delta-stream" target="_blank" rel="external">delta-stream</a>, <a href="https://github.com/dominictarr/scuttlebutt" target="_blank" rel="external">scuttlebutt</a></td>
<td>Данная коллекция потоков предполагает, что операции над данными всегда возвращают один и тот же результат вне зависимости от порядка этих операций</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/mikeal/request" target="_blank" rel="external">request</a></td>
<td>Создание http-запросов</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/juliangruber/reconnect-core" target="_blank" rel="external">reconnect-core</a></td>
<td>Базовый настраиваемый интерфейс для переподключения потоков при возникновении проблем в сети</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/dominictarr/kv" target="_blank" rel="external">kv</a></td>
<td>Абстрактный поток, предоставляющий враппер для доступа к различным key-value хранилищам</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/substack/node-trumpet" target="_blank" rel="external">trumpet</a></td>
<td>Трансформация html-текста с использованием css-селекторов</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/dominictarr/JSONStream" target="_blank" rel="external">JSONStream</a></td>
<td>Преобразование <code>JSON.parse</code> и <code>JSON.stringify</code>. Примеры использования - обработка большого объема JSON-данных при недостаточном количестве оперативной памяти, обработка json “на лету” при получении его через медленные каналы, и т.п.</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/substack/shoe" target="_blank" rel="external">shoe</a></td>
<td>Трансляция вебсокет событий.</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/substack/dnode" target="_blank" rel="external">dnode</a></td>
<td>Данный модуль дает вам возможность вызывать удаленные функции (RPC) через любой поток</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/isaacs/node-tap" target="_blank" rel="external">tap</a></td>
<td>Фреймворк для тестирования node.js на основе потоков.</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/dominictarr/stream-spec" target="_blank" rel="external">stream-spec</a></td>
<td>Способ описания спецификации потоков, для автоматизации их тестирования.</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="Примеры-использования"><a href="#Примеры-использования" class="headerlink" title="Примеры использования "></a>Примеры использования <a name="examples"></a></h2><p><code>pause-stream</code> позволяет буферизировать поток и получать результат буфера в произвольный момент:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ps = <span class="built_in">require</span>(<span class="string">'pause-stream'</span>)();</div><div class="line"></div><div class="line">badlyBehavedStream.pipe(ps.pause())</div><div class="line"></div><div class="line">aLittleLater(<span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</div><div class="line">  ps.pipe(createAnotherStream(data))</div><div class="line">  ps.resume()</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<hr>
<p>В данном примере <code>concat-stream</code>  вернет строку <code>&quot;beep boop&quot;</code> только после того как вызовется <code>cs.end()</code>. Результат работы программы - перевод строки в верхний регистр:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> concat = <span class="built_in">require</span>(<span class="string">'concat-stream'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> cs = concat(<span class="function"><span class="keyword">function</span> (<span class="params">body</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(body.toUpperCase());</div><div class="line">&#125;);</div><div class="line">cs.write(<span class="string">'beep '</span>);</div><div class="line">cs.write(<span class="string">'boop.'</span>);</div><div class="line">cs.end();</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ node concat.js</div><div class="line">BEEP BOOP.</div></pre></td></tr></table></figure>
<hr>
<p>Следующий пример с <code>concat-stream</code> обработает строку с параметрами, и вернет их уже в JSON:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">var</span> qs = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</div><div class="line"><span class="keyword">var</span> concat = <span class="built_in">require</span>(<span class="string">'concat-stream'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">    req.pipe(concat(<span class="function"><span class="keyword">function</span> (<span class="params">body</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> params = qs.parse(body.toString());</div><div class="line">        res.end(<span class="built_in">JSON</span>.stringify(params) + <span class="string">'\n'</span>);</div><div class="line">    &#125;));</div><div class="line">&#125;);</div><div class="line">server.listen(<span class="number">5005</span>);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ curl -X POST -d &apos;beep=boop&amp;dinosaur=trex&apos; http://localhost:5005</div><div class="line">&#123;&quot;beep&quot;:&quot;boop&quot;,&quot;dinosaur&quot;:&quot;trex&quot;&#125;</div></pre></td></tr></table></figure>
<hr>
<p>В данном примере используются <code>JSONStream</code> и <code>emit-stream</code> и <code>net</code>. Будет создан сервер который автоматически отправит все события клиенту:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> emitStream = <span class="built_in">require</span>(<span class="string">'emit-stream'</span>);</div><div class="line"><span class="keyword">var</span> JSONStream = <span class="built_in">require</span>(<span class="string">'JSONStream'</span>);</div><div class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> server = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> ev = createEmitter();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> net.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">stream</span>) </span>&#123;</div><div class="line">        emitStream(ev)</div><div class="line">            .pipe(JSONStream.stringify())</div><div class="line">            .pipe(stream)</div><div class="line">        ;</div><div class="line">    &#125;);</div><div class="line">&#125;)();</div><div class="line">server.listen(<span class="number">5555</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createEmitter</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> ev = <span class="keyword">new</span> EventEmitter;</div><div class="line">    setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        ev.emit(<span class="string">'ping'</span>, <span class="built_in">Date</span>.now());</div><div class="line">    &#125;, <span class="number">2000</span>);</div><div class="line"></div><div class="line">    <span class="keyword">var</span> x = <span class="number">0</span>;</div><div class="line">    setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        ev.emit(<span class="string">'x'</span>, x ++);</div><div class="line">    &#125;, <span class="number">500</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> ev;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Клиент, со своей стороны, может автоматически конвертировать приходящие данные обратно в события:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> emitStream = <span class="built_in">require</span>(<span class="string">'emit-stream'</span>);</div><div class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> stream = net.connect(<span class="number">5555</span>)</div><div class="line">    .pipe(JSONStream.parse([<span class="literal">true</span>]))</div><div class="line">;</div><div class="line"><span class="keyword">var</span> ev = emitStream(stream);</div><div class="line"></div><div class="line">ev.on(<span class="string">'ping'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">t</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'# ping: '</span> + t);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">ev.on(<span class="string">'x'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'x = '</span> + x);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<hr>
<p>Данная программа создаст из stdin и stdout дуплексный поток с помощью <code>invert-stream</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> spawn = <span class="built_in">require</span>(<span class="string">'child_process'</span>).spawn</div><div class="line">  <span class="keyword">var</span> invert = <span class="built_in">require</span>(<span class="string">'invert-stream'</span>)</div><div class="line"></div><div class="line">  <span class="keyword">var</span> ch = spawn(cmd, args)</div><div class="line">  <span class="keyword">var</span> inverted = invert()</div><div class="line"></div><div class="line">  ch.stdout.pipe(inverted.other).pipe(ch.sdin)</div><div class="line"></div><div class="line">  <span class="comment">//now, we have just ONE stream: inverted</span></div><div class="line"></div><div class="line">  <span class="comment">//write to che ch's stdin</span></div><div class="line">  inverted.write(data)</div><div class="line"></div><div class="line">  <span class="comment">//read from ch's stdout</span></div><div class="line">  inverted.on(<span class="string">'data'</span>, <span class="built_in">console</span>.log)</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> map = <span class="built_in">require</span>(<span class="string">'map-stream'</span>)</div><div class="line"></div><div class="line">map(<span class="function"><span class="keyword">function</span> (<span class="params">data, callback</span>) </span>&#123;</div><div class="line">  <span class="comment">//transform data</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">  callback(<span class="literal">null</span>, data)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<hr>
<p>Для создания потока, работающего с датами, тут мы используем <code>mux-demux</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MuxDemux = <span class="built_in">require</span>(<span class="string">'mux-demux'</span>)</div><div class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>)</div><div class="line"></div><div class="line">net.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">con</span>) </span>&#123;</div><div class="line">  con.pipe(MuxDemux(<span class="function"><span class="keyword">function</span> (<span class="params">stream</span>) </span>&#123;</div><div class="line">    stream.on(<span class="string">'data'</span>, <span class="built_in">console</span>.log.bind(<span class="built_in">console</span>))</div><div class="line">  &#125;)).pipe(con)</div><div class="line">&#125;).listen(<span class="number">8642</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> con = net.connect(<span class="number">8642</span>), mx</div><div class="line">  con.pipe(mx = MuxDemux()).pipe(con)</div><div class="line"></div><div class="line">  <span class="keyword">var</span> ds = mx.createWriteStream(<span class="string">'times'</span>)</div><div class="line"></div><div class="line">  setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    ds.write(<span class="keyword">new</span> <span class="built_in">Date</span>().toString())</div><div class="line">  &#125;, <span class="number">1e3</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="Мощные-комбинации"><a href="#Мощные-комбинации" class="headerlink" title="Мощные комбинации "></a>Мощные комбинации <a name="cool"></a></h2><p>Статья была бы не полной без рассказа о той магии, которую можно совершать используя комбинации различных потоков. Давайте рассмотрим некоторые из них.</p>
<h3 id="Создание-распределенной-сети"><a href="#Создание-распределенной-сети" class="headerlink" title="Создание распределенной сети "></a>Создание распределенной сети <a name="mesh"></a></h3><p>Модуль <code>scuttlebutt</code> может быть использован для синхронизации состояния между узлами mesh-сети, где узлы непосредственно не связаны между собой и нет единого мастера (аналог торрент-клиента).</p>
<p>Под капотом у <code>scuttlebutt</code> используется широко известный в узких кругах протокол <a href="https://en.wikipedia.org/wiki/Gossip_protocol" target="_blank" rel="external">gossip</a>, который гарантирует что все узлы будут возвращать <a href="https://ru.wikipedia.org/wiki/Консистентность_в_конечном_счёте" target="_blank" rel="external">последнее актуальное значение</a>.</p>
<p>Используя интерфейс <code>scuttlebutt/model</code>, мы можем создавать клиентов и связывать их между собой:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Model = <span class="built_in">require</span>(<span class="string">'scuttlebutt/model'</span>);</div><div class="line"><span class="keyword">var</span> am = <span class="keyword">new</span> Model;</div><div class="line"><span class="keyword">var</span> <span class="keyword">as</span> = am.createStream();</div><div class="line"></div><div class="line"><span class="keyword">var</span> bm = <span class="keyword">new</span> Model;</div><div class="line"><span class="keyword">var</span> bs = bm.createStream();</div><div class="line"></div><div class="line"><span class="keyword">var</span> cm = <span class="keyword">new</span> Model;</div><div class="line"><span class="keyword">var</span> cs = cm.createStream();</div><div class="line"></div><div class="line"><span class="keyword">var</span> dm = <span class="keyword">new</span> Model;</div><div class="line"><span class="keyword">var</span> ds = dm.createStream();</div><div class="line"></div><div class="line"><span class="keyword">var</span> em = <span class="keyword">new</span> Model;</div><div class="line"><span class="keyword">var</span> es = em.createStream();</div><div class="line"></div><div class="line"><span class="keyword">as</span>.pipe(bs).pipe(<span class="keyword">as</span>);</div><div class="line">bs.pipe(cs).pipe(bs);</div><div class="line">bs.pipe(ds).pipe(bs);</div><div class="line">ds.pipe(es).pipe(ds);</div><div class="line"></div><div class="line">em.on(<span class="string">'update'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">key, value, source</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(key + <span class="string">' =&gt; '</span> + value + <span class="string">' from '</span> + source);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">am.set(<span class="string">'x'</span>, <span class="number">555</span>);</div></pre></td></tr></table></figure>
<p>Мы создали сеть в форме ненаправленного графа, которая выглядит так:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a &lt;-&gt; b &lt;-&gt; c</div><div class="line">      ^</div><div class="line">      |</div><div class="line">      v</div><div class="line">      d &lt;-&gt; e</div></pre></td></tr></table></figure>
<p>Узлы <code>a</code> и <code>e</code> напрямую не соединены, но если мы выполним команду:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ node model.js</div><div class="line">x =&gt; 555 from 1347857300518</div></pre></td></tr></table></figure>
<p>то увидим что узел  <code>a</code> будет доступен узлу <code>e</code> через узлы <code>b</code>и <code>d</code>. Учитывая то, что <code>scuttlebutt</code> использует простой потоковый интерфейс, и все узлы гарантированно получат данные - мы можем соединить любой процесс, сервер или транспорт которые поддерживают обработку строк.</p>
<p>Давайте создадим более реалистичный пример. В нем мы будем соединяться через сеть, и увеличивать счетчик каждые 320 миллисекунд на всех узлах:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Model = <span class="built_in">require</span>(<span class="string">'scuttlebutt/model'</span>);</div><div class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> Model;</div><div class="line">m.set(<span class="string">'count'</span>, <span class="string">'0'</span>);</div><div class="line">m.on(<span class="string">'update'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(key + <span class="string">' = '</span> + m.get(<span class="string">'count'</span>));</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> server = net.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">stream</span>) </span>&#123;</div><div class="line">    stream.pipe(m.createStream()).pipe(stream);</div><div class="line">&#125;);</div><div class="line">server.listen(<span class="number">8888</span>);</div><div class="line"></div><div class="line">setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    m.set(<span class="string">'count'</span>, <span class="built_in">Number</span>(m.get(<span class="string">'count'</span>)) + <span class="number">1</span>);</div><div class="line">&#125;, <span class="number">320</span>);</div></pre></td></tr></table></figure>
<p>Теперь создадим клиента, который подключается к серверу, получает обновления и выводит их на экран:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Model = <span class="built_in">require</span>(<span class="string">'scuttlebutt/model'</span>);</div><div class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> Model;</div><div class="line"><span class="keyword">var</span> s = m.createStream();</div><div class="line"></div><div class="line">s.pipe(net.connect(<span class="number">8888</span>, <span class="string">'localhost'</span>)).pipe(s);</div><div class="line"></div><div class="line">m.on(<span class="string">'update'</span>, <span class="function"><span class="keyword">function</span> <span class="title">cb</span> (<span class="params">key</span>) </span>&#123;</div><div class="line">    <span class="comment">// wait until we've gotten at least one count value from the network</span></div><div class="line">    <span class="keyword">if</span> (key !== <span class="string">'count'</span>) <span class="keyword">return</span>;</div><div class="line">    m.removeListener(<span class="string">'update'</span>, cb);</div><div class="line"></div><div class="line">    setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        m.set(<span class="string">'count'</span>, <span class="built_in">Number</span>(m.get(<span class="string">'count'</span>)) + <span class="number">1</span>);</div><div class="line">    &#125;, <span class="number">100</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">m.on(<span class="string">'update'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(key + <span class="string">' = '</span> + value);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Клиент получился чуть-чуть сложнее, так как ему приходится ждать обновления от остальных участников прежде чем убедиться что он может увеличить счетчик.</p>
<p>После того как мы запустим сервер и несколько клиентов - мы увидим изменения счетчика наподобие такого:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">count = 183</div><div class="line">count = 184</div><div class="line">count = 185</div><div class="line">count = 186</div><div class="line">count = 187</div><div class="line">count = 188</div><div class="line">count = 189</div></pre></td></tr></table></figure>
<p>Время от времени на некоторых узлах мы будем замечать что значения повторяются:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">count = 147</div><div class="line">count = 148</div><div class="line">count = 149</div><div class="line">count = 149</div><div class="line">count = 150</div><div class="line">count = 151</div></pre></td></tr></table></figure>
<p>Это происходит потому, что мы не предоставили достаточно данных алгоритму для разрешения временных конфликтов, и ему сложнее поддерживать синхронизацию всех узлов. К сожалению, дальнейшее развитие примера выходит за пределы данной статьи, поэтому рекомендуем самостоятельно изучить <code>scuttlebutt</code>.</p>
<p>Обратите внимание, что в вышеприведенных примерах сервер это всего лишь еще один узел с теми же привилегиями что и остальные клиенты. Понятия “клиент” и “сервер” не затрагивают способы синхронизации данных, в данном сервер это “тот кто первым создал соединение”. Подобные протоколы называют “симметричными”, еще один пример подобного протокола можно посмотреть в реализации модуля <code>dnode</code>.</p>
<h3 id="Клиент-серверный-RPC"><a href="#Клиент-серверный-RPC" class="headerlink" title="Клиент-серверный RPC "></a>Клиент-серверный RPC <a name="rpc"></a></h3><p>Для примера, создадим простой сервер <code>dnode</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dnode = <span class="built_in">require</span>(<span class="string">'dnode'</span>);</div><div class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> server = net.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">c</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> d = dnode(&#123;</div><div class="line">        <span class="attr">transform</span> : <span class="function"><span class="keyword">function</span> (<span class="params">s, cb</span>) </span>&#123;</div><div class="line">            cb(s.replace(<span class="regexp">/[aeiou]&#123;2,&#125;/</span>, <span class="string">'oo'</span>).toUpperCase())</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    c.pipe(d).pipe(c);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">server.listen(<span class="number">5004</span>);</div></pre></td></tr></table></figure>
<p>потом напишем клиента, который вызывает метод сервера <code>.transform()</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dnode = <span class="built_in">require</span>(<span class="string">'dnode'</span>);</div><div class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> d = dnode();</div><div class="line">d.on(<span class="string">'remote'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">remote</span>) </span>&#123;</div><div class="line">    remote.transform(<span class="string">'beep'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'beep =&gt; '</span> + s);</div><div class="line">        d.end();</div><div class="line">    &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> c = net.connect(<span class="number">5004</span>);</div><div class="line">c.pipe(d).pipe(c);</div></pre></td></tr></table></figure>
<p>После запуска, клиент выведет следующий текст:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ node client.js</div><div class="line">beep =&gt; BOOP</div></pre></td></tr></table></figure>
<p>Клиент послал <code>&#39;beep&#39;</code> на сервер, запросив выполнение метода <code>.transform()</code>, сервер вернул результат.</p>
<p>Интерфейс, который предоставляет <code>dnode</code>, является дуплексным потоком. Таким образом, так как и клиент и сервер подключены друг к другу (<code>c.pipe(d).pipe(c)</code>), запросы можно выполнять в обе стороны.</p>
<p><code>dnode</code> раскрывает себя во всей красе когда вы начинаете передавать аргументы к предоставленным методам. Посмотрим на обновленную версию предыдущего сервера:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dnode = <span class="built_in">require</span>(<span class="string">'dnode'</span>);</div><div class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> server = net.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">c</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> d = dnode(&#123;</div><div class="line">        <span class="attr">transform</span> : <span class="function"><span class="keyword">function</span> (<span class="params">s, cb</span>) </span>&#123;</div><div class="line">            cb(<span class="function"><span class="keyword">function</span> (<span class="params">n, fn</span>) </span>&#123;</div><div class="line">                <span class="keyword">var</span> oo = <span class="built_in">Array</span>(n+<span class="number">1</span>).join(<span class="string">'o'</span>);</div><div class="line">                fn(s.replace(<span class="regexp">/[aeiou]&#123;2,&#125;/</span>, oo).toUpperCase());</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    c.pipe(d).pipe(c);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">server.listen(<span class="number">5004</span>);</div></pre></td></tr></table></figure>
<p>Вот обновленный клиент:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dnode = <span class="built_in">require</span>(<span class="string">'dnode'</span>);</div><div class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> d = dnode();</div><div class="line">d.on(<span class="string">'remote'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">remote</span>) </span>&#123;</div><div class="line">    remote.transform(<span class="string">'beep'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">cb</span>) </span>&#123;</div><div class="line">        cb(<span class="number">10</span>, <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'beep:10 =&gt; '</span> + s);</div><div class="line">            d.end();</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> c = net.connect(<span class="number">5004</span>);</div><div class="line">c.pipe(d).pipe(c);</div></pre></td></tr></table></figure>
<p>После запуска клиента, мы увидим:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ node client.js</div><div class="line">beep:10 =&gt; BOOOOOOOOOOP</div></pre></td></tr></table></figure>
<p>Сервер увидел аргумент, и выполнил функцию с ним!</p>
<p>Основная идея такая: вы просто кладете функцию в объект, и на другой стороне земного шара вызываете идентичную функцию с нужными вам аргументами. Вместо того чтобы выполниться локально, данные передаются на сервер и функция возвращает результат удаленного выполнения. Это просто работает.</p>
<p><code>dnode</code> работает через потоки как в node.js, так и в браузере. Удобно комбинировать потоки через <code>mux-demux</code> для создания мультиплексного потока, работающего в обе стороны.</p>
<h3 id="Собственная-реализация-socket-io"><a href="#Собственная-реализация-socket-io" class="headerlink" title="Собственная реализация socket.io "></a>Собственная реализация socket.io <a name="socket"></a></h3><p>Мы можем создать собственное API для генерации событий через websocket с использованием потоков.</p>
<p>Сперва, используем <code>shoe</code> для создания серверного обработчика вебсокетов, и <code>emit-stream</code> чтобы превратить эмиттер событий в поток, который генерирует объекты.</p>
<p>Далее, поток с объектами мы подключаем к <code>JSONStream</code>, с целью преобразовать объект в строку готовую для передачи в сеть.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter;</div><div class="line"><span class="keyword">var</span> shoe = <span class="built_in">require</span>(<span class="string">'shoe'</span>);</div><div class="line"><span class="keyword">var</span> emitStream = <span class="built_in">require</span>(<span class="string">'emit-stream'</span>);</div><div class="line"><span class="keyword">var</span> JSONStream = <span class="built_in">require</span>(<span class="string">'JSONStream'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> sock = shoe(<span class="function"><span class="keyword">function</span> (<span class="params">stream</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> ev = <span class="keyword">new</span> EventEmitter;</div><div class="line">    emitStream(ev)</div><div class="line">        .pipe(JSONStream.stringify())</div><div class="line">        .pipe(stream)</div><div class="line">    ;</div><div class="line">    ...</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Теперь мы можем прозрачно генерировать события используя метод эмиттера <code>ev</code>. К примеру, несколько событий через разные промежутки времени:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> intervals = [];</div><div class="line"></div><div class="line">intervals.push(setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    ev.emit(<span class="string">'upper'</span>, <span class="string">'abc'</span>);</div><div class="line">&#125;, <span class="number">500</span>));</div><div class="line"></div><div class="line">intervals.push(setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    ev.emit(<span class="string">'lower'</span>, <span class="string">'def'</span>);</div><div class="line">&#125;, <span class="number">300</span>));</div><div class="line"></div><div class="line">stream.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    intervals.forEach(clearInterval);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Наконец, экземпляр <code>shoe</code> привяжем к http-серверу:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">var</span> server = http.createServer(<span class="built_in">require</span>(<span class="string">'ecstatic'</span>)(__dirname));</div><div class="line">server.listen(<span class="number">8080</span>);</div><div class="line"></div><div class="line">sock.install(server, <span class="string">'/sock'</span>);</div></pre></td></tr></table></figure>
<p>Между тем, на стороне браузера поток от <code>shoe</code> содержащий json обрабатывается и получившиеся объекты передаются в <code>eventStream()</code>. Таким образом, <code>eventStream()</code> возвращает эмиттер который генерирует переданные сервером события:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> shoe = <span class="built_in">require</span>(<span class="string">'shoe'</span>);</div><div class="line"><span class="keyword">var</span> emitStream = <span class="built_in">require</span>(<span class="string">'emit-stream'</span>);</div><div class="line"><span class="keyword">var</span> JSONStream = <span class="built_in">require</span>(<span class="string">'JSONStream'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> parser = JSONStream.parse([<span class="literal">true</span>]);</div><div class="line"><span class="keyword">var</span> stream = parser.pipe(shoe(<span class="string">'/sock'</span>)).pipe(parser);</div><div class="line"><span class="keyword">var</span> ev = emitStream(stream);</div><div class="line"></div><div class="line">ev.on(<span class="string">'lower'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</div><div class="line">    div.textContent = msg.toLowerCase();</div><div class="line">    <span class="built_in">document</span>.body.appendChild(div);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">ev.on(<span class="string">'upper'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</div><div class="line">    div.textContent = msg.toUpperCase();</div><div class="line">    <span class="built_in">document</span>.body.appendChild(div);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Используем <a href="https://github.com/substack/node-browserify" target="_blank" rel="external">browserify</a> для генерации кода в браузере, чтобы мы могли делать <code>require()</code> прямо в файле:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ browserify main.js -o bundle.js</div></pre></td></tr></table></figure>
<p>Подключаем <code>&lt;script src=&quot;/bundle.js&quot;&gt;&lt;/script&gt;</code> в html-страницу, открываем ее в браузере и наслаждаемся серверными событиями которые отображаются в браузере.</p>
<h1 id="Заключение"><a href="#Заключение" class="headerlink" title="Заключение "></a>Заключение <a name="conclusion"></a></h1><p>Начав использовать потоки и планировать с их помощью процесс разработки программ, вы заметите что стали больше полагаться на маленькие переиспользуемые компоненты которым не нужно ничего кроме общего интерфейса потоков. Вместо маршрутизации сообщений через глобальную систему событий и настройки обработчиков вы сфокусируетесь на разбиении приложения на мелкие компоненты, хорошо выполняющими какую-то одну задачу.</p>
<p>В примерах вы можете легко заменить <code>JSONStream</code> на <code>stream-serializer</code> чтобы получить немного другой способ преобразования в строку. Вы можете добавить дополнительный слой чтобы обрабатывать потери связи с помощью <code>reconnect-core</code>. Если вы захотите использовать события с областью видимости - вы вставите дополнительный поток с поддержкой <a href="https://npmjs.org/package/eventemitter2" target="_blank" rel="external">eventemitter2</a>. В случае если вам потребуется изменить поведение некоторых частей потока вы сможете пропустить его через <code>mux-demux</code> и разделить на отдельные каналы каждый со своей логикой.</p>
<p>С течением времени, при изменении требований к приложению, вы легко сможете заменять устаревшие компоненты новыми, с гораздо меньшим риском получить в результате неработающую систему.</p>
  </section> <footer class='post-footer clearfix'>   <div class="addthis_toolbox addthis_default_style pull-right"> <a class="addthis_button_facebook"></a> <a class="addthis_button_twitter"></a> <a class="addthis_button_vk"></a> <a class="addthis_button_compact"></a> <a class="addthis_counter addthis_bubble_style"></a></div><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>  </footer> </div></article><section id="comment"> <h3 class="title">Комментарии</h3> <div id="disqus_thread"> <noscript>Включите Javascript, чтобы просмотреть <a href="//disqus.com/?ref_noscript">комментарии с помощью Disqus.</a></noscript> </div></section></div> <aside class="span2">  <div class="widget tag"> <h3 class="title">Тэги</h3> <ul class="unstyled">  <li> <span class='badge'>31</span> <a href="/blog/tags/AngularJS/"> AngularJS </a> </li>  <li> <span class='badge'>2</span> <a href="/blog/tags/CSS/"> CSS </a> </li>  <li> <span class='badge'>1</span> <a href="/blog/tags/Chef/"> Chef </a> </li>  <li> <span class='badge'>1</span> <a href="/blog/tags/Coffee-script/"> Coffee-script </a> </li>  <li> <span class='badge'>1</span> <a href="/blog/tags/Cordova/"> Cordova </a> </li>  <li> <span class='badge'>5</span> <a href="/blog/tags/ElasticSearch/"> ElasticSearch </a> </li>  <li> <span class='badge'>5</span> <a href="/blog/tags/FAQ/"> FAQ </a> </li>  <li> <span class='badge'>2</span> <a href="/blog/tags/GitHub/"> GitHub </a> </li>  <li> <span class='badge'>2</span> <a href="/blog/tags/HTML5/"> HTML5 </a> </li>  <li> <span class='badge'>2</span> <a href="/blog/tags/ItProjects/"> ItProjects </a> </li>  <li> <span class='badge'>30</span> <a href="/blog/tags/Javascript/"> Javascript </a> </li>  <li> <span class='badge'>1</span> <a href="/blog/tags/Mongoose/"> Mongoose </a> </li>  <li> <span class='badge'>11</span> <a href="/blog/tags/Node-js/"> Node.js </a> </li>  <li> <span class='badge'></span> <a href="/blog/tags/NodeJS/"> NodeJS </a> </li>  <li> <span class='badge'>1</span> <a href="/blog/tags/Objective-C/"> Objective-C </a> </li>  <li> <span class='badge'>1</span> <a href="/blog/tags/PhoneGap/"> PhoneGap </a> </li>  <li> <span class='badge'>1</span> <a href="/blog/tags/RabbitMQ/"> RabbitMQ </a> </li>  <li> <span class='badge'>2</span> <a href="/blog/tags/SEO/"> SEO </a> </li>  <li> <span class='badge'>3</span> <a href="/blog/tags/SQL/"> SQL </a> </li>  <li> <span class='badge'>1</span> <a href="/blog/tags/YAC2014/"> YAC2014 </a> </li>  <li> <span class='badge'>1</span> <a href="/blog/tags/bash/"> bash </a> </li>  <li> <span class='badge'>1</span> <a href="/blog/tags/iOS7/"> iOS7 </a> </li>  <li> <span class='badge'>2</span> <a href="/blog/tags/jQuery/"> jQuery </a> </li>  <li> <span class='badge'>1</span> <a href="/blog/tags/Бизнес-модель/"> Бизнес модель </a> </li>  <li> <span class='badge'>4</span> <a href="/blog/tags/Для-новичков/"> Для новичков </a> </li>  <li> <span class='badge'>1</span> <a href="/blog/tags/Жизнь-компании/"> Жизнь компании </a> </li>  </ul></div></aside> </div></section> <!-- /container --><footer id='contacts' class='footer-main'> <div class='callback'> <div class='container'> <div class='row'> <div class='span12'> <h2 class='xlarge'>Есть вопросы или предложения?</h2> <p class='outlined-caption'>закажите обратный звонок и наш менеджер перезвонит вам</p> <form method='POST' action='/brief' id='callback'> <ul class='hidden error'></ul> <input type="text" name='name' placeholder="Как к вам обратиться?" class='span12' required /> <input type="text" name='phone' placeholder="По какому номеру звонить?" class='span6' /> <input type="email" name='email' placeholder="E-mail (опционально)" class='span6 pull-right' /> <textarea name='question' placeholder="Ваш вопрос (опционально)" class='span12'></textarea> <button type="submit" class='blue-plank'>Заказать звонок</button> </form> </div> </div> </div> </div> <div class='container'> <div class='row'> <div class='span6'> <h4 class='footer-caption'>Разделы сайта</h4> <ul class="nav inline">  <li><a href="/blog">Блог</a></li>  <li><a href="/team">Команда</a></li>  <li><a href="#about">О нас</a></li>  <li><a href="#portfolio">Портфолио</a></li>  <li><a href="#tech">Технологии</a></li>  <li><a href="#contacts">Контакты</a></li>  <li><a href='https://github.com/AVVSDevelopment/avvs.co'>Проект на GitHub</a></li> </ul> <p class='copyright'>Makeomatic, (c) 2012-2016<br/>Разработка сайтов и мобильных приложений</p> </div> <div class='span6 blue-line'> <h4 class='footer-caption'>Контакты</h4> <p> тел: +7 (495) 79-222-44 </p> <p> e-mail: <a href="mailto:getstarted@makeomatic.ru">getstarted@makeomatic.ru</a> </p> <address> Россия, Москва, Ленинский пр-т, дом 30а<br/>индекс: 111555 </address> <div class="social"> <a class="fcb fa-stack fa-lg" href="https://www.facebook.com/makeomatic"> <i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-facebook fa-stack-1x fa-inverse"></i> </a> <a class="fa-stack fa-lg" href="http://vk.com/makeomatic"> <i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-vk fa-stack-1x fa-inverse"></i> </a> <a class="twt fa-stack fa-lg" href="https://twitter.com/MakeOmatic"> <i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-twitter fa-stack-1x fa-inverse"></i> </a> <a class="gp fa-stack fa-lg" href="https://google.com/+MakeomaticRu"> <i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-google-plus fa-stack-1x fa-inverse"></i> </a> </div> </div> </div> </div></footer><div class="modal hide fade brief" id='brief'> <div class="modal-body"> <div class='text-center'> <h2 class='brief-header outlined-caption'>Расскажите нам о вашем проекте</h2> <p class='small'> Коротко опишите ваши идеи или просто прикрепите файл с готовым ТЗ.<br/> Мы свяжемся с вами в течение 1 дня и подробно расскажем о том, как мы можем вам помочь. </p> </div> <form method='POST' action='/brief' class='callback'> <input type="text" name='name' placeholder="Как к вам обратиться?" class='span10' required /> <input type="text" name='phone' placeholder="По какому номеру звонить?" class='span5' /> <input type="email" name='email' placeholder="E-mail (опционально)" class='span5 pull-right' /> <textarea name='question' placeholder="Краткое описание вашего проекта" class='span7'></textarea> <div class='dropbox pull-right' id='dropbox' ></div> <button class="blue-plank pull-right" type='submit'>Отправить</button> </form> </div></div><!-- scripts --><script src="/js/app.min.2.3.1.js" charset="UTF-8" ></script><!-- end scripts --><script type="text/javascript">var disqus_shortname = 'makeomatic';(function(){ var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);}());</script><!-- Yandex.Metrika counter --><script type="text/javascript">(function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter15629977 = new Ya.Metrika({id:15629977, webvisor:true, clickmap:true, trackLinks:true, accurateTrackBounce:true, trackHash:true, ut:"noindex"}); } catch(e) { } }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f, false); } else { f(); } })(document, window, "yandex_metrika_callbacks");</script><noscript><div><img src="//mc.yandex.ru/watch/15629977?ut=noindex" style="position:absolute; left:-9999px;" alt="" /></div></noscript><!-- /Yandex.Metrika counter --><!-- google analytics --><script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-40638966-1', 'makeomatic.ru'); ga('send', 'pageview');</script></body></html>