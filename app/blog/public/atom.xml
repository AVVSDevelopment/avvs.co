<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Блог Makeomatic: разработка сайтов и мобильных приложений</title>
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://makeomatic.ru/blog/"/>
  <updated>2017-03-08T17:52:58.000Z</updated>
  <id>https://makeomatic.ru/blog/</id>
  
  <author>
    <name>Makeomatic</name>
    <email>getstarted@makeomatic.ru</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Работа с потоками в node.js</title>
    <link href="https://makeomatic.ru/blog/2016/08/22/Streams_handbook/"/>
    <id>https://makeomatic.ru/blog/2016/08/22/Streams_handbook/</id>
    <published>2016-08-22T07:00:00.000Z</published>
    <updated>2017-03-08T17:52:58.000Z</updated>
    
    <content type="html"><![CDATA[<div class="text-center"><br><img src="/blog/images/Streams_node.png" alt="Работа с потоками в node.js"><br></div>


<p>Данный документ является вольным переводом <a href="https://github.com/substack/stream-handbook" target="_blank" rel="external">stream-handbook</a> и охватывает основы создания <a href="http://nodejs.org/" target="_blank" rel="external">node.js</a> приложений с использованием <a href="http://nodejs.org/docs/latest/api/stream.html" target="_blank" rel="external">потоков</a>. По сравнению с источником - обновлены некоторые главы с учетом 2016 года, добавлено объяснение различий между разными версиями API, убраны устаревшие модули и добавлены новые, изменена структура повествования.</p>
<a id="more"></a>
<p>Таким образом, надеюсь, в результате получился актуальный современный учебник по потоковому API в node.js. Жду ваших комментариев и замечаний.</p>
<h3 id="Оглавление"><a href="#Оглавление" class="headerlink" title="Оглавление"></a>Оглавление</h3><ul>
<li><a href="#intro">Вступление</a></li>
<li><a href="#why">Почему мы должны использовать потоки</a></li>
<li><a href="#theory">Основы</a><ul>
<li><a href="#pipe">.pipe()</a></li>
<li><a href="#readable">Потоки на чтение (readable)</a><ul>
<li><a href="#readable-create">Создание потока на чтение</a></li>
<li><a href="#readable-usage">Использование потока на чтение</a></li>
</ul>
</li>
<li><a href="#writeable">Потоки на запись (writeable)</a><ul>
<li><a href="#writeable-create">Создание потока на запись</a></li>
<li><a href="#writeable-usage">Отправка данных в поток на запись</a></li>
</ul>
</li>
<li><a href="#duplex">Дуплексные потоки (duplex)</a></li>
<li><a href="#transform">Трансформирующие потоки (transform)</a></li>
<li><a href="#difference">Различия в реализации потоков</a><ul>
<li><a href="#streams1">streams1: устаревшее API</a></li>
<li><a href="#streams2">streams2: второе поколение</a></li>
<li><a href="#streams3">streams3: стабильная реализация</a></li>
</ul>
</li>
<li><a href="#additional">Дополнительно</a></li>
</ul>
</li>
<li><a href="#internal">Встроенные потоки</a></li>
<li><a href="#external">Сторонние потоки</a><ul>
<li><a href="#modules">Список модулей</a></li>
<li><a href="#examples">Примеры использования</a></li>
<li><a href="#cool">Мощные комбинации</a><ul>
<li><a href="#mesh">Создание распределенной сети</a></li>
<li><a href="#rpc">Клиент-серверный RPC</a></li>
<li><a href="#socket">Собственная реализация socket.io</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#conslusion">Заключение</a></li>
</ul>
<h1 id="Вступление"><a href="#Вступление" class="headerlink" title="Вступление "></a>Вступление <a name="intro"></a></h1><blockquote>
<p>Нам нужен способ взаимодействия между программами, наподобие того как садовый шланг можно подключать к разным сегментам и изменять направление воды. То же самое можно сделать с вводом-выводом данных</p>
</blockquote>
<p><a href="http://cm.bell-labs.com/who/dmr/mdmpipe.html" target="_blank" rel="external">Дуглас Макилрой. 11 октября 1964</a></p>
<p><img src="/blog/images/mcilroy.png" alt="doug mcilroy"></p>
<hr>
<p>Потоки пришли к нам из <a href="http://www.youtube.com/watch?v=tc4ROCJYbm0" target="_blank" rel="external">первых дней эпохи Unix</a> и зарекомендовали себя в течении многих десятилетий как надежный способ создания сложных систем из маленьких компонентов, которые <a href="https://ru.wikipedia.org/wiki/Философия_UNIX" target="_blank" rel="external">делают что-то одно, но делают это хорошо</a>. В Unix потоки реализуются в оболочке с помощью знака <code>|</code> (pipe). В node встроенный <a href="http://nodejs.org/docs/latest/api/stream.html" target="_blank" rel="external">модуль потоков</a> используется в базовых библиотеках, кроме этого его можно подключать в свой код. Подобно Unix, в node основной метод модуля потоков называется <code>.pipe()</code>. Он позволяет соединять потоки с разной скоростью передачи данных таким образом что данные не будут потеряны.</p>
<p>Потоки помогают <a href="https://ru.wikipedia.org/wiki/Разделение_ответственности" target="_blank" rel="external">разделять ответственность</a>, поскольку позволяют вынести все взаимодействие в отдельный интерфейс, который может быть <a href="http://www.faqs.org/docs/artu/ch01s06.html#id2877537" target="_blank" rel="external">использован повторно</a>. Вы сможете подключить вывод одного потока на ввод другого, и <a href="http://npmjs.org" target="_blank" rel="external">использовать библиотеки</a> которые будут работать с подобными интерфейсами на более высоком уровне.</p>
<p>Потоки - важный элемент микроархитектурного дизайна и философии UNIX, но кроме этого есть еще достаточное количество важных абстракций для рассмотрения. Всегда помните своего врага (<a href="http://c2.com/cgi/wiki?TechnicalDebt" target="_blank" rel="external">технический долг</a>) и ищите наиболее подходящие для решения задач абстракции.</p>
<p><img src="/blog/images/kernighan.png" alt="brian kernighan"></p>
<hr>
<h1 id="Почему-мы-должны-использовать-потоки"><a href="#Почему-мы-должны-использовать-потоки" class="headerlink" title="Почему мы должны использовать потоки "></a>Почему мы должны использовать потоки <a name="why"></a></h1><p>Ввод-вывод в node асинхронен, поэтому взаимодействие с диском и сетью происходит через различные способы управления асинхронным кодом (обещания, генераторы, функции обратного вызова и т.п.). Следующий код отдает файл браузеру через функцию обратного вызова (callback):</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">    fs.readFile(__dirname + <span class="string">'/data.txt'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</div><div class="line">        res.end(data);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div><div class="line">server.listen(<span class="number">8000</span>);</div></pre></td></tr></table></figure>
<p>Этот код работает, но он буферизирует весь <code>data.txt</code> в память при каждом запросе. Если <code>data.txt</code> достаточно большой, ваша программа начнет потреблять слишком много оперативной памяти, особенно при большом количестве подключений пользователей с медленными каналами связи.</p>
<p>При этом пользователи останутся недовольными, ведь им придется ждать пока весь файл не будет считан в память на сервере перед отправкой.</p>
<p>К счастью, оба аргумента <code>(req, res)</code> являются потоками, а это значит что мы можем переписать код с использованием <code>fs.createReadStream()</code> вместо <code>fs.readFile()</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> stream = fs.createReadStream(__dirname + <span class="string">'/data.txt'</span>);</div><div class="line">    stream.pipe(res);</div><div class="line">&#125;);</div><div class="line">server.listen(<span class="number">8000</span>);</div></pre></td></tr></table></figure>
<p>Теперь <code>.pipe()</code> самостоятельно слушает события <code>&#39;data&#39;</code> и<code>&#39;end&#39;</code> потока созданного через <code>fs.createReadStream()</code>. Этот код не только чище, но теперь и <code>data.txt</code> доставляется по частям по мере чтения его с диска.</p>
<p>Использование <code>.pipe()</code> имеет ряд других преимуществ, например автоматическая обработка скорости ввода-вывода - node.js не будет буферизировать лишние части файла в память пока предыдущие части не отправлены клиенту с медленным соединением.</p>
<p>А если мы хотим еще больше ускорить отправку файла? Добавим сжатие:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">var</span> oppressor = <span class="built_in">require</span>(<span class="string">'oppressor'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> stream = fs.createReadStream(__dirname + <span class="string">'/data.txt'</span>);</div><div class="line">    stream.pipe(oppressor(req)).pipe(res);</div><div class="line">&#125;);</div><div class="line">server.listen(<span class="number">8000</span>);</div></pre></td></tr></table></figure>
<p>Теперь наш файл cжимается для браузеров, которые поддерживают gzip или deflate! Мы просто отдаем модулю <a href="https://github.com/substack/oppressor" target="_blank" rel="external">opressor</a> всю логику обработки content-encoding и забываем про нее.</p>
<p>После того как вы ознакомитесь с API потоков, вы сможете писать потоковые модули и соединять их как кусочки лего, вместо того чтобы изобретать свои велосипеды и пытаться запомнить все способы взаимодействия между компонентами системы.</p>
<p>Потоки делают программирование в node.js простым, элегантным и компонуемым.</p>
<h1 id="Основы"><a href="#Основы" class="headerlink" title="Основы "></a>Основы <a name="theory"></a></h1><p>Существует 4 вида потоков:</p>
<ul>
<li>на чтение (<strong>readable</strong>)</li>
<li>на запись (<strong>writeable</strong>)</li>
<li>трансформирующие (<strong>transform</strong>)</li>
<li>дуплексные (<strong>duplex</strong>)</li>
</ul>
<p>Начиная с версии node.js v0.12 в стабильном состоянии заморожена версия APIv3 (<strong>streams3</strong>) - именно его описывает официальная документация. Все виды потоков, и различия в реализации API между ними будут рассмотрены ниже.</p>
<h2 id="pipe"><a href="#pipe" class="headerlink" title="pipe() "></a>pipe() <a name="pipe"></a></h2><p>Любой поток может использовать<code>.pipe()</code> для соединения входов с выходами.</p>
<p><code>.pipe()</code> это просто функция, которая берет поток на чтение <code>src</code> и соединяет его вывод с вводом потока на запись <code>dst</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">src.pipe(dst)</div></pre></td></tr></table></figure>
<p><code>.pipe(dst)</code> возвращает <code>dst</code>, так что вы можете связывать сразу несколько потоков:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.pipe(b).pipe(c).pipe(d)</div></pre></td></tr></table></figure>
<p>или то же самое:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a.pipe(b);</div><div class="line">b.pipe(c);</div><div class="line">c.pipe(d);</div></pre></td></tr></table></figure>
<p>Аналогично в Unix вы можете связать утилиты вместе:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a | b | c | d</div></pre></td></tr></table></figure>
<h2 id="Потоки-на-чтение-readable"><a href="#Потоки-на-чтение-readable" class="headerlink" title="Потоки на чтение (readable) "></a>Потоки на чтение (readable) <a name="readable"></a></h2><p>Поток на чтение производит данные, которые с помощью <code>.pipe()</code> могут быть переданы в поток на запись, трансформирующий или дуплексный поток:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">readableStream.pipe(dst)</div></pre></td></tr></table></figure>
<h3 id="Создание-потока-на-чтение"><a href="#Создание-потока-на-чтение" class="headerlink" title="Создание потока на чтение "></a>Создание потока на чтение <a name="readable-create"></a></h3><p>Давайте создадим считываемый поток!</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Readable = <span class="built_in">require</span>(<span class="string">'stream'</span>).Readable;</div><div class="line"></div><div class="line"><span class="keyword">var</span> rs = <span class="keyword">new</span> Readable;</div><div class="line">rs.push(<span class="string">'beep '</span>);</div><div class="line">rs.push(<span class="string">'boop\n'</span>);</div><div class="line">rs.push(<span class="literal">null</span>);</div><div class="line"></div><div class="line">rs.pipe(process.stdout);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ node read0.js</div><div class="line">beep boop</div></pre></td></tr></table></figure>
<p>Тут <code>rs.push(null)</code> сообщает потребителю, что <code>rs</code> закончил вывод данных.</p>
<p>Заметьте, мы отправили содержимое в поток на чтение <code>rs</code> ДО привязывания его к <code>process.stdout</code>, но сообщение все равно появилось в консоли. Когда вы посылаете с помощью <code>.push()</code> данные в поток на чтение, они буферизируются до тех пор пока потребитель не будет готов их прочитать.</p>
<p>Тем не менее, в большинстве случаев будет лучше если мы не будем их буферизировать совсем, вместо этого будем генерировать их только когда данные запрашиваются потребителем.</p>
<p>Мы можем посылать данные кусками, определив функцию <code>._read</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Readable = <span class="built_in">require</span>(<span class="string">'stream'</span>).Readable;</div><div class="line"><span class="keyword">var</span> rs = Readable();</div><div class="line"></div><div class="line"><span class="keyword">var</span> c = <span class="number">97</span>;</div><div class="line">rs._read = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    rs.push(<span class="built_in">String</span>.fromCharCode(c++));</div><div class="line">    <span class="keyword">if</span> (c &gt; <span class="string">'z'</span>.charCodeAt(<span class="number">0</span>)) rs.push(<span class="literal">null</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">rs.pipe(process.stdout);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ node read1.js</div><div class="line">abcdefghijklmnopqrstuvwxyz</div></pre></td></tr></table></figure>
<p>Теперь мы помещаем буквы  от <code>&#39;a&#39;</code> до <code>&#39;z&#39;</code> включительно, но только тогда когда потребитель будет готов их прочитать.</p>
<p>Метод <code>_read</code> также получает в первом аргументе параметр <code>size</code>, который указывает сколько байт потребитель хочет прочитать - он необязательный, так что ваша реализация потока может его игнорировать.</p>
<p>Обратите внимание, вы также можете использовать <code>util.inherits()</code> для наследования от базового потока, но такой подход может быть непонятен тому кто будет читать ваш код.</p>
<p>Чтобы продемонстрировать, что наш метод <code>_read</code> вызовется только когда потребитель запросит данные, добавим задержку в наш поток:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Readable = <span class="built_in">require</span>(<span class="string">'stream'</span>).Readable;</div><div class="line"><span class="keyword">var</span> rs = Readable();</div><div class="line"></div><div class="line"><span class="keyword">var</span> c = <span class="number">97</span> - <span class="number">1</span>;</div><div class="line"></div><div class="line">rs._read = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (c &gt;= <span class="string">'z'</span>.charCodeAt(<span class="number">0</span>)) <span class="keyword">return</span> rs.push(<span class="literal">null</span>);</div><div class="line"></div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        rs.push(<span class="built_in">String</span>.fromCharCode(++c));</div><div class="line">    &#125;, <span class="number">100</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">rs.pipe(process.stdout);</div><div class="line"></div><div class="line">process.on(<span class="string">'exit'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.error(<span class="string">'\n_read() called '</span> + (c - <span class="number">97</span>) + <span class="string">' times'</span>);</div><div class="line">&#125;);</div><div class="line">process.stdout.on(<span class="string">'error'</span>, process.exit);</div></pre></td></tr></table></figure>
<p>Запустив программу, мы увидим, что если мы запросим 5 байт - <code>_read ()</code> вызовется 5 раз:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ node read2.js | head -c5</div><div class="line">abcde</div><div class="line">_read() called 5 times</div></pre></td></tr></table></figure>
<p>Задержка через setTimeout необходима, так как операционной системе требуется определенное время чтобы послать сигнал о закрытии конвейера.</p>
<p>Обработчик <code>process.stdout.on(&#39;error&#39;, fn)</code> также необходим, поскольку операционная система пошлет SIGPIPE нашему процессу когда утилите <code>head</code> больше не будет нужен результат нашей программы (в этом случае будет вызвано событие EPIPE в потоке <code>process.stdout</code>).</p>
<p>Эти усложнения необходимы при взаимодействии с конвейером в операционной системе, но в случае реализации потоков чисто в коде они будут обработаны автоматически.</p>
<p>Если вы хотите создать читаемый поток, который выдает произвольные форматы данных вместо строк и буферов - убедитесь что вы его инициализировали с соответствующей опцией: <code>Readable ({ objectMode: true })</code>.</p>
<h3 id="Использование-потока-на-чтение"><a href="#Использование-потока-на-чтение" class="headerlink" title="Использование потока на чтение "></a>Использование потока на чтение <a name="readable-usage"></a></h3><p>В большинстве случаев мы будем подключать такой поток к другому потоку, созданному нами или модулями наподобие <a href="https://npmjs.org/package/through" target="_blank" rel="external">through</a>, <a href="https://npmjs.org/package/concat-stream" target="_blank" rel="external">concat-stream</a>. Но иногда может потребоваться использовать его напрямую.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">process.stdin.on(<span class="string">'readable'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> buf = process.stdin.read();</div><div class="line">    <span class="built_in">console</span>.dir(buf);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ (echo abc; sleep 1; echo def; sleep 1; echo ghi) | node consume0.js</div><div class="line">&lt;Buffer 61 62 63 0a&gt;</div><div class="line">&lt;Buffer 64 65 66 0a&gt;</div><div class="line">&lt;Buffer 67 68 69 0a&gt;</div><div class="line">null</div></pre></td></tr></table></figure>
<p>Когда данные становятся доступными, возникает событие <code>&#39;readable&#39;</code>, и вы можете вызвать <code>.read()</code> чтобы получить следующую порцию данных из буффера.</p>
<p>Когда поток завершится, <code>.read()</code> вернет <code>null</code>, потому что не останется доступных для чтения байтов.</p>
<p>Вы можете запросить определенное количество байтов: <code>.read(n)</code>. Указание необходимого размера носит рекомендательный характер, и не сработает для потоков возвращающих объекты. Однако, все базовые потоки обязаны поддерживать данную опцию.</p>
<p>Пример чтения в буффер порциями по 3 байта:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">process.stdin.on(<span class="string">'readable'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> buf = process.stdin.read(<span class="number">3</span>);</div><div class="line">    <span class="built_in">console</span>.dir(buf.toString());</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Но, при запуске этого примера мы получим не все данные:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ (echo abc; sleep 1; echo def; sleep 1; echo ghi) | node consume1.js</div><div class="line">&apos;abc&apos;</div><div class="line">&apos;\nde&apos;</div><div class="line">&apos;f\ng&apos;</div></pre></td></tr></table></figure>
<p>Это произошло потому что последняя порция данных осталась во внутреннем буфере, и нам надо “подопнуть” их. Сделаем мы это сообщив с помощью <code>.read(0)</code> что нам надо больше чем только что полученные 3 байта данных:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">process.stdin.on(<span class="string">'readable'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> buf = process.stdin.read(<span class="number">3</span>);</div><div class="line">    <span class="built_in">console</span>.dir(buf.toString());</div><div class="line">    process.stdin.read(<span class="number">0</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Теперь наш код работает как и ожидалось:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ (echo abc; sleep <span class="number">1</span>; echo def; sleep <span class="number">1</span>; echo ghi) | node consume2.js</div><div class="line"><span class="string">'abc'</span></div><div class="line"><span class="string">'\nde'</span></div><div class="line"><span class="string">'f\ng'</span></div><div class="line"><span class="string">'hi\n'</span></div></pre></td></tr></table></figure>
<p>В случае, если вы получили больше данных чем вам требуется - можно использовать <code>.unshift()</code> чтобы вернуть их назад. Использование <code>.unshift()</code> помогает нам предотвратить получение ненужных частей.</p>
<p>К примеру, создадим парсер который разделяет абзац на строки с делителем - переносом строки:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> offset = <span class="number">0</span>;</div><div class="line"></div><div class="line">process.stdin.on(<span class="string">'readable'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> buf = process.stdin.read();</div><div class="line">    <span class="keyword">if</span> (!buf) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">for</span> (; offset &lt; buf.length; offset++) &#123;</div><div class="line">        <span class="keyword">if</span> (buf[offset] === <span class="number">0x0a</span>) &#123;</div><div class="line">            <span class="built_in">console</span>.dir(buf.slice(<span class="number">0</span>, offset).toString());</div><div class="line">            buf = buf.slice(offset + <span class="number">1</span>);</div><div class="line">            offset = <span class="number">0</span>;</div><div class="line">            process.stdin.unshift(buf);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    process.stdin.unshift(buf);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ tail -n +50000 /usr/share/dict/american-english | head -n10 | node lines.js</div><div class="line">&apos;hearties&apos;</div><div class="line">&apos;heartiest&apos;</div><div class="line">&apos;heartily&apos;</div><div class="line">&apos;heartiness&apos;</div><div class="line">&apos;heartiness\&apos;s&apos;</div><div class="line">&apos;heartland&apos;</div><div class="line">&apos;heartland\&apos;s&apos;</div><div class="line">&apos;heartlands&apos;</div><div class="line">&apos;heartless&apos;</div><div class="line">&apos;heartlessly&apos;</div></pre></td></tr></table></figure>
<p>Код выше приведен только для примера, если вам действительно нужно будет разбить строку - лучше будет воспользоваться специализированным модулем <a href="https://npmjs.org/package/split" target="_blank" rel="external">split</a> и не изобретать велосипед.</p>
<h2 id="Потоки-на-запись-writeable"><a href="#Потоки-на-запись-writeable" class="headerlink" title="Потоки на запись (writeable) "></a>Потоки на запись (writeable) <a name="writeable"></a></h2><p>В поток на запись можно послать данные используя <code>.pipe()</code>, но прочитать их уже не получится:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">src.pipe(writableStream)</div></pre></td></tr></table></figure>
<h3 id="Создание-потока-на-запись"><a href="#Создание-потока-на-запись" class="headerlink" title="Создание потока на запись "></a>Создание потока на запись <a name="writeable-create"></a></h3><p>Просто определяем методом <code>._write(chunk, enc, next)</code>, и теперь в наш поток можно передавать данные:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Writable = <span class="built_in">require</span>(<span class="string">'stream'</span>).Writable;</div><div class="line"><span class="keyword">var</span> ws = Writable();</div><div class="line">ws._write = <span class="function"><span class="keyword">function</span> (<span class="params">chunk, enc, next</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.dir(chunk);</div><div class="line">    next();</div><div class="line">&#125;;</div><div class="line"></div><div class="line">process.stdin.pipe(ws);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ (echo beep; sleep 1; echo boop) | node write0.js</div><div class="line">&lt;Buffer 62 65 65 70 0a&gt;</div><div class="line">&lt;Buffer 62 6f 6f 70 0a&gt;</div></pre></td></tr></table></figure>
<p>Первый аргумент, <code>chunk</code>, это данные которые посылает отправитель.</p>
<p>Второй аргумент, <code>enc</code>, это строка с названием кодировки. Она используется только в случае когда опция <code>opts.decodeString</code> установлена в <code>false</code>, и вы отправляете строку.</p>
<p>Третий аргумент, <code>next(err)</code>, является функцией обратного вызова (callback), сообщающей отправителю что можно послать еще данные. Если вы вызовите ее с параметром <code>err</code>, в потоке будет создано событие <code>&#39;error&#39;</code>.</p>
<p>В случае если поток из которого вы читаете передает строки, они будут преобразовываться в <code>Buffer</code>. Чтобы отключить преобразование - создайте поток на запись с соответствующим параметром: <code>Writable({ decodeStrings: false })</code>.</p>
<p>Если поток на чтение передает объекты - явно укажите это в параметрах: <code>Writable({ objectMode: true })</code>.</p>
<h3 id="Отправка-данных-в-поток-на-запись"><a href="#Отправка-данных-в-поток-на-запись" class="headerlink" title="Отправка данных в поток на запись "></a>Отправка данных в поток на запись <a name="writeable-usage"></a></h3><p>Чтобы передать данные в поток на запись - вызовите <code>.write(data)</code>, где <code>data</code> это набор данных которые вы хотите записать.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">process.stdout.write(<span class="string">'beep boop\n'</span>);</div></pre></td></tr></table></figure>
<p>Если вы хотите сообщить что вы закончили запись - вызовите <code>.end()</code> (или <code>.end(data)</code> чтобы отправить еще немного данных перед завершением):</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">var</span> ws = fs.createWriteStream(<span class="string">'message.txt'</span>);</div><div class="line"></div><div class="line">ws.write(<span class="string">'beep '</span>);</div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    ws.end(<span class="string">'boop\n'</span>);</div><div class="line">&#125;, <span class="number">1000</span>);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ node writing1.js</div><div class="line">$ cat message.txt</div><div class="line">beep boop</div></pre></td></tr></table></figure>
<p>Не беспокойтесь о синхронизации данных и буферизации, <code>.write()</code> вернет <code>false</code> если в буфере скопилось данных больше чем указывалось в параметре <code>opts.highWaterMark</code> при создании потока. В этом случае следует подождать события <code>&#39;drain&#39;</code>, которое сигнализирует о том что данные можно снова писать.</p>
<h2 id="Дуплексные-потоки-duplex"><a href="#Дуплексные-потоки-duplex" class="headerlink" title="Дуплексные потоки (duplex) "></a>Дуплексные потоки (duplex) <a name="duplex"></a></h2><p>Дуплексные потоки наследуют методы как от потоков на чтение, так и от потоков на запись. Это позволяет им действовать в обоих направлениях - читать данные, и записывать их в обе стороны. В качестве аналогии можно привести телефон. Если вам требуется сделать что-нибудь типа такого:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.pipe(b).pipe(a)</div></pre></td></tr></table></figure>
<p>значит вам нужен дуплексный поток.</p>
<h2 id="Трансформирующие-потоки-transform"><a href="#Трансформирующие-потоки-transform" class="headerlink" title="Трансформирующие потоки (transform) "></a>Трансформирующие потоки (transform) <a name="transform"></a></h2><p>Трансформирующие потоки это частный случай дуплексных потоков (в обоих случаях они могут использоваться как для записи, так и чтения). Разница в том, что в случае трансформации отдаваемые данные так или иначе зависят от того что подается на вход.</p>
<p>Возможно, вы также встречали второе название таких потоков - “сквозные” (“through streams”). В любом случае, это просто фильтры которые преобразовывают входящие данные и отдают их.</p>
<h2 id="Различия-в-реализации-потоков"><a href="#Различия-в-реализации-потоков" class="headerlink" title="Различия в реализации потоков "></a>Различия в реализации потоков <a name="difference"></a></h2><h3 id="streams1-устаревшее-API"><a href="#streams1-устаревшее-API" class="headerlink" title="streams1: устаревшее API "></a>streams1: устаревшее API <a name="streams1"></a></h3><p>В первых версиях node.js существовал <em>классический</em> (<strong>streams1</strong>) интерфейс потоков. Интерфейс поддерживал добавление данных в поток (push-режим), однако потребитель мог только слушать события <code>data</code> и <code>end</code>, буферизация не поддерживалась и данные легко было потерять. Разработчики вручную контролировали поток вызывая <code>.pause()</code> и <code>.resume()</code>. На текущий момент его практически нигде не используют. Если вы все таки работаете с подобным потоком - вам пригодится несколько практик.</p>
<p>К примеру, чтобы избежать установки слушателей <code>&quot;data&quot;</code> и <code>&quot;end&quot;</code> подойдет модуль <a href="https://npmjs.org/package/through" target="_blank" rel="external">through</a>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> through = <span class="built_in">require</span>(<span class="string">'through'</span>);</div><div class="line">process.stdin.pipe(through(write, end));</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">write</span> (<span class="params">buf</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(buf);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">end</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'__END__'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ (echo beep; sleep 1; echo boop) | node through.js</div><div class="line">&lt;Buffer 62 65 65 70 0a&gt;</div><div class="line">&lt;Buffer 62 6f 6f 70 0a&gt;</div><div class="line">__END__</div></pre></td></tr></table></figure>
<p>а для буферизации всего содержимого потока сойдет <a href="https://npmjs.org/package/concat-stream" target="_blank" rel="external">concat-stream</a>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> concat = <span class="built_in">require</span>(<span class="string">'concat-stream'</span>);</div><div class="line">process.stdin.pipe(concat(<span class="function"><span class="keyword">function</span> (<span class="params">body</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(body));</div><div class="line">&#125;));</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ echo &apos;&#123;&quot;beep&quot;:&quot;boop&quot;&#125;&apos; | node concat.js</div><div class="line">&#123; beep: &apos;boop&apos; &#125;</div></pre></td></tr></table></figure>
<p><em>У классических потоков на чтение для остановки и продолжения есть методы <code>.pause()</code> и <code>.resume()</code>, но их использования следует избегать. Если вам необходим этот функционал - рекомендуется не создавать логику самостоятельно, а использовать модуль <a href="https://npmjs.org/package/through" target="_blank" rel="external">through</a>.</em></p>
<h3 id="streams2-второе-поколение"><a href="#streams2-второе-поколение" class="headerlink" title="streams2: второе поколение "></a>streams2: второе поколение <a name="streams2"></a></h3><p>В node.js v0.10 появилось второе поколение потоков (<strong>streams2</strong>). Эти потоки всегда запускаются в режиме паузы, и у потребителей уже есть возможность запросить данные вызвав <code>.read(numBytes)</code> (pull-режим), присутствует буферизация. Ключевая особенность данного API - поток автоматически переключается в <em>классический</em> режим в целях совместимости если назначить обработчики на <code>data</code> и <code>end</code>. При этом поток снимается с режима паузы и отключается возможность использовать pull-режим. На момент написания статьи (11.07.2016) многие неактуальные модули работают в данном режиме, однако активно развивающиеся модули перешли на третье поколение.</p>
<h3 id="streams3-стабильная-реализация"><a href="#streams3-стабильная-реализация" class="headerlink" title="streams3: стабильная реализация "></a>streams3: стабильная реализация <a name="streams3"></a></h3><p>Начиная с node.js v0.11, концепция потоков переработана и <em>признана стабильной</em> -  в официальной документации описывается именно поведение <strong>streams3</strong>. По умолчанию потоки все еще запускаются в режиме паузы а назначение обработчиков снимает их с паузы. Однако, если использовать <code>.pause()</code> и вызвать метод <code>.read()</code> - соответствующие данные будут возвращены. Таким образом, потоки поддерживают как pull режим, так и push. При этом, можно смело использовать модули с streams2 так как они совместимы.</p>
<h2 id="Дополнительно"><a href="#Дополнительно" class="headerlink" title="Дополнительно "></a>Дополнительно <a name="additional"></a></h2><p>Вы прочитали про базовые понятия касающиеся потоков, если вы хотите узнать больше - обратитесь к актуальной <a href="http://nodejs.org/docs/latest/api/stream.html#stream_stream" target="_blank" rel="external">документация по потокам</a>. В случае если вам понадобится сделать API <strong>streams2</strong> потоков совместимым с “классическим” API <strong>streams1</strong> (например, при использовании устаревших версий node.js)- используйте модуль <a href="https://npmjs.org/package/readable-stream" target="_blank" rel="external">readable-stream</a>. Просто подключите его в свой проект: <code>require(&#39;readable-stream&#39;)</code> вместо <code>require(&#39;stream&#39;)</code>.</p>
<h1 id="Встроенные-потоки"><a href="#Встроенные-потоки" class="headerlink" title="Встроенные потоки "></a>Встроенные потоки <a name="internal"></a></h1><p>Эти потоки поставляются с node.js и могут быть использованы без подключения дополнительных библиотек.</p>
<h2 id="process"><a href="#process" class="headerlink" title="process"></a>process</h2><h3 id="process-stdin"><a href="#process-stdin" class="headerlink" title="process.stdin"></a><a href="http://nodejs.org/docs/latest/api/process.html#process_process_stdin" target="_blank" rel="external">process.stdin</a></h3><p>Поток на чтение содержит стандартный системный поток ввода для вашей программы.</p>
<p>По умолчанию он находится в режиме паузы, но после первого вызова <code>.resume()</code> он начнет исполняться в<br><a href="http://nodejs.org/docs/latest/api/process.html#process_process_nexttick_callback" target="_blank" rel="external">следующем системном тике</a>.</p>
<p>Если process.stdin указывает на терминал (проверяется вызовом<br><a href="http://nodejs.org/docs/latest/api/tty.html#tty_tty_isatty_fd" target="_blank" rel="external"><code>tty.isatty()</code></a>), тогда входящие данные будут буферизироваться построчно. Вы можете выключить построчную буферизацию вызвав <code>process.stdin.setRawMode(true)</code>. Однако, имейте ввиду что в этом случае обработчики системных нажатий (таких как<code>^C</code> и <code>^D</code>) будут удалены.</p>
<h3 id="process-stdout"><a href="#process-stdout" class="headerlink" title="process.stdout"></a><a href="http://nodejs.org/api/process.html#process_process_stdout" target="_blank" rel="external">process.stdout</a></h3><p>Поток на запись, содержащий стандартный системный вывод для вашей программы. Посылайте туда данные, если вам нужно передать их в stdout.</p>
<h3 id="process-stderr"><a href="#process-stderr" class="headerlink" title="process.stderr"></a><a href="http://nodejs.org/api/process.html#process_process_stderr" target="_blank" rel="external">process.stderr</a></h3><p>Поток на запись, содержащий стандартный системный вывод ошибок для вашей программы. Посылайте туда данные, если вам нужно передать их в stderr.</p>
<h2 id="child-process-spawn"><a href="#child-process-spawn" class="headerlink" title="child_process.spawn()"></a><a href="https://nodejs.org/api/child_process.html" target="_blank" rel="external">child_process.spawn()</a></h2><p>Данная функция запускает процесс, и возвращает объект содержащий stderr/stdin/stdout потоки данного процесса.</p>
<h3 id="fs-createReadStream"><a href="#fs-createReadStream" class="headerlink" title="fs.createReadStream()"></a><a href="https://nodejs.org/api/fs.html#fs_fs_createreadstream_path_options" target="_blank" rel="external">fs.createReadStream()</a></h3><p>Поток на чтение, содержащий указанный файл. Используйте, если вам надо прочесть большой файл без больших затрат ресурсов.</p>
<h3 id="fs-createWriteStream"><a href="#fs-createWriteStream" class="headerlink" title="fs.createWriteStream()"></a><a href="https://nodejs.org/api/fs.html#fs_fs_createwritestream_path_options" target="_blank" rel="external">fs.createWriteStream()</a></h3><p>Поток на запись, позволяющий сохранить переданные данные в файл.</p>
<h2 id="net"><a href="#net" class="headerlink" title="net"></a>net</h2><h3 id="net-connect"><a href="#net-connect" class="headerlink" title="net.connect()"></a><a href="http://nodejs.org/docs/latest/api/net.html#net_net_connect_options_connectionlistener" target="_blank" rel="external">net.connect()</a></h3><p>Данная функция вернет дуплексный поток, который позволяет подключиться к удаленному хосту по протоколу tcp.</p>
<p>Все данные которые вы будете в него записывать будут буферизироваться до тех пор, пока не возникнет событие <code>&#39;connect&#39;</code>.</p>
<h3 id="net-createServer"><a href="#net-createServer" class="headerlink" title="net.createServer()"></a><a href="https://nodejs.org/api/net.html#net_net_createserver_options_connectionlistener" target="_blank" rel="external">net.createServer()</a></h3><p>Создает сервер для обработки входящих соединений. Параметром передается функция обратного вызова (callback), которая вызывается при создании соединения, и содержит поток на запись.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</div><div class="line"><span class="keyword">const</span> server = net.createServer(<span class="function">(<span class="params">c</span>) =&gt;</span> &#123;</div><div class="line">  <span class="comment">// 'connection' listener</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'client connected'</span>);</div><div class="line">  c.on(<span class="string">'end'</span>, () =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'client disconnected'</span>);</div><div class="line">  &#125;);</div><div class="line">  c.write(<span class="string">'hello\r\n'</span>);</div><div class="line">  c.pipe(c);</div><div class="line">&#125;);</div><div class="line">server.on(<span class="string">'error'</span>, (err) =&gt; &#123;</div><div class="line">  <span class="keyword">throw</span> err;</div><div class="line">&#125;);</div><div class="line">server.listen(<span class="number">8124</span>, () =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'server bound'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="http-request"><a href="#http-request" class="headerlink" title="http.request()"></a><a href="https://nodejs.org/api/http.html#http_http_request_options_callback" target="_blank" rel="external">http.request()</a></h3><p>Создает поток на чтение, позволяющий сделать запрос к веб-серверу и вернуть результат.</p>
<h3 id="http-createServer"><a href="#http-createServer" class="headerlink" title="http.createServer()"></a><a href="https://nodejs.org/api/http.html#http_http_createserver_requestlistener" target="_blank" rel="external">http.createServer()</a></h3><p>Создает сервер для обработки входящих веб-запросов. Параметром передается функция обратного вызова (callback), которая вызывается при создании соединения, и содержит поток на запись.</p>
<h3 id="zlib-createGzip"><a href="#zlib-createGzip" class="headerlink" title="zlib.createGzip()"></a><a href="https://nodejs.org/api/zlib.html#zlib_zlib_creategzip_options" target="_blank" rel="external">zlib.createGzip()</a></h3><p>Трансформирующий поток, который отдает на выходе запакованный gzip.</p>
<h3 id="zlib-createGunzip"><a href="#zlib-createGunzip" class="headerlink" title="zlib.createGunzip()"></a><a href="https://nodejs.org/api/zlib.html#zlib_zlib_creategunzip_options" target="_blank" rel="external">zlib.createGunzip()</a></h3><p>Трансформирующий поток, распаковывает gzip-поток.</p>
<h3 id="zlib-createDeflate"><a href="#zlib-createDeflate" class="headerlink" title="zlib.createDeflate()"></a><a href="https://nodejs.org/api/zlib.html#zlib_zlib_createdeflate_options" target="_blank" rel="external">zlib.createDeflate()</a></h3><h3 id="zlib-createInflate"><a href="#zlib-createInflate" class="headerlink" title="zlib.createInflate()"></a><a href="https://nodejs.org/api/zlib.html#zlib_zlib_createinflate_options" target="_blank" rel="external">zlib.createInflate()</a></h3><h1 id="Сторонние-потоки"><a href="#Сторонние-потоки" class="headerlink" title="Сторонние потоки "></a>Сторонние потоки <a name="external"></a></h1><h2 id="Список-модулей"><a href="#Список-модулей" class="headerlink" title="Список модулей "></a>Список модулей <a name="modules"></a></h2><p>Ниже приведен список npm-модулей, работающих с потоками. Список является далеко не полным, постоянно появляются новые модули и их нет возможности отслеживать. Цель данной таблицы - дать представление о “кирпичиках”, из которых вы можете собрать свое приложение. Не стесняйтесь проходить по ссылкам и изучать документацию, там есть более подробное описание и примеры использования.</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/dominictarr/through" target="_blank" rel="external">through</a></td>
<td>Простой способ создания дуплексного потока или конвертации “классического” в современный</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/dominictarr/from" target="_blank" rel="external">from</a></td>
<td>Аналог through, только для создания потока для чтения</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/dominictarr/pause-stream" target="_blank" rel="external">pause-stream</a></td>
<td>Позволяет буферизировать поток и получать результат буфера в произвольный момент</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/maxogden/node-concat-stream" target="_blank" rel="external">concat-stream</a></td>
<td>Буферизирует поток в один общий буфер. <code>concat(cb)</code> принимает параметром только один аргумент - функцию <code>cb(body)</code>, которая вернет <code>body</code> когда поток завершится</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/dominictarr/duplex" target="_blank" rel="external">duplex</a>, <a href="https://github.com/Raynos/duplexer" target="_blank" rel="external">duplexer</a></td>
<td>Создание дуплексного потока</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/substack/emit-stream" target="_blank" rel="external">emit-stream</a></td>
<td>Конвертирует события (event-emitter) в поток, и обратно</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/dominictarr/invert-stream" target="_blank" rel="external">invert-stream</a></td>
<td>Создает из двух потоков один, “соединяя” вход первого потока с выходом второго и наоборот</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/dominictarr/map-stream" target="_blank" rel="external">map-stream</a></td>
<td>Создает трансформирующий поток для заданной асинхронной функции</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/dominictarr/remote-events" target="_blank" rel="external">remote-events</a></td>
<td>Позволяет объединять несколько эмиттеров событий в единый поток</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/Raynos/buffer-stream" target="_blank" rel="external">buffer-stream</a></td>
<td>Дуплексный поток, буферизирующий проходящие через него данные</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/caolan/highland" target="_blank" rel="external">highland</a></td>
<td>Управление асинхронным кодом с использованием потоков</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/Raynos/auth-stream" target="_blank" rel="external">auth-stream</a></td>
<td>Добавление слоя авторизации для доступа к потокам</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/dominictarr/mux-demux" target="_blank" rel="external">mux-demux</a></td>
<td>Создание мультифункциональных потоков на основе любых текстовых.</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/Raynos/stream-router" target="_blank" rel="external">stream-router</a></td>
<td>Роутер для потоков, созданных с помощью <code>mux-demux</code></td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/Raynos/multi-channel-mdm" target="_blank" rel="external">multi-channel-mdm</a></td>
<td>Создание постоянных потоков (каналов) из потоков <code>mux-demux</code></td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/dominictarr/crdt" target="_blank" rel="external">crdt</a>, <a href="https://github.com/Raynos/delta-stream" target="_blank" rel="external">delta-stream</a>, <a href="https://github.com/dominictarr/scuttlebutt" target="_blank" rel="external">scuttlebutt</a></td>
<td>Данная коллекция потоков предполагает, что операции над данными всегда возвращают один и тот же результат вне зависимости от порядка этих операций</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/mikeal/request" target="_blank" rel="external">request</a></td>
<td>Создание http-запросов</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/juliangruber/reconnect-core" target="_blank" rel="external">reconnect-core</a></td>
<td>Базовый настраиваемый интерфейс для переподключения потоков при возникновении проблем в сети</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/dominictarr/kv" target="_blank" rel="external">kv</a></td>
<td>Абстрактный поток, предоставляющий враппер для доступа к различным key-value хранилищам</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/substack/node-trumpet" target="_blank" rel="external">trumpet</a></td>
<td>Трансформация html-текста с использованием css-селекторов</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/dominictarr/JSONStream" target="_blank" rel="external">JSONStream</a></td>
<td>Преобразование <code>JSON.parse</code> и <code>JSON.stringify</code>. Примеры использования - обработка большого объема JSON-данных при недостаточном количестве оперативной памяти, обработка json “на лету” при получении его через медленные каналы, и т.п.</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/substack/shoe" target="_blank" rel="external">shoe</a></td>
<td>Трансляция вебсокет событий.</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/substack/dnode" target="_blank" rel="external">dnode</a></td>
<td>Данный модуль дает вам возможность вызывать удаленные функции (RPC) через любой поток</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/isaacs/node-tap" target="_blank" rel="external">tap</a></td>
<td>Фреймворк для тестирования node.js на основе потоков.</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><a href="https://github.com/dominictarr/stream-spec" target="_blank" rel="external">stream-spec</a></td>
<td>Способ описания спецификации потоков, для автоматизации их тестирования.</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="Примеры-использования"><a href="#Примеры-использования" class="headerlink" title="Примеры использования "></a>Примеры использования <a name="examples"></a></h2><p><code>pause-stream</code> позволяет буферизировать поток и получать результат буфера в произвольный момент:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ps = <span class="built_in">require</span>(<span class="string">'pause-stream'</span>)();</div><div class="line"></div><div class="line">badlyBehavedStream.pipe(ps.pause())</div><div class="line"></div><div class="line">aLittleLater(<span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</div><div class="line">  ps.pipe(createAnotherStream(data))</div><div class="line">  ps.resume()</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<hr>
<p>В данном примере <code>concat-stream</code>  вернет строку <code>&quot;beep boop&quot;</code> только после того как вызовется <code>cs.end()</code>. Результат работы программы - перевод строки в верхний регистр:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> concat = <span class="built_in">require</span>(<span class="string">'concat-stream'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> cs = concat(<span class="function"><span class="keyword">function</span> (<span class="params">body</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(body.toUpperCase());</div><div class="line">&#125;);</div><div class="line">cs.write(<span class="string">'beep '</span>);</div><div class="line">cs.write(<span class="string">'boop.'</span>);</div><div class="line">cs.end();</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ node concat.js</div><div class="line">BEEP BOOP.</div></pre></td></tr></table></figure>
<hr>
<p>Следующий пример с <code>concat-stream</code> обработает строку с параметрами, и вернет их уже в JSON:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">var</span> qs = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</div><div class="line"><span class="keyword">var</span> concat = <span class="built_in">require</span>(<span class="string">'concat-stream'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">    req.pipe(concat(<span class="function"><span class="keyword">function</span> (<span class="params">body</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> params = qs.parse(body.toString());</div><div class="line">        res.end(<span class="built_in">JSON</span>.stringify(params) + <span class="string">'\n'</span>);</div><div class="line">    &#125;));</div><div class="line">&#125;);</div><div class="line">server.listen(<span class="number">5005</span>);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ curl -X POST -d &apos;beep=boop&amp;dinosaur=trex&apos; http://localhost:5005</div><div class="line">&#123;&quot;beep&quot;:&quot;boop&quot;,&quot;dinosaur&quot;:&quot;trex&quot;&#125;</div></pre></td></tr></table></figure>
<hr>
<p>В данном примере используются <code>JSONStream</code> и <code>emit-stream</code> и <code>net</code>. Будет создан сервер который автоматически отправит все события клиенту:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> emitStream = <span class="built_in">require</span>(<span class="string">'emit-stream'</span>);</div><div class="line"><span class="keyword">var</span> JSONStream = <span class="built_in">require</span>(<span class="string">'JSONStream'</span>);</div><div class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> server = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> ev = createEmitter();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> net.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">stream</span>) </span>&#123;</div><div class="line">        emitStream(ev)</div><div class="line">            .pipe(JSONStream.stringify())</div><div class="line">            .pipe(stream)</div><div class="line">        ;</div><div class="line">    &#125;);</div><div class="line">&#125;)();</div><div class="line">server.listen(<span class="number">5555</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createEmitter</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> ev = <span class="keyword">new</span> EventEmitter;</div><div class="line">    setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        ev.emit(<span class="string">'ping'</span>, <span class="built_in">Date</span>.now());</div><div class="line">    &#125;, <span class="number">2000</span>);</div><div class="line"></div><div class="line">    <span class="keyword">var</span> x = <span class="number">0</span>;</div><div class="line">    setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        ev.emit(<span class="string">'x'</span>, x ++);</div><div class="line">    &#125;, <span class="number">500</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> ev;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Клиент, со своей стороны, может автоматически конвертировать приходящие данные обратно в события:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> emitStream = <span class="built_in">require</span>(<span class="string">'emit-stream'</span>);</div><div class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> stream = net.connect(<span class="number">5555</span>)</div><div class="line">    .pipe(JSONStream.parse([<span class="literal">true</span>]))</div><div class="line">;</div><div class="line"><span class="keyword">var</span> ev = emitStream(stream);</div><div class="line"></div><div class="line">ev.on(<span class="string">'ping'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">t</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'# ping: '</span> + t);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">ev.on(<span class="string">'x'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'x = '</span> + x);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<hr>
<p>Данная программа создаст из stdin и stdout дуплексный поток с помощью <code>invert-stream</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> spawn = <span class="built_in">require</span>(<span class="string">'child_process'</span>).spawn</div><div class="line">  <span class="keyword">var</span> invert = <span class="built_in">require</span>(<span class="string">'invert-stream'</span>)</div><div class="line"></div><div class="line">  <span class="keyword">var</span> ch = spawn(cmd, args)</div><div class="line">  <span class="keyword">var</span> inverted = invert()</div><div class="line"></div><div class="line">  ch.stdout.pipe(inverted.other).pipe(ch.sdin)</div><div class="line"></div><div class="line">  <span class="comment">//now, we have just ONE stream: inverted</span></div><div class="line"></div><div class="line">  <span class="comment">//write to che ch's stdin</span></div><div class="line">  inverted.write(data)</div><div class="line"></div><div class="line">  <span class="comment">//read from ch's stdout</span></div><div class="line">  inverted.on(<span class="string">'data'</span>, <span class="built_in">console</span>.log)</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> map = <span class="built_in">require</span>(<span class="string">'map-stream'</span>)</div><div class="line"></div><div class="line">map(<span class="function"><span class="keyword">function</span> (<span class="params">data, callback</span>) </span>&#123;</div><div class="line">  <span class="comment">//transform data</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">  callback(<span class="literal">null</span>, data)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<hr>
<p>Для создания потока, работающего с датами, тут мы используем <code>mux-demux</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MuxDemux = <span class="built_in">require</span>(<span class="string">'mux-demux'</span>)</div><div class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>)</div><div class="line"></div><div class="line">net.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">con</span>) </span>&#123;</div><div class="line">  con.pipe(MuxDemux(<span class="function"><span class="keyword">function</span> (<span class="params">stream</span>) </span>&#123;</div><div class="line">    stream.on(<span class="string">'data'</span>, <span class="built_in">console</span>.log.bind(<span class="built_in">console</span>))</div><div class="line">  &#125;)).pipe(con)</div><div class="line">&#125;).listen(<span class="number">8642</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> con = net.connect(<span class="number">8642</span>), mx</div><div class="line">  con.pipe(mx = MuxDemux()).pipe(con)</div><div class="line"></div><div class="line">  <span class="keyword">var</span> ds = mx.createWriteStream(<span class="string">'times'</span>)</div><div class="line"></div><div class="line">  setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    ds.write(<span class="keyword">new</span> <span class="built_in">Date</span>().toString())</div><div class="line">  &#125;, <span class="number">1e3</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="Мощные-комбинации"><a href="#Мощные-комбинации" class="headerlink" title="Мощные комбинации "></a>Мощные комбинации <a name="cool"></a></h2><p>Статья была бы не полной без рассказа о той магии, которую можно совершать используя комбинации различных потоков. Давайте рассмотрим некоторые из них.</p>
<h3 id="Создание-распределенной-сети"><a href="#Создание-распределенной-сети" class="headerlink" title="Создание распределенной сети "></a>Создание распределенной сети <a name="mesh"></a></h3><p>Модуль <code>scuttlebutt</code> может быть использован для синхронизации состояния между узлами mesh-сети, где узлы непосредственно не связаны между собой и нет единого мастера (аналог торрент-клиента).</p>
<p>Под капотом у <code>scuttlebutt</code> используется широко известный в узких кругах протокол <a href="https://en.wikipedia.org/wiki/Gossip_protocol" target="_blank" rel="external">gossip</a>, который гарантирует что все узлы будут возвращать <a href="https://ru.wikipedia.org/wiki/Консистентность_в_конечном_счёте" target="_blank" rel="external">последнее актуальное значение</a>.</p>
<p>Используя интерфейс <code>scuttlebutt/model</code>, мы можем создавать клиентов и связывать их между собой:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Model = <span class="built_in">require</span>(<span class="string">'scuttlebutt/model'</span>);</div><div class="line"><span class="keyword">var</span> am = <span class="keyword">new</span> Model;</div><div class="line"><span class="keyword">var</span> <span class="keyword">as</span> = am.createStream();</div><div class="line"></div><div class="line"><span class="keyword">var</span> bm = <span class="keyword">new</span> Model;</div><div class="line"><span class="keyword">var</span> bs = bm.createStream();</div><div class="line"></div><div class="line"><span class="keyword">var</span> cm = <span class="keyword">new</span> Model;</div><div class="line"><span class="keyword">var</span> cs = cm.createStream();</div><div class="line"></div><div class="line"><span class="keyword">var</span> dm = <span class="keyword">new</span> Model;</div><div class="line"><span class="keyword">var</span> ds = dm.createStream();</div><div class="line"></div><div class="line"><span class="keyword">var</span> em = <span class="keyword">new</span> Model;</div><div class="line"><span class="keyword">var</span> es = em.createStream();</div><div class="line"></div><div class="line"><span class="keyword">as</span>.pipe(bs).pipe(<span class="keyword">as</span>);</div><div class="line">bs.pipe(cs).pipe(bs);</div><div class="line">bs.pipe(ds).pipe(bs);</div><div class="line">ds.pipe(es).pipe(ds);</div><div class="line"></div><div class="line">em.on(<span class="string">'update'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">key, value, source</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(key + <span class="string">' =&gt; '</span> + value + <span class="string">' from '</span> + source);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">am.set(<span class="string">'x'</span>, <span class="number">555</span>);</div></pre></td></tr></table></figure>
<p>Мы создали сеть в форме ненаправленного графа, которая выглядит так:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a &lt;-&gt; b &lt;-&gt; c</div><div class="line">      ^</div><div class="line">      |</div><div class="line">      v</div><div class="line">      d &lt;-&gt; e</div></pre></td></tr></table></figure>
<p>Узлы <code>a</code> и <code>e</code> напрямую не соединены, но если мы выполним команду:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ node model.js</div><div class="line">x =&gt; 555 from 1347857300518</div></pre></td></tr></table></figure>
<p>то увидим что узел  <code>a</code> будет доступен узлу <code>e</code> через узлы <code>b</code>и <code>d</code>. Учитывая то, что <code>scuttlebutt</code> использует простой потоковый интерфейс, и все узлы гарантированно получат данные - мы можем соединить любой процесс, сервер или транспорт которые поддерживают обработку строк.</p>
<p>Давайте создадим более реалистичный пример. В нем мы будем соединяться через сеть, и увеличивать счетчик каждые 320 миллисекунд на всех узлах:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Model = <span class="built_in">require</span>(<span class="string">'scuttlebutt/model'</span>);</div><div class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> Model;</div><div class="line">m.set(<span class="string">'count'</span>, <span class="string">'0'</span>);</div><div class="line">m.on(<span class="string">'update'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(key + <span class="string">' = '</span> + m.get(<span class="string">'count'</span>));</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> server = net.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">stream</span>) </span>&#123;</div><div class="line">    stream.pipe(m.createStream()).pipe(stream);</div><div class="line">&#125;);</div><div class="line">server.listen(<span class="number">8888</span>);</div><div class="line"></div><div class="line">setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    m.set(<span class="string">'count'</span>, <span class="built_in">Number</span>(m.get(<span class="string">'count'</span>)) + <span class="number">1</span>);</div><div class="line">&#125;, <span class="number">320</span>);</div></pre></td></tr></table></figure>
<p>Теперь создадим клиента, который подключается к серверу, получает обновления и выводит их на экран:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Model = <span class="built_in">require</span>(<span class="string">'scuttlebutt/model'</span>);</div><div class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> Model;</div><div class="line"><span class="keyword">var</span> s = m.createStream();</div><div class="line"></div><div class="line">s.pipe(net.connect(<span class="number">8888</span>, <span class="string">'localhost'</span>)).pipe(s);</div><div class="line"></div><div class="line">m.on(<span class="string">'update'</span>, <span class="function"><span class="keyword">function</span> <span class="title">cb</span> (<span class="params">key</span>) </span>&#123;</div><div class="line">    <span class="comment">// wait until we've gotten at least one count value from the network</span></div><div class="line">    <span class="keyword">if</span> (key !== <span class="string">'count'</span>) <span class="keyword">return</span>;</div><div class="line">    m.removeListener(<span class="string">'update'</span>, cb);</div><div class="line"></div><div class="line">    setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        m.set(<span class="string">'count'</span>, <span class="built_in">Number</span>(m.get(<span class="string">'count'</span>)) + <span class="number">1</span>);</div><div class="line">    &#125;, <span class="number">100</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">m.on(<span class="string">'update'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(key + <span class="string">' = '</span> + value);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Клиент получился чуть-чуть сложнее, так как ему приходится ждать обновления от остальных участников прежде чем убедиться что он может увеличить счетчик.</p>
<p>После того как мы запустим сервер и несколько клиентов - мы увидим изменения счетчика наподобие такого:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">count = 183</div><div class="line">count = 184</div><div class="line">count = 185</div><div class="line">count = 186</div><div class="line">count = 187</div><div class="line">count = 188</div><div class="line">count = 189</div></pre></td></tr></table></figure>
<p>Время от времени на некоторых узлах мы будем замечать что значения повторяются:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">count = 147</div><div class="line">count = 148</div><div class="line">count = 149</div><div class="line">count = 149</div><div class="line">count = 150</div><div class="line">count = 151</div></pre></td></tr></table></figure>
<p>Это происходит потому, что мы не предоставили достаточно данных алгоритму для разрешения временных конфликтов, и ему сложнее поддерживать синхронизацию всех узлов. К сожалению, дальнейшее развитие примера выходит за пределы данной статьи, поэтому рекомендуем самостоятельно изучить <code>scuttlebutt</code>.</p>
<p>Обратите внимание, что в вышеприведенных примерах сервер это всего лишь еще один узел с теми же привилегиями что и остальные клиенты. Понятия “клиент” и “сервер” не затрагивают способы синхронизации данных, в данном сервер это “тот кто первым создал соединение”. Подобные протоколы называют “симметричными”, еще один пример подобного протокола можно посмотреть в реализации модуля <code>dnode</code>.</p>
<h3 id="Клиент-серверный-RPC"><a href="#Клиент-серверный-RPC" class="headerlink" title="Клиент-серверный RPC "></a>Клиент-серверный RPC <a name="rpc"></a></h3><p>Для примера, создадим простой сервер <code>dnode</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dnode = <span class="built_in">require</span>(<span class="string">'dnode'</span>);</div><div class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> server = net.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">c</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> d = dnode(&#123;</div><div class="line">        <span class="attr">transform</span> : <span class="function"><span class="keyword">function</span> (<span class="params">s, cb</span>) </span>&#123;</div><div class="line">            cb(s.replace(<span class="regexp">/[aeiou]&#123;2,&#125;/</span>, <span class="string">'oo'</span>).toUpperCase())</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    c.pipe(d).pipe(c);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">server.listen(<span class="number">5004</span>);</div></pre></td></tr></table></figure>
<p>потом напишем клиента, который вызывает метод сервера <code>.transform()</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dnode = <span class="built_in">require</span>(<span class="string">'dnode'</span>);</div><div class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> d = dnode();</div><div class="line">d.on(<span class="string">'remote'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">remote</span>) </span>&#123;</div><div class="line">    remote.transform(<span class="string">'beep'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'beep =&gt; '</span> + s);</div><div class="line">        d.end();</div><div class="line">    &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> c = net.connect(<span class="number">5004</span>);</div><div class="line">c.pipe(d).pipe(c);</div></pre></td></tr></table></figure>
<p>После запуска, клиент выведет следующий текст:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ node client.js</div><div class="line">beep =&gt; BOOP</div></pre></td></tr></table></figure>
<p>Клиент послал <code>&#39;beep&#39;</code> на сервер, запросив выполнение метода <code>.transform()</code>, сервер вернул результат.</p>
<p>Интерфейс, который предоставляет <code>dnode</code>, является дуплексным потоком. Таким образом, так как и клиент и сервер подключены друг к другу (<code>c.pipe(d).pipe(c)</code>), запросы можно выполнять в обе стороны.</p>
<p><code>dnode</code> раскрывает себя во всей красе когда вы начинаете передавать аргументы к предоставленным методам. Посмотрим на обновленную версию предыдущего сервера:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dnode = <span class="built_in">require</span>(<span class="string">'dnode'</span>);</div><div class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> server = net.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">c</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> d = dnode(&#123;</div><div class="line">        <span class="attr">transform</span> : <span class="function"><span class="keyword">function</span> (<span class="params">s, cb</span>) </span>&#123;</div><div class="line">            cb(<span class="function"><span class="keyword">function</span> (<span class="params">n, fn</span>) </span>&#123;</div><div class="line">                <span class="keyword">var</span> oo = <span class="built_in">Array</span>(n+<span class="number">1</span>).join(<span class="string">'o'</span>);</div><div class="line">                fn(s.replace(<span class="regexp">/[aeiou]&#123;2,&#125;/</span>, oo).toUpperCase());</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    c.pipe(d).pipe(c);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">server.listen(<span class="number">5004</span>);</div></pre></td></tr></table></figure>
<p>Вот обновленный клиент:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dnode = <span class="built_in">require</span>(<span class="string">'dnode'</span>);</div><div class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> d = dnode();</div><div class="line">d.on(<span class="string">'remote'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">remote</span>) </span>&#123;</div><div class="line">    remote.transform(<span class="string">'beep'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">cb</span>) </span>&#123;</div><div class="line">        cb(<span class="number">10</span>, <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'beep:10 =&gt; '</span> + s);</div><div class="line">            d.end();</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> c = net.connect(<span class="number">5004</span>);</div><div class="line">c.pipe(d).pipe(c);</div></pre></td></tr></table></figure>
<p>После запуска клиента, мы увидим:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ node client.js</div><div class="line">beep:10 =&gt; BOOOOOOOOOOP</div></pre></td></tr></table></figure>
<p>Сервер увидел аргумент, и выполнил функцию с ним!</p>
<p>Основная идея такая: вы просто кладете функцию в объект, и на другой стороне земного шара вызываете идентичную функцию с нужными вам аргументами. Вместо того чтобы выполниться локально, данные передаются на сервер и функция возвращает результат удаленного выполнения. Это просто работает.</p>
<p><code>dnode</code> работает через потоки как в node.js, так и в браузере. Удобно комбинировать потоки через <code>mux-demux</code> для создания мультиплексного потока, работающего в обе стороны.</p>
<h3 id="Собственная-реализация-socket-io"><a href="#Собственная-реализация-socket-io" class="headerlink" title="Собственная реализация socket.io "></a>Собственная реализация socket.io <a name="socket"></a></h3><p>Мы можем создать собственное API для генерации событий через websocket с использованием потоков.</p>
<p>Сперва, используем <code>shoe</code> для создания серверного обработчика вебсокетов, и <code>emit-stream</code> чтобы превратить эмиттер событий в поток, который генерирует объекты.</p>
<p>Далее, поток с объектами мы подключаем к <code>JSONStream</code>, с целью преобразовать объект в строку готовую для передачи в сеть.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter;</div><div class="line"><span class="keyword">var</span> shoe = <span class="built_in">require</span>(<span class="string">'shoe'</span>);</div><div class="line"><span class="keyword">var</span> emitStream = <span class="built_in">require</span>(<span class="string">'emit-stream'</span>);</div><div class="line"><span class="keyword">var</span> JSONStream = <span class="built_in">require</span>(<span class="string">'JSONStream'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> sock = shoe(<span class="function"><span class="keyword">function</span> (<span class="params">stream</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> ev = <span class="keyword">new</span> EventEmitter;</div><div class="line">    emitStream(ev)</div><div class="line">        .pipe(JSONStream.stringify())</div><div class="line">        .pipe(stream)</div><div class="line">    ;</div><div class="line">    ...</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Теперь мы можем прозрачно генерировать события используя метод эмиттера <code>ev</code>. К примеру, несколько событий через разные промежутки времени:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> intervals = [];</div><div class="line"></div><div class="line">intervals.push(setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    ev.emit(<span class="string">'upper'</span>, <span class="string">'abc'</span>);</div><div class="line">&#125;, <span class="number">500</span>));</div><div class="line"></div><div class="line">intervals.push(setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    ev.emit(<span class="string">'lower'</span>, <span class="string">'def'</span>);</div><div class="line">&#125;, <span class="number">300</span>));</div><div class="line"></div><div class="line">stream.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    intervals.forEach(clearInterval);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Наконец, экземпляр <code>shoe</code> привяжем к http-серверу:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">var</span> server = http.createServer(<span class="built_in">require</span>(<span class="string">'ecstatic'</span>)(__dirname));</div><div class="line">server.listen(<span class="number">8080</span>);</div><div class="line"></div><div class="line">sock.install(server, <span class="string">'/sock'</span>);</div></pre></td></tr></table></figure>
<p>Между тем, на стороне браузера поток от <code>shoe</code> содержащий json обрабатывается и получившиеся объекты передаются в <code>eventStream()</code>. Таким образом, <code>eventStream()</code> возвращает эмиттер который генерирует переданные сервером события:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> shoe = <span class="built_in">require</span>(<span class="string">'shoe'</span>);</div><div class="line"><span class="keyword">var</span> emitStream = <span class="built_in">require</span>(<span class="string">'emit-stream'</span>);</div><div class="line"><span class="keyword">var</span> JSONStream = <span class="built_in">require</span>(<span class="string">'JSONStream'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> parser = JSONStream.parse([<span class="literal">true</span>]);</div><div class="line"><span class="keyword">var</span> stream = parser.pipe(shoe(<span class="string">'/sock'</span>)).pipe(parser);</div><div class="line"><span class="keyword">var</span> ev = emitStream(stream);</div><div class="line"></div><div class="line">ev.on(<span class="string">'lower'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</div><div class="line">    div.textContent = msg.toLowerCase();</div><div class="line">    <span class="built_in">document</span>.body.appendChild(div);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">ev.on(<span class="string">'upper'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</div><div class="line">    div.textContent = msg.toUpperCase();</div><div class="line">    <span class="built_in">document</span>.body.appendChild(div);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Используем <a href="https://github.com/substack/node-browserify" target="_blank" rel="external">browserify</a> для генерации кода в браузере, чтобы мы могли делать <code>require()</code> прямо в файле:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ browserify main.js -o bundle.js</div></pre></td></tr></table></figure>
<p>Подключаем <code>&lt;script src=&quot;/bundle.js&quot;&gt;&lt;/script&gt;</code> в html-страницу, открываем ее в браузере и наслаждаемся серверными событиями которые отображаются в браузере.</p>
<h1 id="Заключение"><a href="#Заключение" class="headerlink" title="Заключение "></a>Заключение <a name="conclusion"></a></h1><p>Начав использовать потоки и планировать с их помощью процесс разработки программ, вы заметите что стали больше полагаться на маленькие переиспользуемые компоненты которым не нужно ничего кроме общего интерфейса потоков. Вместо маршрутизации сообщений через глобальную систему событий и настройки обработчиков вы сфокусируетесь на разбиении приложения на мелкие компоненты, хорошо выполняющими какую-то одну задачу.</p>
<p>В примерах вы можете легко заменить <code>JSONStream</code> на <code>stream-serializer</code> чтобы получить немного другой способ преобразования в строку. Вы можете добавить дополнительный слой чтобы обрабатывать потери связи с помощью <code>reconnect-core</code>. Если вы захотите использовать события с областью видимости - вы вставите дополнительный поток с поддержкой <a href="https://npmjs.org/package/eventemitter2" target="_blank" rel="external">eventemitter2</a>. В случае если вам потребуется изменить поведение некоторых частей потока вы сможете пропустить его через <code>mux-demux</code> и разделить на отдельные каналы каждый со своей логикой.</p>
<p>С течением времени, при изменении требований к приложению, вы легко сможете заменять устаревшие компоненты новыми, с гораздо меньшим риском получить в результате неработающую систему.</p>
]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;text-center&quot;&gt;&lt;br&gt;&lt;img src=&quot;/blog/images/Streams_node.png&quot; alt=&quot;Работа с потоками в node.js&quot;&gt;&lt;br&gt;&lt;/div&gt;


&lt;p&gt;Данный документ является вольным переводом &lt;a href=&quot;https://github.com/substack/stream-handbook&quot;&gt;stream-handbook&lt;/a&gt; и охватывает основы создания &lt;a href=&quot;http://nodejs.org/&quot;&gt;node.js&lt;/a&gt; приложений с использованием &lt;a href=&quot;http://nodejs.org/docs/latest/api/stream.html&quot;&gt;потоков&lt;/a&gt;. По сравнению с источником - обновлены некоторые главы с учетом 2016 года, добавлено объяснение различий между разными версиями API, убраны устаревшие модули и добавлены новые, изменена структура повествования.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="https://makeomatic.ru/blog/tags/Node-js/"/>
    
      <category term="Javascript" scheme="https://makeomatic.ru/blog/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Социальная сеть для путешественников — новый формат</title>
    <link href="https://makeomatic.ru/blog/2015/12/28/Social_network_for_travellers/"/>
    <id>https://makeomatic.ru/blog/2015/12/28/Social_network_for_travellers/</id>
    <published>2015-12-28T08:00:00.000Z</published>
    <updated>2016-08-22T18:16:21.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://makeomatic.ru/blog/images/f4f_main.jpg" alt="f4f"></p>
<p>До наступления 2016 года остаются считанные дни — самое время подвести итоги. Для нас в Makeomatic уходящий год был продуктивным. Не нарушая сложившейся традиции, в сентябре мы всей командой посетили конференцию <a href="http://nodeconfeu.com/" target="_blank" rel="external">NodeConf</a>, проходившую  в замке Уотерфорд в Ирландии (было здорово, но роботов в этот раз не хватало).<br><a id="more"></a></p>
<p>В течение года наши тимлиды стажировали двух интернов — один из них в результате присоединился к команде. Включив световую скорость, мы успели завершить и зарелизить несколько крупных проектов, и с удовольствием подключились к реализации новых. В этой статье хотелось бы рассказать об одном из проектов и о том, какие технические решения были приняты в процессе разработки.</p>
<p>Цифровая эпоха диктует свои правила, и, наверное, всем уже очевидно, что e-commerce  — тренд ближайших лет. На этой волне поднялись такие гиганты, как Amazon, Shopify и огромное количество более мелких игроков. Сегодня, когда нужно что-то купить, мы редко сразу бежим в магазин. Гораздо проще и быстрее забить нужную вещь в поисковик, найти подходящее по соотношению цена-качество предложение и сразу же всё заказать. Ещё один бонус онлайн-шоппинга — возможность покупать за границей товары, которые вряд ли удалось бы найти в местных магазинах. К сожалению, конечная стоимость доставки нередко сводит на нет весь смысл покупки за рубежом: особенно, когда стоимость доставки превышает цену самой покупки. Что мы обычно делаем в таких случаях? Идём в любимую социальную сеть и публикуем пост с просьбой о помощи, в надежде, что кто-нибдуь из друзей в скором времени поедет за границу и попутно сможет привезти желаемую вещь. Иногда нам везёт. Но, согласитесь, хотелось бы, чтобы в подобных ситуациях существовал более простой, всегда срабатывающий способ.</p>
<p>Именно поэтому мы ни секунды не сомневались, когда к нам обратились клиенты с идеей создания социальной платформы, которая объединит тех, кто хотел бы получать товары из-за границы, и тех, кто часто бывает за рубежом. Обсудив основной функционал сервиса, мы принялись за работу.</p>
<h3 id="Определение-задач-и-целевой-аудитории"><a href="#Определение-задач-и-целевой-аудитории" class="headerlink" title="Определение задач и целевой аудитории"></a>Определение задач и целевой аудитории</h3><p>Наше принципиальное правило разработки — чётко определить все основные фичи продукта и понять, на каких пользователей он расчитан. Это позволяет работать эффективнее: тратить меньше времени на прототипирование, и больше — на создание непосредственно интерфейсов, которыми люди будут пользоваться. Поэтому в самом начале важно сформулировать цель проекта — проблемы, которые продукт/приложение будет решать. В данном случае, перед нами была поставлена задача разработать социальную сеть для путешественников и ценителей зарубежных товаров. Необходимо было создать полноценную платформу: удобную для социального взаимодействия, современную, простую в использовании, надёжную для онлайн платежей — это то, чем мы руководствовались на протяжении всей разработки. </p>
<p>Работа была разделена на три отдельных этапа: </p>
<ul>
<li>разработка десктопной платформы;</li>
<li>приложение для мобильной системы iOS;</li>
<li>приложение под Android.</li>
</ul>
<p><img src="https://makeomatic.ru/blog/images/1.jpg" alt="1"></p>
<h3 id="Первые-шаги-—-выбираем-технологии"><a href="#Первые-шаги-—-выбираем-технологии" class="headerlink" title="Первые шаги — выбираем технологии"></a>Первые шаги — выбираем технологии</h3><p>Многие считают, что успех стартапа зависит от хорошей идеи. Но те, кто понимает, что на самом деле успех зависит от того, как эта идея реализована — <a href="https://sivers.org/multiply" target="_blank" rel="external">зрят в корень</a>. Каждое архитектурное решение напрямую влияет на конечный потенциал продукта. В Makeomatic мы используем самые разные технологии, выбирая под конкретную задачу. Конечно, у нас есть личные предпочтения, и, по результатам внутреннего опроса, любимый инструмент всей команды  — Node.js. На NodeConf выступающие говорили, что по сравнению со многими  другими языками программирования Node.js выигрывает в 2-4 раза в производительности и скорости разработки. Лучший способ проверить это — отправить ваш любимый язык программирования (будь то Java, Ruby или PHP) в отпуск и начать использовать Node.js в реальных проектах. Наш личный опыт позволяет утверждать: при больших объёмах данных и высоких нагрузках эта технология — правильный выбор, а в паре с Javascript-фреймворком (например, Angular или React) Node.js прекрасно подойдёт и для изоморфных одностраничных приложений (SPA).</p>
<p>Но что значит высокие нагрузки, и как понять, будут ли в вашем приложении большие объёмы данных? Мы придерживаемся мнения, что не существует универсальной технологии. Вам вряд ли понадобится экскаватор, чтобы вырыть клумбу, точно также вы маловероятно выберете Node.js для создания простого статического блога (конечно, вам никто не запретит, в качестве опытного эксперимента, но с практической точки зрения это перебор). </p>
<p>Однако, если ваш проект — поисковый движок по миллионам социальных профилей (вроде того, что мы разрабатывали и вкратце описали <a href="https://en.makeomatic.ru/blog/2015/11/27/people_search_engine" target="_blank" rel="external">в этом посте</a>), или если вашим приложением будут одновременно пользоваться тысячи пользователей, смело выбирайте Node.js. Именно поэтому первый этап нашего процесса разработки — определение (и документация) всего функционала. Это даёт нам чёткое представление о том, каким в итоге будет продукт, и какие технические требования необходимо заранее учесть и архитектурно реализовать, чтобы в случае дальнейшего масшабирования не возникало никаких проблем.</p>
<p>Поскольку в данном случае мы принялись за разработку социальной сети, изначально закладывалась вероятность большого траффика. Также было понятно, что приложение должно работать в режиме реального времени: когда путешественник добавляет информацию о новой поездке или покупатель размещает заказ товара, требовалось, чтобы эти обновления были мгновенно доступны для всех пользователей. И, конечно, ни одна социальная сеть не обходится без личных сообщений. Node.js идеально подходит для решения этих задач, так что долго выбирать технологию нам не пришлось. А чтобы иметь возможность работать с последней версией Javascript (ES6), мы добавили транспилятор Babel.js.</p>
<p>Поскольку наши разработчики хотят идти в ногу со временем и использовать актуальные технологии, мы решили реализовать микросервисную архитектуру —  множество функциональных блоков, которые легко заменять и переиспользовать. Проще говоря, наша система разделена на небольшие компоненты (модули): каждый модуль сам по себе микро-приложение. Благодаря этому, мы получили более гибкую архитектуру. Если в какой-то момент наша социальная сеть перерастёт в более сложную платформу или преобразуется в совершенно другой сервис, нам не придётся выкидывать весь написанный код и начинать с нуля. </p>
<p>Как и следовало ожидать, в качестве поискового движка в этом проекте мы выбрали ElasticSearch, технологию с открытым исходным кодом и богатым API, которая отлично проявила себя в наших прошлых проектах. На этот раз мы реализовали с помощью ElasticSearch быстрый и удобный поиск по разным условиям (страна, дата, категории товаров, и т.д.). Не будем скрывать: в списке “любимых инструментов Makeomatic” ElasticSearch на почётном втором месте (после Node.js). В рамках этого проекта можно рассказать много интересного о том, какие проблемы он помог нам решить, и об этом мы напишем отдельную статью.</p>
<h3 id="Фронтенд-поговорим-об-интерфейсах"><a href="#Фронтенд-поговорим-об-интерфейсах" class="headerlink" title="Фронтенд: поговорим об интерфейсах"></a>Фронтенд: поговорим об интерфейсах</h3><h4 id="Интуитивный-UX"><a href="#Интуитивный-UX" class="headerlink" title="Интуитивный UX"></a>Интуитивный UX</h4><p>Ни одна социальная сеть не обходится без профилей. Информация о пользователе, аватар, время последнего посещения,  личные сообщения — всё это обычно есть в любом профиле. Однако, в нашем случае, профили включали гораздо больше информации: запланированные поездки, заказы, отзывы и целый ряд связанных с ними метаданных. И первая трудность, с которой мы столкнулись, заключалась в том, чтобы правильно сгруппировать основные компоненты интерфейса, не усложняя при этом навигацию. Мы попробовали скрыть менее важные блоки в подменю, но быстро поняли, что это не сработает. </p>
<p>В социальной сети функционал должен быть интуитивно понятным. Пользователи не должны часами разбираться во всех наворотах приложения. В идеале интерфейс должен быть настолько интуитивным, чтобы пользователю, впервые оказавшемуся на нашем ресурсе, не понадобилось обращаться к разделу FAQ. После нескольких итераций, в конечном варианте, мы разместили ключевые информационные блоки во вкладках основной области страницы. На больших экранах личные профили отображают всю информацию в одном окне, на малых — менее важные функции скрыты в меню навигации.</p>
<p><img src="https://makeomatic.ru/blog/images/2.jpg" alt="2"><br><img src="https://makeomatic.ru/blog/images/3.jpg" alt="3"></p>
<h4 id="Социальное-взаимодействие"><a href="#Социальное-взаимодействие" class="headerlink" title="Социальное взаимодействие"></a>Социальное взаимодействие</h4><p>Любая социальная сеть — прежде всего, площадка для общения. Поэтому мы интегрировали личные сообщения, систему отзывов и рейтинги. Пользователи могут оставлять комментарии о сделках с другими пользователями, что позволит отсеивать неблагонадежных путешественников и заказчиков. Алгоритм формирования рейтинга основан на ряде параметров, в том числе учитывается активность на сайте, отзывы, количество заказанных и доставленных товаров.</p>
<p><img src="https://makeomatic.ru/blog/images/4.jpg" alt="4"></p>
<p>Не зря говорят, истина в мелочах. Протестировав наш интерфейс на нескольких десятках пользователей (юзабилити-тестирование, на самом деле, полезная штука), мы поняли, что профилям нашей социальной сети не хватает одной важной детали — поиска попутчиков. Новые сайты для поиска попутчиков постоянно появляются именно потому, что часто людям не с кем ехать в отпуск, при этом, отправляясь в путешествие, всем хочется провести его в хорошей компании. И наше тестирование подтвердило: пользователи ожидали увидеть эту функцию в социальной сети для путешественников. </p>
<p>Не теряя времени, мы добавили опцию поиска попутчиков в профили, повысив тем самым социальную активность, мотивируя людей возвращаться и пользоваться нашим приложением чаще. Также мы добавили вкладку “дневник”, где вернувшиеся из поездки пользователи могут делиться впечатлениями и фотографиями. Таким образом, мы старались учесть все принпицы социальной медиа оптимизации (SMO). </p>
<p><img src="https://makeomatic.ru/blog/images/5.png" alt="5"></p>
<h3 id="Больше-технических-подробностей"><a href="#Больше-технических-подробностей" class="headerlink" title="Больше технических подробностей"></a>Больше технических подробностей</h3><p>Было бы несправедливо не упомянуть еще одно секретное оружие Makeomatic: клиентская часть приложения написана на Angular.js. Этот “волшебный” фреймворк от Google, наверное, у всех на слуху. Конечно, в нём больше логики, чем магии — любой инструмент становится мощным оружием, как только вы хорошо в нём разберётесь. В начале цикла разработки мы выбирали из нескольких популярных фреймворков, и по ряду причин остановились на Angular.js. Его разрабатывает серьёзная корпорация и поддерживает большое сообщество программистов (поэтому вероятность, что однажды фреймворк забросят, крайне мала); также, Angular.js отлично работает в связке с Node.js и MongoDB (используемая в этом проекте база данных). Кроме того, мы много работали именно с этим фреймворком на прошлых проектах:  как говорится, опыт не пропьёшь лучший учитель  — опыт.</p>
<p>Были и более мелкие технические решения, такие как: выбор инструмента для автоматизации задач (Gulp), препроцессинга стилей (в данном случае, Stylus) и шаблонизатора (Jade).</p>
<p>Раз вы всё ещё с нами, вас явно интересуют современные веб-технологии. А может, вы только определяетесь, какие инструменты выбрать для вашего следующего умопомрачительного стартапа (если вам понадобится помощь - обращайтесь, с удовольствием проконсультируем). Пожалуй, на этом закончим говорить о технических аспектах. В конечном итоге, гораздо важнее — будет ли ваш стартап, продукт или приложение решать реальные проблемы людей. Если будет, то какие бы инструменты вы ни выбрали, ваш пользователь всё равно вас найдёт!</p>
<p>По прогнозам экономистов, в ближайшие годы рынок электронной коммерции продолжит расти, и всё больше людей будут стремиться приобретать необычные, эксклюзивные вещи. Правительство, к сожалению, постоянно грозится снизить беспошлинный порог для онлайн-покупок из-за рубежа. В связи с этим  мы надеемся, что разработанная нами социальная сеть объединит тех, кто готов помочь другим (получив при этом денежный бонус в дополнение к поездке), и тех, кто хочет покупать товары за границей. </p>
<p>Команда Makeomatic поздравляет всех с наступающим, 2016ым, Новым Годом! Будьте на волне современных трендов и воплощайте все ваши задумки в жизнь!</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://makeomatic.ru/blog/images/f4f_main.jpg&quot; alt=&quot;f4f&quot;&gt;&lt;/p&gt;
&lt;p&gt;До наступления 2016 года остаются считанные дни — самое время подвести итоги. Для нас в Makeomatic уходящий год был продуктивным. Не нарушая сложившейся традиции, в сентябре мы всей командой посетили конференцию &lt;a href=&quot;http://nodeconfeu.com/&quot;&gt;NodeConf&lt;/a&gt;, проходившую  в замке Уотерфорд в Ирландии (было здорово, но роботов в этот раз не хватало).&lt;br&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="https://makeomatic.ru/blog/tags/Node-js/"/>
    
      <category term="AngularJS" scheme="https://makeomatic.ru/blog/tags/AngularJS/"/>
    
      <category term="ElasticSearch" scheme="https://makeomatic.ru/blog/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>Как работает реляционная база данных</title>
    <link href="https://makeomatic.ru/blog/2015/11/24/relational_database_3/"/>
    <id>https://makeomatic.ru/blog/2015/11/24/relational_database_3/</id>
    <published>2015-11-24T08:00:00.000Z</published>
    <updated>2016-01-08T17:55:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/images/relational database3_main.jpg" alt="картинка main"></p>
<p>В <a href="https://makeomatic.ru/blog/2015/10/12/relational_database_2/">прошлой серии</a> мы подробно поговорили про статистику, оптимизатор запросов, алгоритмы объединения, теперь разберёмся с диспетчером данных.</p>
<a id="more"></a>
<h3 id="Диспетчер-данных"><a href="#Диспетчер-данных" class="headerlink" title="Диспетчер данных"></a>Диспетчер данных</h3><p><img src="/blog/images/rational_database_3_1.png" alt="схема БД и диспетчера данных"></p>
<p>На этапе выполнения запроса диспетчеру запросов необходимы данные таблиц и индексов, за ними он обращается к диспетчеру данных. Здесь есть два сложных момента:</p>
<ol>
<li>Реляционные базы данных работают по транзакционной модели. Другими словами, вы не можете получать любые данные в любой отрезок времени, если в этот момент данные используются / изменяется кем-то ещё;</li>
<li>Извлечение данных - самая медленная операция, поэтому диспетчер данных должен уметь сохранять полученные данные в буфер памяти.<br>Давайте посмотрим, как базы данных решают эти проблемы.</li>
</ol>
<h4 id="Диспетчер-кэша"><a href="#Диспетчер-кэша" class="headerlink" title="Диспетчер кэша"></a>Диспетчер кэша</h4><p>Для повышения производительности во всех современных БД есть диспетчер кэша.</p>
<p><img src="/blog/images/rational_database_3_2.png" alt="схема с диспетчером кэша"></p>
<p>Таким образом, диспетчер запросов получает данные не напрямую из файловой системы, а из буферного пула диспетчера кэша. Это очень сильно ускоряет работу БД. Трудно рассчитать математически, насколько именно такой подход ускоряет извлечение данных - и во многом это зависит от типа накопителя в базе данных (HDD, SSD, дисковые массивы RAID), а также от видов операций: последовательный доступ (например, полное сканирование) или произвольный (например, по ID строки), чтение или запись… Но можно сказать, что получение данных из памяти в 100-100 000 раз быстрее, чем с диска. Однако, и здесь свой нюанс: данные должны оказаться в буферном пулле диспетчера кэша до того, как их запросят, иначе диспетчер запросов обратится к диску.</p>
<h5 id="Предвыборка-данных"><a href="#Предвыборка-данных" class="headerlink" title="Предвыборка данных"></a>Предвыборка данных</h5><p>Для этого существует предвыборка данных. Диспетчер запросов знает (благодаря статистике), какие данные есть на диске, и какие данные ему понадобятся (поскольку ему известен план выполнения запроса). Работает это примерно так: во время обработки первого набора данных, диспетчер запросов просит диспетчер кэша предварительно загрузить второй набор данных в буфер; во время обработки второго набора данных, диспетчер кэша получает команду предварительно загрузить третий набор данных и удалить из кэша первый. И так далее. Вместе с данными диспетчер кеша сохраняет в буферный пул дополнительную информацию (фиксатор – latch), чтобы своевременно очищать кэш, если данные более не нужны.<br>В некоторых БД диспетчер запросов не имеет возможности знать заранее, какие данные ему понадобятся — в этом случае осуществляется предвыборка предполагаемых необходимых данных (например, если диспетчеру запросов понадобились данные 1, 3, 5, скорее всего, он в скором времени запросит и данные 7, 9, 11). Иногда также используется последовательная предвыборка (когда диспетчер кеша просто подгружает в буфер данные, следующие сразу за запрошенными).</p>
<p>Для измерения эффективности предвыборки данных в современных БД есть коэффициент попадания в кэш. Он отражает, насколько часто запрашиваемые данные были получены из буферного пула, без обращения к диску. К слову, низкий коэффициент ещё не означает, что предвыборка данных работает плохо — подробнее об этом можно прочитать в <a href="http://docs.oracle.com/database/121/TGDBA/tune_buffer_cache.htm#TGDBA294" target="_blank" rel="external">документации Oracle</a>.</p>
<p>Разумеется, объём буферной памяти не безграничен, и чтобы загружать новые данные, нужно очищать кэш от старых, это достаточно ресурсозатратная операция. Если у вас есть часто выполняемый запрос, не имеет смысла каждый раз загружать его в кеш, а потом удалять.Для таких случаев современные БД используют стратегию замены буфера.</p>
<h5 id="Стратегии-замены-буфера"><a href="#Стратегии-замены-буфера" class="headerlink" title="Стратегии замены буфера"></a>Стратегии замены буфера</h5><p>Большинство баз данных (например, SQL Server, MySQL, Oracle, DB2) используют алгоритм вытеснения по давности использования - LRU (Least Recently Used). Идея в том, чтобы хранить в кеше только данные, которые только что использовались, и значит, скорее всего, в ближайшее время снова будут использоваться.<br>Схематично это можно представить следующим образом:</p>
<p><img src="/blog/images/rational_database_3_3.png" alt="иллюстрация алгоритма LRU"></p>
<p>Для простоты будем считать, что данные в буфере не фиксированы (то есть их можно удалить). В нашем примере буфер может хранить 3 набора данных. Алгоритм действует следующим образом:</p>
<ol>
<li>диспетчер кэша использует набор 1 и помещает его в пустой буфер;</li>
<li>далее он использует набор 4 и помещает его в буфер;</li>
<li>затем используется набор 3, который также отправляется в буфер;</li>
<li>диспетчер кеша использует набор 9 — буфер переполнен, поэтому удаляется набор 1, который использовался наиболее давно, набор 9 помещается в буфер;</li>
<li>диспетчер кэша использует набор 4 — он уже есть в буфере и становится только что использованным набором данных;</li>
<li>диспетчер запроса использует набор 1 — буфер переполнен, поэтому набор 9 удаляется как наиболее давно использованный, набор 1 помещается в буфер.<br>И так далее.</li>
</ol>
<p>Этот алгоритм работает хорошо, но у него есть некоторые ограничения. Например, в случае полного сканирования большой таблицы. Если размер таблицы / индекса больше размера буфера, данный алгоритм удалит все предыдущие значения в кеше, хотя данные полного сканирования скорее всего будут использованы лишь один раз.</p>
<p>Чтобы такого не случалось, некоторые БД добавили специальные правила. <a href="http://docs.oracle.com/database/121/CNCPT/memory.htm#CNCPT1222" target="_blank" rel="external">Пример из документации Oracle</a>: «В случае очень больших таблиц база данных, как правило, считывает наборы данных напрямую, без загрузки в кеш. Если таблица средних размеров, может использоваться как прямое считывание, так и загрузка из кеша. Если БД решает использовать чтение из кеша, данные помещаются в конец списка LRU, чтобы избежать очистки кеша».</p>
<p>Существует улучшенная версия алгоритма — LRU-K, используемая, например, в SQL Server (K=2). В случае LRU (где K=1) учитывается только, когда данные использовались в последний раз. Улучшенная версия анализирует, какие данные использовались последние K раз. Часто используемые данные обладают большим весом. При загрузке в кеш нового набора данных, старые часто используемые данные не удаляются (поскольку количество раз их использования больше). Но в случае, если данные не используются часто, алгоритм не хранит их в кеше. Таким образом, со временем вес данных снижается, если они реже используются.<br>Расчет веса данных требует некоторых системных ресурсов, поэтому SQL Server использует только K = 2 — наиболее оптимальный вариант с точки зрения ресурсозатрат.<br>Более подробную информацию про LRU-K алгоритм вы найдёте в <a href="http://www.cs.cmu.edu/~christos/courses/721-resources/p297-o_neil.pdf" target="_blank" rel="external">этой работе</a>.</p>
<h6 id="Другие-алгоритмы"><a href="#Другие-алгоритмы" class="headerlink" title="Другие алгоритмы"></a>Другие алгоритмы</h6><p>Есть и другие алгоритмы замены буфера: 2Q и CLOCK (похожи на LRU-K); MRU (Most Recently Used) — использует ту же логику, что и LRU, но другие правила; LRFU (Least Recently and Frequently Used), и так далее. В некоторых базах данных можно самостоятельно выбирать алгоритм.</p>
<h5 id="Буфер-записи"><a href="#Буфер-записи" class="headerlink" title="Буфер записи"></a>Буфер записи</h5><p>Мы говорили только про буферы чтения, которые подгружают данные перед их использованием. Но в базе данных есть и буферы записи, которые позволяют группировать данные и передавать их наборами, что сокращает количество обращений к диску.</p>
<p>Следует помнить, что в буфере хранятся страницы (минимальная единица данных), а не ряды (то, как мы визуально представляем данные). Если страница в буферном пуле была изменена, но не записана на диск, она считается «грязной». Существуют различные алгоритмы для вычисления лучшего времени для записи «грязных» страниц на диск, все они вписываются в транзакционную модель, о которой и поговорим далее.</p>
<h4 id="Диспетчер-транзакций"><a href="#Диспетчер-транзакций" class="headerlink" title="Диспетчер транзакций"></a>Диспетчер транзакций</h4><p>Основное правило транзакционной модели: одна транзакция — один запрос.<br>Давайте сначала разберёмся, что же такое ACID-транзакции.</p>
<p>ACID-транзакция предусматривает четыре условия:</p>
<ol>
<li>Неразрывность: транзакция либо выполнена полностью, либо не выполнена вовсе, даже если она длится 10 часов. Если происходит сбой, всё возвращается в состояние до начала транзакции;</li>
<li>Изолированность: если одновременно выполняются транзакции A и B, ни одна из них никак не может повлиять на результат второй;</li>
<li>Надёжность: как только транзакция успешно завершилась, результат сохраняется в БД, независимо от любых обстоятельств (падение или ошибки).</li>
<li>Однородность: только корректные (с точки зрения реляционных и функциональных ограничений) данные записываются в БД, что обеспечивается неразрывностью и изолированностью транзакций.</li>
</ol>
<p><img src="/blog/images/rational_database_3_4.webp" alt="картинка доллара"></p>
<p>Во время транзакции может выполняться несколько SQL запросов на чтение, создание, обновление и удаление данных. Трудности начинаются, когда две транзакции используют одни и те же данные. Классический пример - перевод денег со счета А на счет Б. Представим, что у нас есть 2 транзакции:</p>
<ul>
<li>Транзакция 1 снимает 100$ со счета А и переводит на счёт B;</li>
<li>Транзакция 2 снимает 50$ со счета А и переводит на счёт B.</li>
</ul>
<p>Вернёмся к характеристикам ACID-транзакций:</p>
<ul>
<li>Неразрывность гарантирует, что независимо от того, что произойдёт во время транзакции 1 (сбой сервера, сбой в сети), никогда не получится, что 100$ будут сняты со счёта А, но не дойдут до счёта B.</li>
<li>Изолированность гарантирует, что если обе транзакции выполнятся одновременно, в результате, со счёта А спишутся 150$ и на счёт В будут переведены 150$; ситуация, при которой, например, со счёта А списано 150$, а на счёт В пришло только 50$ (потому что транзакция 2 частично затёрла действия транзакции 1), невозможна.</li>
<li>Надёжность гарантирует, что даже если после выполнения транзакции 1 база упадёт, результат транзакции сохранится в БД.</li>
<li>Однородность гарантирует, что денежные суммы не будут изменяться в системе.</li>
</ul>
<p>Многие современные базы данных не используют изолированность по умолчанию, поскольку она очень ресурсозатратна. В SQL 4 уровня изолированности:</p>
<ol>
<li>Сериализованные транзакции (включены по умолчанию в SQL): максимально изолированные. Две одновременно происходящие транзакции на 100% изолированы друг от друга.</li>
<li>Повторяющееся («фантомное») чтение (включено по умолчанию в MySQL): транзакции изолированы во всех случаях, кроме одного - если транзакция успешно завершается и добавляет новые данные, эти данные будут доступны в других, всё ещё совершаемых, транзакциях. Но если транзакция изменяет уже существующие данные, по её завершению эти изменения не будут доступны параллельно выполняемым транзакциям. Таким образом, нарушение изолированности происходит лишь в случае добавления новых данных.</li>
</ol>
<p>Например, транзакция A совершает<br><code>SELECT COUNT (1) from TABLE_X</code><br>после чего транзакция B добавляет новые данные в TABLE_X; если транзакция A снова выполнит count(1), результат будет уже другим.</p>
<ol>
<li>Чтение фиксированных данных (включено по умолчанию в Oracle, PostgreSQL и SQL Server): повторяющееся чтение с дополнительным нарушением изоляции. Транзакция А читает данные D, а затем эти данные изменяются (или удаляются) транзакцией B, если транзакция A снова считает данные D, изменения, внесённые B, будут ей доступны. Это не повторяющееся чтение.</li>
<li>Чтение нефиксированных данных - самый низкий уровень изолированности. Это чтение фиксированных данных с дополнительным нарушением изолированности. Транзакция A читает данные D, затем эти данные D изменяются транзакцией B (транзакция ещё не завершена), если в этот момент транзакция А параллельно считает данные D, внесённые изменения будут ей доступны. Если по каким-то причинам транзакция B откатывается назад, то данные D, считанные транзакцией A во второй раз, не будут иметь смысла, так как эти изменения были внесены отменённой транзакцией B. Такое чтение называется «грязным».</li>
</ol>
<p>Многие базы данных добавляют свои собственные уровни изоляции (например, снэпшоты, используемые в PostgreSQL, Oracle и SQL Server). И, разумеется, в большинстве БД реализованы не все уровни изоляции (чтение нефиксированных данных встречается не часто).</p>
<p>Уровень изоляции, установленный по умолчанию, можно изменить при первом соединении (буквально одной строчкой кода).</p>
<h5 id="Управление-многозадачностью"><a href="#Управление-многозадачностью" class="headerlink" title="Управление многозадачностью"></a>Управление многозадачностью</h5><p>Наибольшая трудность в обеспечении изолированности, неразрывности и однородности связана с операциями добавления, изменения и удаления одних и тех же данных.<br>Если все транзакции только считывают данные, они могут происходить параллельно, не влияя друг на друга. Если хотя бы одна из транзакций изменяет данные, считываемые другой транзакцией, базе данных необходимо скрыть это изменение от других транзакций, а также гарантировать, что внесённое изменение не будет перезаписано другой транзакцией, которой эти изменения не были видны.<br>Для этого и необходимо управление многозадачностью.<br>Самый простой способ решения вышеописанной проблемы - выполнение каждой транзакции по отдельности (т.е. последовательно). Абсолютно не масштабируемый вариант: если использовать лишь одно ядро многоядерного процессора — об эффективности не может быть и речи.</p>
<p>Для решения этой проблемы при каждом запуске или отмене транзакции нужно:</p>
<ul>
<li>анализировать все операции всех транзакций;</li>
<li>проверять транзакции на предмет конфликтов (например, если две или более транзакций изменяют/считывают одни и те же данные);</li>
<li>изменять порядок совершения операций внутри конфликтующих транзакций;</li>
<li>выполнять конфликтующие части транзакций отдельно, в определенном порядке (в то время как не конфликтующие транзакции продолжают выполняться параллельно);</li>
<li>наконец, учитывать, что транзакция может быть отменена.</li>
</ul>
<p>Другими словами, это проблема нахождения оптимальных графиков выполнения транзакций. Базы данных не могут тратить слишком много времени на нахождение самого оптимального графика для каждой новой транзакции, поэтому они выбирают менее эффективные подходы и тратят время на разрешение конфликтующих транзакций.</p>
<h5 id="Диспетчер-блокировок"><a href="#Диспетчер-блокировок" class="headerlink" title="Диспетчер блокировок"></a>Диспетчер блокировок</h5><p>Чтобы справиться с проблемами многозадачности, многие БД используют блокировки и/или управление версиями данных. Рассмотрим виды блокировок.</p>
<h6 id="Полная-блокировка"><a href="#Полная-блокировка" class="headerlink" title="Полная блокировка"></a>Полная блокировка</h6><p>В целом, идея блокировки такова: если транзакции необходимы какие-либо данные, она их блокирует; если другой транзакции понадобятся эти же данные, ей придётся ждать, пока первая транзакция разблокирует доступ к ним.<br>Однако, крайне неразумно использовать полную блокировку для транзакции, которой необходимо только считать данные, поскольку другим транзакциям, которым также необходимо только считать данные, придётся ждать.</p>
<p>В таких случаях лучше использовать <strong>блокировку с обеспечением совместного доступа</strong>, которая работает так:</p>
<ul>
<li>если транзакции нужно лишь прочитать данные А, она блокирует данные с обеспечением совместного доступа и считывает их;</li>
<li>если другой транзакции также нужно лишь прочитать данные А, она точно также их блокирует и считывает;</li>
<li>если какой-то транзакции нужно внести изменения в данные А, она полностью блокирует их, однако ей приходится ждать, пока предыдущие две транзакции снимут совместную блокировку с данных.<br>При этом, если данные заблокированы полностью, транзакции, которая только считает данные, всё равно придётся ждать окончания полной блокировки для последующей блокировки с обеспечением совместного доступа.</li>
</ul>
<p>Вернёмся к диспетчеру блокировок.</p>
<p><img src="/blog/images/rational_database_3_5.png" alt="схема диспетчера блокировок"></p>
<h6 id="Диспетчер-блокировок-1"><a href="#Диспетчер-блокировок-1" class="headerlink" title="Диспетчер блокировок"></a>Диспетчер блокировок</h6><p>Диспетчер блокировок- это процесс, накладывающий и снимающий блокировки. Данные о блокировках хранятся в хеш-таблице (где ключ — заблокированные данные). Диспетчер знает, какие именно транзакции блокируют данные и какие транзакции ожидают разблокировки данных.</p>
<h6 id="Взаимная-блокировка"><a href="#Взаимная-блокировка" class="headerlink" title="Взаимная блокировка"></a>Взаимная блокировка</h6><p>Однако, случаются ситуации, когда транзакциям придётся ждать разблокировки данных бесконечно:</p>
<p><img src="/blog/images/rational_database_3_6.png" alt="иллюстрация взаимоблокировки"></p>
<p>На данной схеме транзакция A полностью блокировала данные 1 и ожидает разблокировки данных 2. При этом, транзакция B полностью блокировала данные 2 и ожидает разблокировки данных 1.</p>
<p>В такой ситуации диспетчер блокировок решает, какую блокировку отменить для разрешения конфликта. И это непростое решение. Стоит ли отменить транзакцию, изменившую наименьшее количество данных? Или же отменить самую последнюю транзакцию, поскольку клиенты других транзакций ожидали дольше? Стоит ли отменить наиболее короткую транзакцию? В случае отмены, на какое количество других транзакций это повлияет?</p>
<p>Но до принятие решения диспетчер блокировок должен убедиться, что взаимная блокировка действительно произошла. Если это так, это отразится в хеш-таблице блокировок в виде цикличного процесса. Однако, проверять всю таблицу на наличие таких циклов слишком ресурсозатратно. Поэтому часто просто используют таймауты: если разблокировка не происходит в течение заданного таймаута, значит, произошла взаимная блокировка.</p>
<p>Прежде, чем блокировать данные, диспетчер блокировок может проверить, не приведёт ли это к взаимоблокировке. Но, увы, такое вычисление тоже очень ресурсозатратно, поэтому часто используют набор простых правил.</p>
<h6 id="Двухфазная-блокировка"><a href="#Двухфазная-блокировка" class="headerlink" title="Двухфазная блокировка"></a>Двухфазная блокировка</h6><p>Наиболее просто обеспечить полную изолированность блокировок, если применять блокировку в начале транзакции и снимать по факту её завершения. Таким образом, транзакции приходится ждать снятия всех предыдущих блокировок до начала выполнения и снимать собственную блокировку после окончания выполнения. Звучит отлично, но между всеми этими ожиданиями потеряется куча времени.</p>
<p>Более мудрый подход, реализованный в DB2 и SQL Server, - протокол двухфазной блокировки. В этом случае транзакция делится на две части:</p>
<ol>
<li>Фаза подъёма: транзакция может накладывать блокировку, но не может снимать её;</li>
<li>Фаза спада: транзакция может снять блокировку (с данных, которые она уже обработала и к которым не будет возвращаться), но не может накладывать новые блокировки.</li>
</ol>
<p><img src="/blog/images/rational_database_3_7.png" alt="иллюстрация конфликта блокировок без протокола двухфазной блокировки"></p>
<p>Таким образом, блокировки, которые уже не нужны, снимаются, сокращая время ожидания других транзакций. Также благодаря протоколу исключаются ситуации, когда транзакция получает данные, в которые были внесены изменения до начала транзакции (соответственно, они не соответствуют запрашиваемым данным).</p>
<p>Протокол двухфазной блокировки работает отлично, кроме случаев, когда транзакция, изменившая данные и снявшая блокировку, отменяется. Может получиться, что другая транзакция в этот момент считывает изменённые данные, а изменения отменяются. Во избежание подобных ситуаций <strong>все полные блокировки должны сниматься только по окончании транзакции</strong>.</p>
<p>Конечно, в реальных базах данных используются и более глубокие блокировки (блокировки рядов, страниц, разделов, таблиц, табличных пространств).</p>
<p>Также для решения проблем многозадачности БД использую управление версиями данных, суть которого в следующем:</p>
<ul>
<li>транзакции могут изменять одни и те же данные одновременно;</li>
<li>у каждой транзакции своя копия (версия) данных;</li>
<li>если две транзакции изменяют одни и те же данные, только одно изменение в итоге вступает в силу — вторая транзакция отменяется (и затем, возможно, выполняется заново).</li>
</ul>
<p>Управление версиями данных улучшает производительность БД, поскольку читающие транзакции не блокируют записывающие транзакции, и наоборот. Плюс мы экономим ресурсы, которые бы использовал медленный диспетчер блокировок.</p>
<p>Блокировка и управление версиями данных — это два разных подхода (пессимистичный и оптимистичный). У обоих свои плюсы и минусы (в зависимости от количества чтений/записей).<br>Рекомендую к прочтению <a href="http://momjian.us/main/writings/pgsql/mvcc.pdf" target="_blank" rel="external">презентацию от PostgreSQL</a> про мультиверсионное управление многозадачностью.</p>
<p>Некоторые БД (DB2 до версии 9.7, SQL Server за исключением снепшотов) используют только блокировки. Другие (PostgreSQL, MySQL, Oracle) используют как блокировки, так и управление версиями данных. А вот базы данных, использующие только управление версиями данных, мне не известны.<br>Стоит отметить, что управление версиями данных иногда может внести хаос в индексы: в уникальных индексах могут появиться дубликаты, записей в индексах может оказаться больше, чем в таблице и т.д.</p>
<p><strong>Правка (08/20/2015 )</strong> в комментариях поделились информацией, что Firebird и Interbase применяют исключительно управление версиями данных.</p>
<p>В части про уровни изолированности мы выяснили, с повышением уровня увеличивается и количество блокировок, а значит и время ожидания транзакций снятия этих блокировок. Именно поэтому большинство БД не используют по умолчанию сериализованные транзакции (наивысший уровень изолированности).</p>
<p>Как обычно, советую изучить тему подробнее в официальных доках <a href="http://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-model.html" target="_blank" rel="external">MySQL</a>, <a href="http://www.postgresql.org/docs/9.4/static/mvcc.html" target="_blank" rel="external">PostgreSQL</a> или <a href="http://docs.oracle.com/cd/B28359_01/server.111/b28318/consist.htm#i5337" target="_blank" rel="external">Oracle</a>.</p>
<h5 id="Диспетчер-логов"><a href="#Диспетчер-логов" class="headerlink" title="Диспетчер логов"></a>Диспетчер логов</h5><p>Итак, мы знаем, что для увеличения производительности, БД загружает данные в буферный пул. Но если сервер падает во время транзакции, данные, которые находились в памяти во время падения, будут утеряны, а это нарушает принцип надёжности транзакций.</p>
<p>Можно всё записывать сразу на диск, но если в процессе сервер выйдет из строя, у вас на диске в итоге будет лишь часть обновлённых данных, а это в корне нарушает принцип неразрывности транзакций.<br>В подобных случаях любые изменения, внесённые прерванной транзакцией, должны быть отменены.</p>
<p>Сделать это можно двумя способами:</p>
<ol>
<li>Теневые копии: каждая транзакция создаёт свою копию БД (или её части) и работает с этой копией. В случае ошибок копия удаляется. В случае успешного завершения транзакции, БД принимает данные из теневой копии, а старые удаляет.</li>
<li>Лог транзакций: перед каждой записью на диск, БД пишет детали транзакции в лог, чтобы в случае падения / отмены транзакции, она знала, как удалить/завершить незаконченную транзакцию.</li>
</ol>
<h5 id="Протокол-предварительного-логирования"><a href="#Протокол-предварительного-логирования" class="headerlink" title="Протокол предварительного логирования"></a>Протокол предварительного логирования</h5><p>Использование теневых копий в больших базах данных с миллионами транзакций — это смерть для дисковой системы. Поэтому большинство БД используют лог, который должен храниться на стабильном накопителе (не будем вдаваться в детали, но как минимум необходимо использовать дисковые массивы RAID).</p>
<p>Большинство БД (Oracle, SQL Server, DB2, PostgreSQL, MySQL, SQLite) используют <strong>протокол предварительного логирования</strong> (WAL – Write-Ahead Logging), работа которого основана на трёх правилах:</p>
<ol>
<li>Каждое внесённое в БД изменение записывается в лог транзакций, и данная запись должна происходить до того, ка кданные запишутся на диск;</li>
<li>Записи в лог транзакций делаются в логической последовательности выполнения транзакций:</li>
<li>Когда транзакция фиксируется, запись об этом должна появиться в логе до того, как транзакция успешно завершится.</li>
</ol>
<p><img src="/blog/images/rational_database_3_8.png" alt="схема диспетчера логов"></p>
<p>По идее, диспетчер логов должен располагаться между диспетчером кеша и диспетчером доступа к данным (который записывает данные на диск) и записывать каждую операцию изменения/удаления/создания/отката в лог транзакций до того, как эти изменения попадут на диск. Верно?</p>
<p>А вот и нет. После всего, что мы с вами узнали, несложно догадаться, что и тут, как всегда в случаях с базами данных, ключевая и решающая деталь — общая производительность. Если диспетчер логов будет тормозить, это негативно скажется на работе всей БД.</p>
<h5 id="ARIES"><a href="#ARIES" class="headerlink" title="ARIES"></a>ARIES</h5><p>В 1992 году инженеры IBM «создали» расширенную версию WAL под названием ARIES, которая в той или иной степени реализована во всех современных БД. Я написал «создали» в кавычках, потому что согласно <a href="http://db.csail.mit.edu/6.830/lectures/lec15-notes.pdf" target="_blank" rel="external">этому курсу MIT</a>, инженеры IBM сделали ничто иное как собрали воедино все лучшие практики восстановления транзакций. Но в данном случае это мелочи. Я прочёл большую часть <a href="http://www.cs.berkeley.edu/~brewer/cs262/Aries.pdf" target="_blank" rel="external">научно-исследовательской работы по ARIES</a> – на самом деле увлекательно! Далее я сделаю краткий обзор технологии, а за подробностями прошу обращаться к первоисточнику.</p>
<p>Итак, основные задачи, решаемые ARIES (Algorithms for Recovery and Isolation Exploiting Semantics):<br>а) обеспечить высокую производительность при записи в лог транзакций,<br>б) обеспечить быстрое и надёжное восстановление.</p>
<p>По каким причинам транзакция может быть отменена?</p>
<ul>
<li>Её отменил пользователь;</li>
<li>Сбой сервера, сбой в сети;</li>
<li>В связи с тем, что транзакция нарушила целостность базы данных (например, у вас на столбце ограничение UNIQUE, а транзакция добавила дубликат);</li>
<li>Из-за взаимной блокировки.</li>
</ul>
<p>В некоторых случаях (например, сбой в сети) БД может восстановить транзакцию. Чтобы понять, как это происходит, разберёмся, какая информация хранится в логе.</p>
<h6 id="Логи"><a href="#Логи" class="headerlink" title="Логи"></a>Логи</h6><p>В результате любой операции в логе создаётся запись, которая состоит из следующих компонентов:</p>
<ol>
<li>LSN (Log Sequence Number): уникальный регистрационный номер транзакции, присваиваемый в хронологическом порядке (на самом деле, всё немного сложнее, но опустим детали). Это означает, что если операция A произошла раньше операции B, регистрационный номер A будет меньше, чем у B;</li>
<li>TransID: идентификатор транзакции, совершившей операцию;</li>
<li>PageID: место на диске, где хранятся изменённые данные. Минимальная единица данных — страница, поэтому место хранения изменённых данных это место хранения страницы;</li>
<li>PrevLSN: ссылка на предыдущую запись в логе об этой транзакции;</li>
<li>UNDO: описание способа отменить результат транзакции; например, если это операция обновления, в UNDO сохранится либо значение/состояние данных до внесения изменений (физическое UNDO), либо информация об обратной операции, которая вернёт прежние данные (логическое UNDO); ARIES использует только логическое UNDO;</li>
<li>REDO: описание способа повторного выполнения операции; то есть сохранится либо значение/состояние данных после внесения изменений, либо сама операция;</li>
<li>в логе ARIES также имеются поля UndoNxtLSN и Type.</li>
</ol>
<p>Насколько мне известно, PostgreSQL – единственная БД, не использующая UNDO, это связано с управлением версиями данных. Вместо этого там реализован сборщик мусора, удаляющий старые версии данных.</p>
<p>Небольшой наглядный пример лога запроса <code>UPDATE FROM PERSON SET AGE = 18;</code> Предположим, данный запрос выполняется в транзакции 18.</p>
<p><img src="/blog/images/rational_database_3_9.png" alt="иллюстрация примера лога запросов"></p>
<p>У каждого лога уникальный регистрационный номер . Связанные логи относятся к одной и той же транзакции.</p>
<h6 id="Буфер-логов"><a href="#Буфер-логов" class="headerlink" title="Буфер логов"></a>Буфер логов</h6><p>Для оптимизации работы логов существует буфер логов.</p>
<p><img src="/blog/images/rational_database_3_10.png" alt="иллюстрация упрощённого процесса записи в лог"></p>
<p>Упрощённо процесс записи в лог происходит следующим образом:</p>
<ol>
<li>исполнитель запросов запрашивает внесённые изменения;</li>
<li>диспетчер кеша сохраняет изменения в буфере;</li>
<li>диспетчер логов помещает соответствующую запись в в буфер;</li>
<li>на этом этапе исполнитель запросов считает, что операция выполнена (и можно запрашивать другие данные);</li>
<li>затем диспетчер логов вносит соответствующую запись в лог транзакций (решение о том, когда именно вносить эту запись, принимает алгоритм);</li>
<li>наконец, диспетчер кеша записывает изменение на диск (решение о том, когда вносить эту запись, также основано на алгоритме).</li>
</ol>
<p>Если транзакция фиксируется, это значит, что все вышеперечисленные пункты выполнены для всех операций внутри транзакции. В конечном счёте, запись в лог транзакций — достаточно быстрая операция, поскольку это всего лишь запись лога в произвольное место в логе транзакций. В сравнении с этим запись на диск — более сложная и долгая операция, подразумевающая запись данных на диск таким образом, чтобы в дальнейшем их было легко считать.</p>
<h6 id="Стратегии-восстановления"><a href="#Стратегии-восстановления" class="headerlink" title="Стратегии восстановления"></a>Стратегии восстановления</h6><p>В целях повышения производительности последний (6ой) пункт в некоторых БД может выполняться после фиксации транзакции, поскольку в случае падений системы транзакцию всё же можно восстановить с помощью информации REDO в логе. Такая стратегия называется произвольной (NO FORCE POLICY).<br>Однако, для снижения нагрузки во время восстановления БД может применить и силовую стратегию (FORCE POLICY) — когда запись изменений на диск диспетчером кеша производится только и исключительно до фиксации транзакции.</p>
<p>Второе принципиальное различие в стратегиях - применение поэтапной (STEAL – step-by-step policy) записи данных на диск, или же одномоментной записи, когда буфер дожидается фиксации коммита, и потом всё разом пишет на диск (NO-STEAL policy). В данном случае выбор стратегии зависит от того, что вам нужно: быстрая запись, но длительное восстановление с помощью UNDO в логе, или быстрое восстановление.</p>
<p>Кратко различия в стратегиях:</p>
<ul>
<li>для стратегии STEAL / NO FORCE необходимы UNDO и REDO; наиболее производительный подход, но с более сложной структурой логов и восстановительных процессов (как в ARIES); применяется в большинстве БД — эту информацию я много где встречал, хотя ни разу не видел явно задокументриванной;</li>
<li>для стратегии STEAL / FORCE нужен только UNDO;</li>
<li>для стратегии NO STEAL / NO FORCE нужен только REDO;</li>
<li>стратегия NO STEAL / FORCE не использует никаких записей в логах, но наименее продуктивна и требует огромного количество памяти.</li>
</ul>
<h6 id="Процесс-восстановления"><a href="#Процесс-восстановления" class="headerlink" title="Процесс восстановления"></a>Процесс восстановления</h6><p>Итак, у нас есть все засипи в логах, давайте посмотрим, как их используют.<br>Предположим, стажёр уронил нашу базу данных (правило №1: в любой непонятной ситуации виноват стажёр!). Перезапускаем БД, начинается процесс восстановления.<br>В ARIES этот процесс выглядит так:</p>
<ol>
<li>Анализ: процесс восстановления считывает весь лог транзакций , чтобы восстановить последовательность операций во время сбоя. Вычисляется, какие операции необходимо откатить (все не зафиксированные транзакции), и какие данные необходимо было записать на диск во время падения;</li>
<li>Повторное выполнение: начиная с конкретной записи в логе (определённой во время анализа), выполняется REDO для приведения БД в состояние до падения. REDO записи в логе обрабатываются в хронологическом порядке благодаря уникальным регистрационным номерам транзакций (LSN). Процесс восстановления считывает номер LSN страницы на диске<br>Если LSN(страницы на диске) &gt; = LSN(записи в логе), это значит, что изменения в данные уже были внесены до сбоя (значение было переписано операцией, произошедшей после записи в логе и перед падением). Соответственно, никаких изменений не вносится. Если же LSN(страницы на диске) &lt; LSN(записи в логе), страница на диске обновляется.<br>Для упрощения процесса восстановления REDO иногда выполняется даже для транзакций, которые будет отменены (хотя, думаю, в современных БД так уже не делают);</li>
<li>Отмена: наконец, откатываются все транзакции, незавершённые на момент падения БД. Откат начинается с последних записей в логе каждой такой транзакции, то есть UNDO записи обрабатываются в обратном порядке (используя PrevLSN в логе).</li>
</ol>
<p>Во время восстановления действия лога транзакций и процесса восстановления должны синхронизироваться, чтобы данные, записываемые на диск, соответствовали записям, заносимым в лог. В данном случае можно было бы сразу удалять из лога записи о транзакциях, которые отменяются, но технически это не так просто сделать. Вместо этого, ARIES вносит в лог записи, которые логически удаляют записи об отменённых транзакциях.</p>
<p>Когда транзакция отменяется «вручную» или диспетчером блокировок (для снятия взаимной блокировки) или из-за сбоев в сети, этап анализа не обязателен, поскольку информация о том, что нужно повторно выполнить или отменить, есть в двух хранящихся в памяти таблицах — таблице транзакций (хранит информацию о состоянии всех текущих транзакций) и таблице грязных страниц (хранит информацию о данных, которые необходимо записать на диск). Данные в этих таблицах обновляются диспетчерами кеша и транзакций при каждой новой транзакции. При падении системы эти таблицы стираются из памяти.</p>
<p>Задача этапа анализа как раз в том, чтобы восстановить эти таблицы после падения, используя записи в логе транзакций. Для ускорения процесса анализа в ARIES есть контрольные точки: время от времени данные из таблицы транзакций и таблицы грязных страниц записываются на диск вместе с последним на момент записи номером (LSN). Таким образом, во время анализа обрабатываются только логи, идущие после этого LSN.</p>
<h4 id="Заключение"><a href="#Заключение" class="headerlink" title="Заключение"></a>Заключение</h4><p>До начала написания этой статьи я отдавал себе отчёт, насколько это обширная тема, и как много времени займёт составление детального материала. Как оказалось, мои представления были слишком оптимистичными, и на написание ушло в два раза больше времени, чем я предполагал. Зато в процессе я узнал много нового.</p>
<p>Рекомендую к прочтению отличный и полный обзор по БД — <a href="http://db.cs.berkeley.edu/papers/fntdb07-architecture.pdf" target="_blank" rel="external">Архитектура Базы Данных</a>. Сто десять страниц хорошо составленной информации, как ни странно, написано языком, понятным даже новичку. Этот обзор в основном про архитектурные концепции, а не про алгоритмы и структуры данных; очень помог мне разработать структуру моей статьи.</p>
<p>Теперь вы точно знаете, как работает реляционная база данных! И, конечно, вам понятны следующие тезисы:</p>
<ul>
<li>индексы B+деревьев,</li>
<li>общая структура БД,</li>
<li>оптимизация с учётом затрат,</li>
<li>операторы объединения,</li>
<li>назначение буферного пула,</li>
<li>управление транзакциями.</li>
</ul>
<p>Но, поверьте, я рассказал далеко не про все хитрости БД. Не затронуты, например, следующие темы:</p>
<ul>
<li>управление кластеризованными БД и глобальными транзакциями,</li>
<li>создание снэпшотов работающей БД,</li>
<li>эффективное хранение и сжатие данные,</li>
<li>управление памятью.</li>
</ul>
<p>Вооружённые таким багажом знаний, подумайте лишний раз, выбирая между сырыми NoSQL базами данных и проверенными временем реляционными БД. Не поймите меня неверно: некоторые NoSQL базы очень даже ничего. Но это всё же новые технологии, решающие конкретные проблемы конкретных приложений.</p>
<p>В общем, надеюсь, если кто-то спросит вас: «Как работает реляционная БД?», вы теперь сможете дать достойный ответ. Или, в крайнем случае, - ссылку на эту статью.</p>
<p>Читайте так же статьи по теме:</p>
<ul>
<li><a href="https://makeomatic.ru/blog/2015/10/02/relational_database_1/">Как работает реляционная база данных. Часть 1</a></li>
<li><a href="https://makeomatic.ru/blog/2015/10/12/relational_database_2/">Как работает реляционная база данных. Часть 2</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/images/relational database3_main.jpg&quot; alt=&quot;картинка main&quot;&gt;&lt;/p&gt;
&lt;p&gt;В &lt;a href=&quot;https://makeomatic.ru/blog/2015/10/12/relational_database_2/&quot;&gt;прошлой серии&lt;/a&gt; мы подробно поговорили про статистику, оптимизатор запросов, алгоритмы объединения, теперь разберёмся с диспетчером данных.&lt;/p&gt;
    
    </summary>
    
    
      <category term="SQL" scheme="https://makeomatic.ru/blog/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Как работает реляционная база данных</title>
    <link href="https://makeomatic.ru/blog/2015/10/12/relational_database_2/"/>
    <id>https://makeomatic.ru/blog/2015/10/12/relational_database_2/</id>
    <published>2015-10-12T07:00:00.000Z</published>
    <updated>2016-01-08T17:55:51.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Статистика"><a href="#Статистика" class="headerlink" title="Статистика"></a>Статистика</h3><p><img src="/blog/images/sql2_main.png" alt="картинка main"></p>
<p>Прежде чем разбираться, как база данных оптимизирует запросы, давайте поговорим о статистике, потому что без неё любая база данных будет неэффективной. Если БД не анализирует собственные данные, её действия будут крайне неразумны. Какая же информация нужна БД для анализа?</p>
<a id="more"></a>
<p>Вкратце напомню, что для хранения данных операционные системы и БД используют минимальные единицы, называемые страницами или блоками — по умолчанию их размер составляет 4 или 8 килобайт. То есть если вам нужен всего 1 Кбайт, вы в любом случае займёте целый блок — в случае если его размер 8 Кбайт, из них 7 Кбайт вы потратите впустую.</p>
<p>Вернёмся к статистике.</p>
<p>Когда БД собирает статистику, она анализирует следующую информацию:</p>
<ol>
<li>количество строк/страниц в таблице;</li>
<li>количество значений для каждого столбца в таблице;</li>
<li>длину соответствующих значений (мин, макс, среднее);</li>
<li>диапазон этих значений (мин, макс, среднее);</li>
<li>данные об индексах таблицы.</li>
</ol>
<p>Эта информация помогает оптимизатору оценить потребление памяти и ресурсов ЦП и производительность дискового ввода/вывода для любого запроса.</p>
<p>Почему, например, необходимо собирать статистику для каждого столбца? </p>
<p>Предположим, в таблице PERSON мы собираемся объединить 2 столбца: фамилию (LAST_NAME) и имя (FIRST_NAME). Благодаря статистике, мы узнаем, что значений имён всего 1000, в то время как фамилий - 1 000 000. Поэтому база данных объединит значения в порядке LAST_NAME- FIRST_NAME (а не наоборот), таким образом она произведёт меньше операций сравнения - фамилии вряд ли будут совпадать, так что в большинстве случаев сравнения 2 или 3 первых букв будет достаточно.</p>
<p>Это простые примеры. Можно собирать расширенную статистику и графически представлять её в виде гистограммы, отражающей распределение значений в столбцах. Например, наиболее часто встречающиеся значения, квантили, и так далее.</p>
<p>Расширенная статистика помогает базе данных максимально оптимизировать запрос - особенно для вычисления предиката равенства (WHERE AGE = 18 ) или предиката диапазона (WHERE AGE &gt; 10 and AGE &lt;40 ) - проанализировав данные, БД будет знать количество строк, содержащих необходимую информацию (этот процесс называется «селективность»).</p>
<p>Хранится статистика в метаданных БД. Например, в однораздельных таблицах Oracle вы найдёте её в USER/ALL/DBA_TABLES и USER/ALL/DBA_TAB_COLUMNS, а DB2 хранит статистику в SYSCAT.TABLES и SYSCAT.COLUMNS.</p>
<p>Принципиально важно поддерживать статистические данные актуальными. Нельзя допускать, чтобы БД руководствовалась устаревшей информацией, например, что в таблице 500 строк, когда на самом деле там уже 1 000 000. Единственный минус статистики – на её вычисление требуется время. Поэтому в большинстве баз данных по умолчанию она не собирается автоматически. Естественно, когда у вас очень большие объёмы данных, процесс сбора статистики крайне затратен. В таких случаях лучше собирать только базовую статистику или анализировать небольшую выборку данных.</p>
<p>Например, когда я работал над проектом, где в каждой таблице были сотни миллионов строк, я анализировал только 10%, что сильно ускоряло процесс. К слову, в том случае это оказалось неудачным решением, потому что иногда те 10% данных для конкретного столбца конкретной таблицы, которые отбирает для анализа Oracle 10G, существенно отличаются от общих 100% данных. Неверная статистика привела к тому, что порой запрос занимал 8 часов вместо 30 секунд. Обнаружить причину такого поведения было нелегко.</p>
<p>Всё это лишний раз доказывает, какую важную роль играет статистика.<br>Конечно, в каждой базе данных есть свои специфические опции статистики. Чтобы узнать о них, внимательно ознакомьтесь с документацией к вашей БД. Я прочитал немало доков и, на мой взгляд, <a href="http://www.postgresql.org/docs/9.4/static/row-estimation-examples.html" target="_blank" rel="external">лучшая документации - у PostgreSQL</a>.</p>
<h3 id="Оптимизатор-запросов"><a href="#Оптимизатор-запросов" class="headerlink" title="Оптимизатор запросов"></a>Оптимизатор запросов</h3><p><img src="/blog/images/sql2_1.jpg" alt="картинка гамбургера CBO"></p>
<p>Все современные БД используют оптимизацию с учётом затрат (Cost Based Optimization). Идея в том, чтобы оценить каждую операцию по затратам ресурсов и времени выполнения и найти оптимальный способ выполнения запроса, используя минимальное количество операций и вычислительных ресурсов для получения результата.</p>
<p>Чтобы понять, как оптимизатор запросов работает и насколько это сложный процесс, нужны конкретные примеры. Мы рассмотрим 3 самых распространенных способа объединения двух таблиц, и вы поймёте, что даже простой запрос на объединение иногда сложно оптимизировать. А затем поговорим подробнее, как с этим справляются оптимизаторы баз дланных.</p>
<p>Для простоты мои примеры учитывают только временную сложность, а в базе данных оптимизатор учитывает затраты ресурсов процессора, памяти и операций ввода/вывода. Разница между временной сложностью и затратами процессора в том, что временные затраты – приблизительная величина (для лентяев вроде меня). Для вычисления процессорных затрат мне бы пришлось учитывать все операции — сложение, умножение, итерации, операторы if и так далее. К тому же, каждая высокоуровневая операция процессора состоит из нескольких низкоуровневых операций, и у разных процессоров (будь то Intel Core i7 или Intel Pentium 4 или AMD Opteron) они занимают разное количество ресурсов, в зависимости от архитектуры ЦП.</p>
<p>В общем, проще взять примеры на основе временной сложности — они тоже отлично проиллюстрируют идею оптимизации с учётом затрат. Поговорим немного и о затратах на операции ввода/вывода, это действительно важно - даже важнее процессорных затрат.</p>
<h4 id="Индексы"><a href="#Индексы" class="headerlink" title="Индексы"></a>Индексы</h4><p>Мы говорили об индексах в разделе про B+-деревья. Просто запомните, что эти индексы уже отсортированы. Ещё есть bitmap-индексы, но с точки зрения затрат ресурсов ЦП и памяти они считаются менее эффективными. Также в целях оптимизации многие современные базы данных могут динамически создавать временные индексы только для текущего запроса.</p>
<h4 id="Пути-доступа"><a href="#Пути-доступа" class="headerlink" title="Пути доступа"></a>Пути доступа</h4><p>До выполнения каких-либо операций с данными, их необходимо получить. Сделать это можно следующими способами.</p>
<h5 id="Полное-сканирование"><a href="#Полное-сканирование" class="headerlink" title="Полное сканирование"></a>Полное сканирование</h5><p>Если вы когда-нибудь читали план выполнения запросов, то наверняка видели словосочетание “полное сканирование” (или просто сканирование), когда база данных считывает всю таблицу или индекс. Естественно, полное сканирование таблицы – более затраная операция, чем полное сканирование индекса.</p>
<h5 id="Сканирование-диапазона"><a href="#Сканирование-диапазона" class="headerlink" title="Сканирование диапазона"></a>Сканирование диапазона</h5><p>Например, имея индекс в поле AGE, можно использовать сканирование индексного диапазона - “WHERE AGE &gt; 20 AND AGE &lt;40”.</p>
<p>Как вы помните, в части про B+-деревья мы выяснили, что запрос диапазона занимает log(N)+M времени, где N — количество данных в текущем индексе, а M — предполагаемое количество строк в этом диапазоне (M определяет селективность заданного предиката). Оба значения нам известны благодаря статистике. Сканирование диапазона не считывает весь индекс, что положительно сказывается на стоимости запроса.</p>
<h5 id="Сканирование-уникального-значения"><a href="#Сканирование-уникального-значения" class="headerlink" title="Сканирование уникального значения"></a>Сканирование уникального значения</h5><p>Наиболее выгодное решение, если вам нужно одно конкретное значение в индексе.</p>
<h5 id="Доступ-по-id-строки"><a href="#Доступ-по-id-строки" class="headerlink" title="Доступ по id строки"></a>Доступ по id строки</h5><p>Обычно при использовании индексов, базе данных приходится искать строки, связанные с этими индексами. Поиск этот осуществляется с помощью id строк.</p>
<p>Например, такой запрос:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT LASTNAME, FIRSTNAME from PERSON WHERE AGE = 28</div></pre></td></tr></table></figure>
<p>Если в столбце AGE есть индекс для PERSON, оптимизатор найдёт по индексу всех людей, возраст которых 28 лет, и запросит данные соответствующих строк в таблице, поскольку индекс обладает только информацией про возраст, а нам нужны также имя и фамилия.</p>
<p>Если мы изменим запрос:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> TYPE_PERSON.CATEGORY <span class="keyword">from</span> PERSON ,TYPE_PERSON</div><div class="line"><span class="keyword">WHERE</span> PERSON.AGE = TYPE_PERSON.AGE</div></pre></td></tr></table></figure>
<p>Для объединения с TYPE_PERSON база данных использует индекс PERSON, но id строк в таблице PERSON запрашиваться не будет, поскольку нам не требуется информация из этой таблицы.</p>
<p>К сожалению, поиск id строк довольно затратная операция, поэтому если предполагается много подобных операций, лучше выбрать полное сканирование.</p>
<p>Помимо озвученных путей доступа в разных базах данных существуют и другие. Можете <a href="https://docs.oracle.com/database/121/TGSQL/tgsql_optop.htm#TGSQL228" target="_blank" rel="external">почитать подробнее</a> в документации Oracle, терминология в разных БД может отличаться, но подходы те же.</p>
<h3 id="Операторы-объединения"><a href="#Операторы-объединения" class="headerlink" title="Операторы объединения"></a>Операторы объединения</h3><p>Теперь, зная, как получить данные из БД, давайте объединим их! Рассмотрим три наиболее часто используемых операции объединения: объединение слиянием, хеш-объединение и объединение с помощью вложенных циклов. Но сначала разберёмся с двумя типами логических отношений — внутренним и внешним. Таблицы, индексы или промежуточные результаты от ранее выполненных операций (например результаты предыдущих объединений) могут быть взаимосвязанными. Когда мы объединяем два онтошения, алгоритмы объединения, в зависимотси от типа отношения, ведут себя по-разному. Далее я буду предполагать, что: “внешнее” отношение это находящийся слева набор данных, “внутреннее” отношение - правый набор данных.</p>
<p>Например, A JOIN B это объединение A и B, где A — внешнее отношение, B - внутреннее. Как правило, операции A JOIN B и B JOIN A отличаются по ресурсозатратности. Далее будем считать, что внешнее отношение содержит N элементов, а внутреннее - М элементов. Мы помним, что благодаря статистике оптимизатору БД известны N и M значения; эти значения определяют мощность множеств отношений.</p>
<p>Начнём с наиболее простого</p>
<h5 id="Объединение-с-помощью-вложенных-циклов"><a href="#Объединение-с-помощью-вложенных-циклов" class="headerlink" title="Объединение с помощью вложенных циклов"></a>Объединение с помощью вложенных циклов</h5><p><img src="/blog/images/sql2_2.png" alt="картинка объединения с помощью вложенных циклов"></p>
<p>Суть объединения заключается в том, что для каждой строки внешнего отношения ищутся совпадения по всем строкам внутреннего отношения.</p>
<p>Происходит это примерно так:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">nested_loop_join(array outer, array inner)</div><div class="line">for each row a in outer</div><div class="line">for each row b in inner</div><div class="line">if (match_join_condition(a,b))</div><div class="line">write_result_in_output(a,b)</div><div class="line"><span class="keyword">end</span> <span class="keyword">if</span></div><div class="line"><span class="keyword">end</span> <span class="keyword">for</span></div><div class="line"><span class="keyword">end</span> <span class="keyword">for</span></div></pre></td></tr></table></figure>
<p>Из-за двойной итерации временная сложность составляет O(N<em>M). С точки зрения операций ввода/вывода, для каждой из N строк внешнего отношения внутренний цикл должен считать M строк внутреннего отношения. То есть этот алгоритм считывает с диска Н + Н</em>М строк. Если внутреннее отношение невелико, можно поместить его в память и считать лишь М + Н строк. Поэтому, чтобы поместиться в памяти, именно внутреннее отношение должно быть наименьшим.</p>
<p>В плане временной сложности нет никакой разницы, но для сокращения операций ввода/вывода оптимальнее считывать отношения только один раз. Также внутреннее отношение можно заменить на индекс, что лучше скажется на производительности.<br>Другой вариант данного объединения в случае, если внутреннее отношение не помещается в памяти, может быть таким: вместо считывания отношений построчно, вы считываете их группами строк, сохраняете в памяти 2 группы (по одной для каждого отношения), далее сравниваете строки в этих группах и сохраняете совпадения, затем загружаете новые группы и также сравниваете их, и так далее до конца.<br>Псевдокод этого объединения выглядит так:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// улучшенная версия алгоритма для оптимизации затрат</div><div class="line">nested_loop_join_v2(file outer, file inner)</div><div class="line">for each bunch ba in outer</div><div class="line">// ba сохранён в памяти</div><div class="line">for each bunch bb in inner</div><div class="line">// bb сохранён в памяти</div><div class="line">for each row a in ba</div><div class="line">for each row b in bb</div><div class="line">if (match_join_condition(a,b))</div><div class="line">write_result_in_output(a,b)</div><div class="line"><span class="keyword">end</span> <span class="keyword">if</span></div><div class="line"><span class="keyword">end</span> <span class="keyword">for</span></div><div class="line"><span class="keyword">end</span> <span class="keyword">for</span></div><div class="line"><span class="keyword">end</span> <span class="keyword">for</span></div><div class="line"><span class="keyword">end</span> <span class="keyword">for</span></div></pre></td></tr></table></figure>
<p>В таком варианте временная сложность не изменяется, зато уменьшается количество обращений к диску. В первом варианте рассматриваемого алгоритма количество обращений составляло Н + Н<em>М раз (по одному обращению на каждую строку). В улучшенной версии число обращений к диску составит количество<em>групп</em>(внешнего отношения) + количество<em>групп</em>(внешнего отношения) </em> количество<em>групп</em>(внутреннего отношения). Увеличение размера групп строк позволит ещё больше сократить количество обращений к диску.</p>
<p>Стоит отметить, что с каждым обращением к диску считывается всё больший объём данных, но это не так важно, поскольку обращения последовательные (и наиболее критичным является время, необходимое для считывания первого набора данных).</p>
<h5 id="Хеш-объединение"><a href="#Хеш-объединение" class="headerlink" title="Хеш-объединение"></a>Хеш-объединение</h5><p><img src="/blog/images/sql2_3.png" alt="картинка хеш-объединения"></p>
<p>Хеш-объединение состоит из следующих шагов:</p>
<ol>
<li>считать все элементы внутреннего отношения;</li>
<li>создать в памяти хеш-таблицу;</li>
<li>последовательно считать все элементы внешнего отношения;</li>
<li>с помощью функции хеш-таблицы вычислить хеш для каждого элемента и найти соответствующий ему сегмент внутреннего отношения;</li>
<li>найти совпадения между элементами данного сегмента и элементом внешнего отношения.</li>
</ol>
<p>Для упрощения вычисления временной сложности этого алгоритма, будем считать что: </p>
<ul>
<li>внутреннее отношение делится на Х сегментов; </li>
<li>хеш-функция равномерно распределяет хеш-значения для обоих отношений (то есть все сегменты одного размера); </li>
<li>стоимость вычисления совпадения между элементом внешнего отношения и всеми элементами в сегменте пропорциональна количеству элементов в сегменте.</li>
</ul>
<p>Таким образом, временную сложность можно вычислить так: (M/X) <em> N + стоимость<em>создания</em>хеш-таблицы(M) + стоимость_хеш-функции</em>N.<br>Если хеш-функция будет создавать небольшие по размеру сегменты, временная сложность составит O(M+N).</p>
<p>Есть еще один вариант хеш-соединения, который меньше загружает память, но более затратен с точки зрения операций ввода/вывода. Он состоит из следующих шагов:</p>
<ol>
<li>создать хеш-таблицы для внутреннего и для внешнего отношений;</li>
<li>поместить их на диск;</li>
<li>сравнить отношения сегмент за сегментом (один сегмент загружается в оперативную память, а второй считывается построчно).</li>
</ol>
<h5 id="Объединение-слиянием"><a href="#Объединение-слиянием" class="headerlink" title="Объединение слиянием"></a>Объединение слиянием</h5><h6 id="Объединение-слиянием-единственное-объединение-которое-выдаёт-отсортированный-результат"><a href="#Объединение-слиянием-единственное-объединение-которое-выдаёт-отсортированный-результат" class="headerlink" title="Объединение слиянием - единственное объединение, которое выдаёт отсортированный результат."></a>Объединение слиянием - единственное объединение, которое выдаёт отсортированный результат.</h6><p>В нашем упрощенном примере не будет разделения на внутренние и внешние таблицы, но в реальных, более сложных, примерах, алгоритм будет вести себя иначе, например при обнаружении дубликатов.</p>
<p>Объединение слиянием состоит из двух шагов:</p>
<ol>
<li>(опционально) сортировка входных данных: данные сортируются по ключу объединения;</li>
<li>непосредственно слияние: отсортированные данные объединяются.</li>
</ol>
<h6 id="Сортировка"><a href="#Сортировка" class="headerlink" title="Сортировка"></a>Сортировка</h6><p>Мы уже говорили о cортировке методом слияния, в данном случае это сортировка слиянием в хорошем алгоритме (не лучшем, но хорошем — в ситуациях, когда нам важно экономить память).</p>
<p>Иногда входные данные отсортированы заранее, например, если таблица изначально сортируется по индексу условия объединения, или объединение применяется к промежуточному результату, ранее отсортированному в процессе запроса.</p>
<h6 id="Объединение-слиянием-1"><a href="#Объединение-слиянием-1" class="headerlink" title="Объединение слиянием"></a>Объединение слиянием</h6><p><img src="/blog/images/sql2_4.png" alt="схема объединения слиянием"></p>
<p>Этот этап очень похож на процесс слияния в рассмотренной нами ранее cортировке методом слияния. Но на этот раз выводится не каждый элемент из обоих отношений, а лишь совпадающие элементы.<br>Как это происходит:</p>
<ol>
<li>сравниваем два текущих элемента двух отношений (текущий = первый, анализируемый впервые);</li>
<li>если они равны, то помещаются в результат вычисления, и процесс продолжается, перейдя на следующий элемент в каждом отношении;</li>
<li>если элементы не равны, алгоритм переходит в отношение с наименьшим элементом и берёт следующий элемент;</li>
<li>повторяем действия 1-2-3, пока не достигнем последнего элемента в одном из отношений.</li>
</ol>
<p>Оба массива изначально отсортированы, поэтому не приходится “возвращаться” в них. Временная сложность составит O(M+N).<br>Если оба отношения изначально не отсортированы, тогда временная сложность пропорциональна затратам на сортировку обоих отношений: O(N<em>Log(N) + M</em>Log(M)).</p>
<p>Это упрощенная версия алгоритма, потому что у нас нет дубликатов, когда одни и те же данные несколько раз появляется в обоих массивах (соответственно, предполагая несколько совпадений). Если вы гуру алгоритмов и хотите взглянуть на более сложную версию, вот возможный алгоритм, обрабатывающий дубликаты:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">mergeJoin(relation a, relation b)</div><div class="line">relation output</div><div class="line">integer a_key:=0;</div><div class="line">integer b_key:=0;</div><div class="line">while (a[a_key]!=null and b[b_key]!=null)</div><div class="line">if (a[a_key] &lt; b[b_key]) a_key++; else if (a[a_key] &gt; b[b_key])</div><div class="line">b_key++;</div><div class="line">else //предикат объединения выводит результат</div><div class="line">write_result_in_output(a[a_key],b[b_key])</div><div class="line">//Мы должны с осторожностью увеличивать указатели</div><div class="line">integer a_key_temp:=a_key;</div><div class="line">integer b_key_temp:=b_key;</div><div class="line">if (a[a_key+1] != b[b_key])</div><div class="line">b_key_temp:= b_key + 1;</div><div class="line">end if</div><div class="line">if (b[b_key+1] != a[a_key])</div><div class="line">a_key_temp:= a_key + 1;</div><div class="line">end if</div><div class="line">if (b[b_key+1] == a[a_key] &amp;&amp; b[b_key] == a[a_key+1])</div><div class="line">a_key_temp:= a_key + 1;</div><div class="line">b_key_temp:= b_key + 1;</div><div class="line">end if</div><div class="line">a_key:= a_key_temp;</div><div class="line">b_key:= b_key_temp;</div><div class="line">end if</div><div class="line">end while</div></pre></td></tr></table></figure>
<h5 id="Какой-алгоритм-объединения-лучше"><a href="#Какой-алгоритм-объединения-лучше" class="headerlink" title="Какой алгоритм объединения лучше?"></a>Какой алгоритм объединения лучше?</h5><p>Если бы существовал «лучший» алгоритм объединения, не было бы всех остальных вариаций. Выбор зависит от множества факторов, например:</p>
<ul>
<li>объем свободной памяти: если у вас не достаточно памяти, можете даже не думать о хеш-объединении (по крайней мере его полном варианте с помещением хеш-таблицы в память);</li>
<li>размер входных данных: например, если у вас одна таблица большая, а вторая очень маленькая, объединение вложенными циклами будет быстрее, чем хеш-объединение, в котором процесс вычисления хешей довольно затратен; в то же время если у вас обе таблицы очень большие, объединение вложенными циклами будет крайне затратным для ЦП;</li>
<li>наличие индексов:работая с индексами двух В+-деревьев наиболее логичным выбором будет объединение слиянием;</li>
<li>необходимость выполнить объединение в несколько процессов/потоков;</li>
<li>необходимость сортировки результатов: даже работая с несортированными входными данными, вы, возможно, предпочтёте выбрать затратное объединение слиянием (с сортировкой), чтобы в итоге получить отсортированный результат, который можно соединить с результатами другого объединения слиянием (или просто потому что запрос через операции вроде ORDER BY/GROUP BY/DISTINCT предполагает отсортированные результаты);</li>
<li>заранее отсортированные входные данные: в этом случае всё просто — выбирайте объединение слиянием;</li>
<li>тип объединяемых отношений: это могут быть внешние или внутренние отношения, объединение по эквивалентности отношений (например, tableA.col1 = tableB.col2), декартово произведение и так далее. Некоторые алгоритмы объединений не работают с определёнными типами отношений;</li>
<li>распределение данных: если данные для условия объединения несимметричны (например, вы объединяете людей по фамилии, но в таблице много однофамильцев), нельзя использовать хеш-объединение, потому что в таком случае хеш-функция создаст плохо распределённые сегменты.</li>
</ul>
<p>Как обычно, для более глубокого ознакомления с темой отсылаю вас к документации <a href="https://www-01.ibm.com/support/knowledgecenter/SSEPGG_9.7.0/com.ibm.db2.luw.admin.perf.doc/doc/c0005311.html" target="_blank" rel="external">DB2</a>, <a href="http://docs.oracle.com/cd/B28359_01/server.111/b28274/optimops.htm#i76330" target="_blank" rel="external">ORACLE</a> или <a href="https://technet.microsoft.com/en-us/library/ms191426%28v=sql.105%29.aspx" target="_blank" rel="external">SQL Server</a>.</p>
<h4 id="Упрощённый-процесс-выбора-вида-объединения"><a href="#Упрощённый-процесс-выбора-вида-объединения" class="headerlink" title="Упрощённый процесс выбора вида объединения"></a>Упрощённый процесс выбора вида объединения</h4><p>Итак, мы рассмотрели три вида операций объединения.</p>
<p>Теперь возьмём такой пример: предположим, нам необходимо объединить 5 таблиц, чтобы иметь полное представление о человеке. У человека (PERSON) может быть несколько мобильных номеров (MOBILES), почт (MAILS), адресов (ADDRESSES), банковских аккаунтов. (BANK_ACCOUNTS). И нам нужен быстрый результат на такой запрос:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> PERSON, MOBILES, MAILS,ADRESSES, BANK_ACCOUNTS</div><div class="line"><span class="keyword">WHERE</span></div><div class="line">PERSON.PERSON_ID = MOBILES.PERSON_ID</div><div class="line"><span class="keyword">AND</span> PERSON.PERSON_ID = MAILS.PERSON_ID</div><div class="line"><span class="keyword">AND</span> PERSON.PERSON_ID = ADRESSES.PERSON_ID</div><div class="line"><span class="keyword">AND</span> PERSON.PERSON_ID = BANK_ACCOUNTS.PERSON_ID</div></pre></td></tr></table></figure>
<p>Оптимизатор должен найти наиболее оптимальный способ обработки данных.<br>Перед ним встаёт два вопроса:</p>
<ul>
<li>Какой вид объединения их трёх (хеш-объединение, объединение слиянием, объединение вложенными циклами) использовать? И какие индексы - 0,1 или 2 (не говоря уже о том, что существуют различные типы индексов).</li>
<li>В каком порядке выполнять цепочку объединений? Например, на рисунке ниже показаны разные возможные планы выполнения трёх объединений 4 таблиц:</li>
</ul>
<p><img src="/blog/images/sql2_5.png" alt="рисунок возможных планов объединений"></p>
<p>У оптимизатора есть следующие опции:</p>
<ol>
<li>Брутфорс: Используя статистику базы данных, вычислить затраты для каждого возможного плана слияния и выбрать наилучший. Но здесть есть много вариантов. В заданной последовательности объединений каждое объединение может быть любым из трёх типов (хеш-объединение, объединение слиянием, объединение вложенными циклами). То есть для заданной последовательности объединений есть 34 возможных планов слияния. Выбор самой последовательности это по сути <a href="https://en.wikipedia.org/wiki/Catalan_number" target="_blank" rel="external">задача о перестановках</a> и существует (2<em>4)!/(4+1)! возможных варианта. Таким образом, для решения этого простого примера оптимизатор должен выбрать из 34</em>(2*4)!/(4+1)! или 27 216 возможных планов слияния. Если добавим в пример использование 0,1 или 2 индексов B+-деревьев, количество возможных планов слияния возрастёт до 210 000. И это, повторюсь, очень простой запрос.</li>
<li>Сразу сдаться и не выполнить запрос. Решение для слабаков;</li>
<li>Оценить лишь несколько планов слияния и выбрать наименее затратный. То есть вместо вычисления затрат на каждый возможный вариант, выбрать произвольное количество из всех возможных планов, оценить их стоимость и выбрать лучший из рассмотренных план слияния;</li>
<li>Применить «умные» условия, чтобы уменьшить количество возможных планов слияния. Есть 2 типа условий:<br>a. Можно использовать «логические» условия, они исключат ненужные варианты, но не сильно уменьшат колитество возможных планов. Пример такого условия: «внутреннее отношение при объединении вложенными циклами должно быть наименьшим набором данных»<br>b. Можно отказаться от поиска наилучшего решения и удовлетвориться просто хорошим, применив более жёсткие условия, чтобы существенно уменьшить количество возможных планов слияния. Например: «если отношение небольшого размера, использовать объединение вложенными циклами, и никогда не использовать объединение слиянием или хеш-объединение».</li>
</ol>
<p>В одном простом примере у оптимизатора так много возможных вариантов. А в реальных запросах могут быть и другие операторы отношений: OUTER JOIN, CROSS JOIN, GROUP BY, ORDER BY, PROJECTION, UNION, INTERSECT, DISTINCT. </p>
<p>Как же база данных со всем этим справляется?</p>
<h4 id="Динамическое-программирование-жадный-алгоритм-и-эвристика"><a href="#Динамическое-программирование-жадный-алгоритм-и-эвристика" class="headerlink" title="Динамическое программирование, жадный алгоритм и эвристика"></a>Динамическое программирование, жадный алгоритм и эвристика</h4><p>Чтобы сделать правильный выбор, реляционная база данных пробует все вышеперечисленные подходы. Реальная задача оптимизатора заключается в том, чтобы найти эффективное решение за ограниченное количество времени. В большинстве случаев оптимизатор находит не «лучшее» решение, а «достаточно хорошее». Брутфорс-подход годится для небольших запросов. Но если использовать один полезный подход, избежав тем самым лишних вычислений, то можно применять брутфорс и для запросов средней величины. Этот полезный подход называется динамическое программирование.</p>
<h5 id="Динамическое-программирование"><a href="#Динамическое-программирование" class="headerlink" title="Динамическое программирование"></a>Динамическое программирование</h5><p>Основная идея, лежащая в основе динамического программирования, заключается в том, что многие планы выполнения запросов очень похожи. </p>
<p>Взгляните на рисунок ниже:</p>
<p><img src="/blog/images/sql2_6.png" alt="рисунок планов выполнения запросов"></p>
<p>У всех представленных на рисунке планов есть общее поддерево A JOIN B. Поэтому, вместо вычисления стоимости затрат на выполнение этого поддерева в каждом плане, мы можем вычислить его один раз, сохранить полученное значение и использовать его каждый раз, когда встречается данное поддерево. Выражаясь формально, мы решаем проблему перекрытия. Чтобы избежать повторных вычислений, мы используем <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D0%BC%D0%BE%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F" target="_blank" rel="external">мемоизацию</a>. Применив такой подход, вместо (2^N)!/(N+1)! временной сложности получаем сложность 3N. В нашем предыдущем примере с 4 объединениями, это бы означало уменьшить количество возможных планов выполнения с 336 до 81. Если взять запрос посложнее с 8 объединениями, такой подход уменьшит количество вариантов с 57 657 600 до 6561.</p>
<p>Для гуру алгоритмов, приведу пример, но объяснять его не буду — это пример для знатоков динамического программирования:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">procedure findbestplan(S)</div><div class="line">if (bestplan[S].cost infinite)</div><div class="line">   return bestplan[S]</div><div class="line">// если bestplan[S] не был вычислен ранее, вычисляем сейчас</div><div class="line">if (S contains only 1 relation)</div><div class="line">         <span class="keyword">set</span> bestplan[S].plan <span class="keyword">and</span> bestplan[S].cost based <span class="keyword">on</span> the best way</div><div class="line">         <span class="keyword">of</span> accessing S  <span class="comment">/* Using selections on S and indices on S */</span></div><div class="line">     <span class="keyword">else</span> <span class="keyword">for</span> <span class="keyword">each</span> non-<span class="keyword">empty</span> subset S1 <span class="keyword">of</span> S such that S1 != S</div><div class="line">   P1= findbestplan(S1)</div><div class="line">   P2= findbestplan(S - S1)</div><div class="line">   A = best algorithm <span class="keyword">for</span> joining results <span class="keyword">of</span> P1 <span class="keyword">and</span> P2</div><div class="line">   <span class="keyword">cost</span> = P1.cost + P2.cost + <span class="keyword">cost</span> <span class="keyword">of</span> A</div><div class="line">   <span class="keyword">if</span> <span class="keyword">cost</span> &lt; bestplan[S].cost</div><div class="line">       bestplan[S].cost = <span class="keyword">cost</span></div><div class="line">      bestplan[S].plan = “<span class="keyword">execute</span> P1.plan; <span class="keyword">execute</span> P2.plan;</div><div class="line">                 join results of P1 and P2 using A”</div><div class="line">return bestplan[S]</div></pre></td></tr></table></figure>
<p>Динамическое программирование можно использовать и для больших запросов, но с дополнительными условиями (эвристикой), для уменьшения количества вариантов, например:</p>
<ul>
<li>анализировать только конкрентый план, например, дерево с движением по левым ветвям, тем самым изменив временную сложность с 3^n на n*2^n </li>
</ul>
<p><img src="/blog/images/sql2_7.png" alt="рисунок четырёх планов выполнения"></p>
<ul>
<li>добавить логические условия (например, «если таблица является индексом для данного предиката, применять объединение слиянием только к индексу, а не к таблице»); это сократит количество возможных вариантов, не исключая при этом наиболее эффективные решения.</li>
<li>добавить правило для всего потока процессов (например, «выполнить операции объединения ДО всех остальных операций»), что тоже заметно сократит количество планов выполнения.</li>
</ul>
<h5 id="Жадные-алгоритмы"><a href="#Жадные-алгоритмы" class="headerlink" title="Жадные алгоритмы"></a>Жадные алгоритмы</h5><p>Этот тип алгоритмов используют для очень больших запросов или когда нужно быстро получить ответ (на не очень быстрый запрос). Смысл такого алгоритма в том, чтобы выстраивать план выполнения запроса поэтапно, соблюдая определённые правила (эвристику). Алгоритм начинает  план выполнения с одного объединения. Затем, на каждом последующем этапе, опираясь на то же заданное правило, алгоритм добавляет новое объединение к плану. </p>
<p>Рассмотрим несложный пример. Допустим, у нас есть запрос с 4 объединениями 5 таблиц (А, B, С, D, Е). Для упрощения задачи сразу выберем объединение вложенными циклами как единственное возможное объединение. </p>
<p>Давайте зададим правило «выполнять объединение с наименьшими затратами»:</p>
<ul>
<li>начинаем с одной из таблиц, например, с А;</li>
<li>вычисляем стоимость каждого объединения с A (где A - либо внутреннее, либо внешнее отношение);</li>
<li>устанавливаем, что A JOIN B — наименее затратное объединение;</li>
<li>затем вычисляем стоимость каждого объединения с результатом  A JOIN B (где A JOIN B - либо внутреннее, либо внешнее отношение);</li>
<li>устанавливаем, что (A JOIN B) JOIN C -  наименее затратное объединение;</li>
<li>далее  вычисляем стоимость каждого объединения с результатом (A JOIN B) JOIN C;</li>
<li>и так далее…;</li>
<li>в результате получаем план выполнения вида (((A JOIN B) JOIN C) JOIN D) JOIN E). </li>
</ul>
<p>Поскольку мы произвольно начали с таблицы A, точно также можно применить этот алгоритм, начав с таблицы B, затем с C, с D и с E. И из полученных результатов выбрать план выполнения с наименьшими затратами.</p>
<p>Кстати, у данного алгоритма, который я назвал «жадным», есть и более благозвучное название - <a href="https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%B1%D0%BB%D0%B8%D0%B6%D0%B0%D0%B9%D1%88%D0%B5%D0%B3%D0%BE_%D1%81%D0%BE%D1%81%D0%B5%D0%B4%D0%B0_%D0%B2_%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B5_%D0%BA%D0%BE%D0%BC%D0%BC%D0%B8%D0%B2%D0%BE%D1%8F%D0%B6%D1%91%D1%80%D0%B0" target="_blank" rel="external">«алгоритм ближайшего соседа»</a>.</p>
<p>Не вдаваясь в дальнейшие подробности, применив сортировку N<em>log(N), наш пример может быть <a href="http://www.cs.bu.edu/~steng/teaching/Spring2004/lectures/lecture3.ppt" target="_blank" rel="external">решён</a>. Стоимость данного алгоритма составляет O(N</em>log(N)) или O(3N) в полностью «динамическом» его варианте. Таким образом, имея большой запрос из 20 объединений и применив этот алгоритм, мы получим всего 26 вариантов вместо 3 486 784 401 — огромная разница!</p>
<p>Проблема этого алгоритма в следующем: мы предполагаем, что найдя наилучшее объединение 2 таблиц, мы получим наиболее эффективный вариант, добавив к найденному объединению новое объединение. Однако, даже если A JOIN B даёт наиболее оптимальный по стоимости план объединения A, B и C, комбинация (A JOIN C) JOIN B может оказаться эффективнее, чем (A JOIN B) JOIN C. Поэтому для улучшения результата можно прогнать несколько жадных алгоритмов, установив разные правила, и по результатам выбрать самый оптимальный план.</p>
<h5 id="Другие-алгоритмы-объединения"><a href="#Другие-алгоритмы-объединения" class="headerlink" title="Другие алгоритмы объединения"></a>Другие алгоритмы объединения</h5><p><strong>[Если алгоритмы уже сидят у вас в печёнках, переходите к следующему разделу: этот подраздел не так важен]</strong>.<br>На самом деле, проблема поиска наилучшего плана выполнения — актуальная тема многих научных исследований. Обычно цель - найти наиболее эффективные решения для конкретных задач и внедрить их в БД. Например,</p>
<ul>
<li>в случае звездообразного объединения (это определенный тип запроса со множеством объединений), некоторые базы данных используют определенный, считающийся наилучшим, алгоритм.</li>
<li>в случае параллельных запросов некоторые базы данных используют другой определенный алгоритм, и так далее.</li>
</ul>
<p>Для замены динамического программирования в больших запросах, в данный момент изучаются разные алгоритмы. Жадные алгоритмы принадлежат к большой семье алгоритмов, называемых эвристическими алгоритмами. Как вы помните, жадный алгоритм следует определённому заданному правилу (эвристике), сохраняет результат, найденный на первом этапе, и переиспользует его для вычисления результатов последующих этапов. Некоторые алгоритмы соледуют заданному правилу, применяя его на каждом этапе, но не всегда запоминают наилучшее решение, найденное на предыдущем этапе. Они называются эвристическими алгоритмами.<br>Пример таких алгоритмов - генетические алгоритмы, в которых каждое найденное решение является возможным планом полного выполнения запроса, и вместо одного решения (т. е. плана), алгоритм находит P решений на каждом этапе вычислений:</p>
<ol>
<li>сначала случайным образом создаётся Р количество планов;</li>
<li>сохраняются только планы с наименьшими затратами;</li>
<li>эти планы смешиваются и образуют новое P количество планов;</li>
<li>некоторые из новообразованных планов произвольно изменяются;</li>
<li>этапы 1-2-3 повторяются T количество раз;</li>
<li>и в конце сохраняется лучший план из P планов последнего цикла.</li>
</ol>
<p>Таким образом, чем больше циклов проходит этот алгоритм, тем лучше результат.</p>
<p>Магия? Нет, законы природы: выживает только сильнейший!<br>Между прочим, генетические алгоритмы реализованы в <a href="http://www.postgresql.org/docs/9.4/static/geqo-intro.html" target="_blank" rel="external">PostgreSQL</a>, но я не смог выяснить, используются ли они по умолчанию.</p>
<p>Существуют и другие эвристические алгоритмы, используемые в базах данных, например, симмулированная нормалиазция (Simulated Annealing), итеративное улучшение (Iterative Improvement), двухфазная оптимизация (Two-Phase Optimization). Но у меня нет информации, используют ли их уже в реальных БД, или пока только в экспериментлаьных базах данных.</p>
<h4 id="Настоящие-оптимизаторы"><a href="#Настоящие-оптимизаторы" class="headerlink" title="Настоящие оптимизаторы"></a>Настоящие оптимизаторы</h4><p>Но хватит теории. Мы программисты, а не исследователи, так давайте взглянем на реальные реализации.</p>
<p>Посмотрим, как работает <a href="https://www.sqlite.org/optoverview.html" target="_blank" rel="external">SQLite оптимизатор</a>.<br>Это облегчённая база данных, поэтому она использует простую оптимизацию на основе жадного алгоритма с определёнными правилами для сокращения количества вариантов:</p>
<ul>
<li>SQLite ни когда не меняет порядок таблиц в перекрестном объединении (CROSS JOIN);</li>
<li>SQLite использует объединение вложенными циклами;</li>
<li>внешние отношения вычисляются в порядке их следования;</li>
<li>в версиях до 3.8.0 для поиска наиболее оптимального плана выполнения запроса SQLite использует «алгоритм ближайшего соседа»,</li>
<li>начиная с версии 3.8.0, выпущенной в 2015 году, используется алгоритм <a href="https://www.sqlite.org/queryplanner-ng.html" target="_blank" rel="external">«N ближайших соседей»</a>.</li>
</ul>
<p>Давайте взглянем на другой оптимизатор от IBM – DB2 – он работает аналогично другим решениям в корпоративных базах данных, я выбрал его в качестве примера, поскольку до начала работы с большими данными использовал именно его.</p>
<p>Из <a href="https://www-01.ibm.com/support/knowledgecenter/SSEPGG_9.7.0/com.ibm.db2.luw.admin.perf.doc/doc/r0005278.html" target="_blank" rel="external">официальной документации</a>, мы узнаем, что DB2 оптимизатор позволяет применять 7 различных уровней оптимизации:</p>
<ul>
<li>возможность использования жадных алгоритмов для объединений:</li>
</ul>
<ol>
<li>с минимальной оптимизацией, используя сканирование индексов и объединение вложенными циклами, избегая переписывания части запросов,</li>
<li>с частичной оптимизацией;</li>
<li>с полной оптимизацией;</li>
</ol>
<ul>
<li>возможность использования динамического программирования для объединений:</li>
</ul>
<ol>
<li>с умеренной оптимизацией и грубым приближением;</li>
<li>с полной оптимизацией, используя различные эвристические алгоритмы;</li>
<li>с полной оптимизацией, но без эвристики;</li>
<li>с максимальной оптимизацией без учёта ресурсозатрат и вычислением всех возможных последовательностей объединения, включая декартовы произведения.</li>
</ol>
<p>Как видите, DB2 использует как эвристические алгоритмы, так и динамическое программирование. Конечно, вы не найдёте деталей реализации эвристики DB2, такие вещи держатся в секрете, ведь оптимизатор — важнейшая составляющая любой БД.</p>
<p>К слову, по умолчанию выбрана опция номер 5, когда оптимизатор использует следующие характеристики:</p>
<ul>
<li>использовать все возможные статистические данные, включая частотные распределения и квантили;</li>
<li>применять все правила перезаписи запросов (в том числе таблицы маршрутизации материализованных запросов), за исключением ресурсозатратных правил, которые применяются в очень редких случаях;</li>
<li>при динамическом переборе объединений ограниченно использовать составные внутренние отношения и декартовы произведения для звездообразных схем с таблицами подстановки;</li>
<li>предоставлять большой выбор путей доступа, в том числе выборку предварительного списка (далее поговорим об этом подробнее), специальную операцию AND для индексов и таблицы маршрутизации материализованных запросов.</li>
</ul>
<p>Остальные условия (GROUP BY, DISTINCT) обрабатываются простыми правилами.</p>
<h4 id="Кэш-плана-запросов"><a href="#Кэш-плана-запросов" class="headerlink" title="Кэш плана запросов"></a>Кэш плана запросов</h4><p>Поскольку создание плана требует времени, большинство баз данных сохраняют план в кэше во избежание повторных вычислений одного и того же плана. Это в общем непростая задача, поскольку база данных должна знать, когда обновить устаревшие планы. Поэтому устанавливается некий предел, и когда количество изменений в статистических данных таблицы превышает этот предел, план запроса, связанный с этой таблицей, удаляется из кэша.</p>
<h3 id="Диспетчер-запросов"><a href="#Диспетчер-запросов" class="headerlink" title="Диспетчер запросов"></a>Диспетчер запросов</h3><p>Наконец, мы вычислили оптимальный план выполнения запросов. Этот план компилируется в исполняемый код и, если ресурсов памяти и процессора достаточно, выполняется диспетчером запросов. Различные операторы (JOIN, SORT BY ) выпоняются последовательно или параллельно – это решает диспетчер. Для получения и записи данных диспетчер запросов взаимодействует с диспетчером данных, и именно о нём мы подробно поговорим в следующей части статьи.</p>
<p>По мотивам <a href="http://coding-geek.com/how-databases-work/" target="_blank" rel="external">Christophe</a></p>
<p>To be continued…</p>
<p>Читайте так же статьи по теме:</p>
<ul>
<li><a href="https://makeomatic.ru/blog/2015/10/02/relational_database_1/">Как работает реляционная база данных. Часть 1</a></li>
<li><a href="https://makeomatic.ru/blog/2015/11/24/relational_database_3/">Как работает реляционная база данных. Часть 3</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Статистика&quot;&gt;&lt;a href=&quot;#Статистика&quot; class=&quot;headerlink&quot; title=&quot;Статистика&quot;&gt;&lt;/a&gt;Статистика&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/blog/images/sql2_main.png&quot; alt=&quot;картинка main&quot;&gt;&lt;/p&gt;
&lt;p&gt;Прежде чем разбираться, как база данных оптимизирует запросы, давайте поговорим о статистике, потому что без неё любая база данных будет неэффективной. Если БД не анализирует собственные данные, её действия будут крайне неразумны. Какая же информация нужна БД для анализа?&lt;/p&gt;
    
    </summary>
    
    
      <category term="SQL" scheme="https://makeomatic.ru/blog/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Как работает реляционная база данных</title>
    <link href="https://makeomatic.ru/blog/2015/10/02/relational_database_1/"/>
    <id>https://makeomatic.ru/blog/2015/10/02/relational_database_1/</id>
    <published>2015-10-02T07:00:00.000Z</published>
    <updated>2016-01-08T17:55:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/images/sql_main.jpg" alt="картинка с логотипами различных баз данных"></p>
<p>Когда речь заходит о реляционных базах данных, становится очевидно, что информации по этой теме не хватает. Базы данных используются повсеместно, и они очень разные - от небольшой, но функциональной SQLite до мощной Teradata. И тем не менее, достойных, подробных статей, объясняющих как они работают, практически нет.</p>
<a id="more"></a>
<p>Можете погуглить “как работают реляционные базы данных”, и увидите, как мало результатов поиска. Да и те статьи, что есть, довольно короткие. Если же погуглить что-нибудь из последних трендов (большие данные, базы данных типа NoSQL или JavaScript), вы найдете в разы больше хороших источников информации.<br>Значит ли это, что реляционные базы данных устарели, и писать о них вне университетских курсов и научных статей уже не модно?</p>
<p><img src="/blog/images/sql_1.png" alt="картинка с логотипами различных баз данных"></p>
<p>Я разработчик и ненавижу использовать то, чего не понимаю. Раз базы данных используются в разработке вот уже 40 лет, значит, на то есть весомая причина. За эти годы я потратил сотни часов, чтобы понять эти странные ящики пандоры, которые использую каждый день. На самом деле, реляционная база данных – интересная концепция, основанная на полезных, повторяющихся идеях. Если вы всегда хотели углубить ваши знания и понимание баз данных, но не хватало времени или желания разбираться в столь обширной теме, эта статья вам понравится.</p>
<p>Хотя название говорит само за себя, уточню: для понимания данной статьи вам необходимо знать, как написать простой запрос на соединение и базовый CRUD запрос. Только и всего. Всё остальное я объясню.</p>
<p>Начну с таких основ информатики, как временная сложность алгоритма. Наверное, многие из вас эту тему терпеть не могут, но без неё вы не сможете понять всю гениальность баз данных. Поскольку тема большая, я сосредоточусь на том, что считаю наиболее важным: как база данных обрабатывает SQL-запрос. Мы рассмотрим самые простые концепции, так что к концу статьи у вас должно сложиться полное представление о том, что такое БД.</p>
<p>Статья техническая и длинная, в ней много говорится про алгоритмы и структуры данных - не торопитесь дочитать до конца. Какие-то моменты сложнее понять, и пропуская их при первом прочтении, у вас всё равно должна сложиться полноценная картина.</p>
<p>Статья условно разделена на три части:</p>
<ul>
<li>Обзор низкоуровневых и высокоуровневых компонентов БД;</li>
<li>Разбор процесса оптимизации запросов;</li>
<li>Управление транзакциями и буферным пулом БД.</li>
</ul>
<h3 id="Начнём-с-азов"><a href="#Начнём-с-азов" class="headerlink" title="Начнём с азов"></a>Начнём с азов</h3><p>Давным-давно (в другой галактике…) разработчикам приходилось запоминать количество совершаемых операций. Они знали наизусть свои алгоритмы и структуры данных, поскольку не могли позволить себе тратить память и мощности своих довольно медленных компьютеров на подобные задачи.</p>
<p>В этой части, я буду напоминать вам о некоторых концепциях из тех далёких времён, поскольку они крайне важны для понимания баз данных. Также мы рассмотрим понятие <code>индекс базы данных</code>.</p>
<h4 id="Временная-сложность"><a href="#Временная-сложность" class="headerlink" title="Временная сложность"></a>Временная сложность</h4><p>O(1)) vs O(n^2)<br>Сегодня временная сложность алгоритмов не волнует почти никаких разработчиков. Но когда вы начинаете работать с большим объемом данных, или если вам приходится бороться за каждую лишнюю миллисекунду - при работе с базами данных вы рано или поздно столкнётесь и с тем, и с другим, - понимание данной концепции становится очень полезным. Не буду слишком долго утомлять вас разглагольствованиями, только о главном - это поможет нам впоследствии понять принцип оптимизации с учётом затрат.</p>
<p>Временная сложность определяет, сколько времени алгоритм будет обрабатывать конкретный объем данных. Для математического обозначения используется заглавная О и функция, вычисляющая, сколько операций необходимо алгоритму для заданного количества данных.</p>
<p>Проще говоря, формула вида <code>O(некая_функция())</code> расшифровывается так: для определённого количества данных алгоритму требуется <code>некая_функция(количество_данных)</code> операций.</p>
<p>И важно здесь не количество входных данных, а то, как увеличивается количество необходимых операций с увеличением количества данных. Временная сложность не расчитывает точное число операций, но даёт довольно чёткое представление.</p>
<p><img src="/blog/images/sql_2.png" alt="иллюстрация графика временной сложности"></p>
<p>На этом графике вы видите разные временные сложности. Для его создания я использовал логарифмическую шкалу - количество данных резко возрастает от 1 до 1 миллиарда. </p>
<p>Мы видим, что:</p>
<ul>
<li>Значение О (1) остается неизменным (поэтому она называется постоянной сложностью);</li>
<li>Значение О (log(n)) остаётся маленьким даже при больших объёмах данных;</li>
<li>Хуже всего показатель сложности О (n^2), где количество необходимых операций быстро<br>возрастает;</li>
<li>Значения двух оставшихся кривых также быстро растут.</li>
</ul>
<p>Разберём примеры подробнее:</p>
<p>При небольшом объёме данных разницы между О(1) и O(n^2) практически нет. Предположим, у вас есть алгоритм, который должен обработать 2000 элементов.</p>
<ul>
<li>Алгоритму O(1) потребуется всего 1 операция;</li>
<li>Алгоритму O(log(n)) - 7 операций;</li>
<li>Алгоритм O(n) обойдётся вам в 2 000 операций;</li>
<li>Алгоритм O(n*log(n)) – уже в 14 000 операций;</li>
<li>Наконец, алгоритму O(n^2) потребуется 4 000 000 операций.</li>
</ul>
<p>Разница между O(1) и O(n^2) кажется огромной (4 миллиона), но на самом деле это всего около 2 миллисекунд — и моргнуть не успеете. Современные процессоры способны выполнять сотни миллионов операций в секунду. Поэтому для большинства IT-проектов производительность и оптимизация не являются критическими проблемами.<br>Однако, когда вы сталкиваетесь с огромным количеством данных, эти знания вам очень пригодятся. Допустим, теперь алгоритм должен обработать 1 000 000 элементов (не так уж много для базы данных):</p>
<ul>
<li>Алгоритму O(1), как и прежде, потребуется 1 операция;</li>
<li>Алгоритму O(log(n)) - 14 операций;</li>
<li>Алгоритм O(n) займёт 1 000 000 операций;</li>
<li>Алгоритм O(n*log(n)) – 14 000 000 операций;</li>
<li>Алгоритм O(n^2) - 1 000 000 000 000 операции.</li>
</ul>
<p>Точно не считал, но навскидку за время выполнения O(n^2) вы успеете отойти выпить чашку кофе (возможно, две). Добавьте к изначальному количеству элементов ещё один ноль — и на время выполнения последнего алгоритма можно лечь поспать.</p>
<p>Если ближе к практике, можно привести такие примеры:</p>
<ul>
<li>Поиск элемента в правильной хеш-таблице занимает O(1) операций;</li>
<li>Поиск в сбалансированном дереве выдаст результат за O(log(n)) операций;</li>
<li>Поиск в массиве - пример O(n);</li>
<li>Лучшие алгоритмы сортировки имеют O(n*log(n)) временную сложность;</li>
<li>Плохие алгоритмы сортировки — сложность O(n^2).</li>
</ul>
<p>Временная сложность бывает среднестатистической, а также наилучший и наихудший сценарии. Чаще всего, подразумевается худший сценарий.</p>
<p>Также при выполнении алгоритма учитывается потребление памяти и производительность при чтении и записи на диск.</p>
<p>Конечно, есть сложности и похлеще n^2:</p>
<ul>
<li>n^4: это кошмар! я буду упоминать некоторые алгоритмы с такой сложностью;</li>
<li>3^n: просто ад; мы встретим один такой алгоритм примерно в середине статьи (и, он, к слову, используется во многих БД);</li>
<li>факториальный n: результатов вы не дождётесь никогда, даже при небольшом объёме данных;</li>
<li>n^n: если вы используете алгоритмы такой сложности, возможно, стоит спросить себя, а стоит ли мне дальше работать в IT-сфере.</li>
</ul>
<p>Я не дал точного определения “большого О”, только общую идею. Изучить подробнее можете в <a href="https://en.wikipedia.org/wiki/Big_O_notation" target="_blank" rel="external">этой Wiki статье</a>.</p>
<h4 id="Сортировка-методом-слияния"><a href="#Сортировка-методом-слияния" class="headerlink" title="Сортировка методом слияния"></a>Сортировка методом слияния</h4><p>Что вы делаете, когда нужно отсортировать коллекцию? Вызываете функцию <code>sort()?</code> Окей, но для работы с базами данных хорошо бы понимать, как эта функция работает.</p>
<p>Есть несколько хороших алгоритмов сортировки, я остановлюсь на наиболее важном: сортировка методом слияния. Возможно, сейчас вы не очень понимаете, чем так полезна сортировка данных, но когда мы поговорим об оптимизации запросов, вы поймёте. К тому же, понимание этого алгоритма поможет нам позднее понять типичную для БД операцию объединения, которую ещё называют объединение слиянием.</p>
<h5 id="Слияние"><a href="#Слияние" class="headerlink" title="Слияние"></a>Слияние</h5><p>Как и многие полезные алгоритмы, сортировка методом слияния основана на хитрости: слияние двух отсортированных массивов размера N/2 в отсортированный массив из N-элементов займёт всего N операций. Эта операция называется слиянием.</p>
<p>Посмотрим на простом примере, что это значит:</p>
<p><img src="/blog/images/sql_3.png" alt="картинка с алгоритмом слияния"></p>
<p>По рисунку видно, что для построения отсортированного массива из 8 элементов нам нужно перебрать два массива из 4х элементов всего 1 раз.<br>Поскольку оба массива из 4 элементов уже отсортированы, мы:</p>
<ol>
<li>сравниваем два текущих элемента в 2 массивах (текущий = первый, анализируемый впервые);</li>
<li>наименьший из них помещаем в массив из 8 элементов;</li>
<li>и переходим к следующему элементу в массиве, откуда был взят наименьший элемент;<br>повторяем действия 1-2-3, пока не дойдём до последнего элемента в одном из массивов. Затем уже берём оставшиеся элементы другого массива и помещаем их в наш конечный массив из 8 элементнов.</li>
</ol>
<p>Оба массива из 4 элементнов изначально отсортированы, поэтому не приходится возвращаться в них.</p>
<p>Таким образом, сортировка методом слияния разбивает задачу на небольшие задачи, и находит результат этих более мелких задач, чтобы в итоге получить результат исходной задачи (такой вид алгоритмов можно назвать «разделяй и властвуй»). Если вдруг алгоритм всё равно вам не понятен, не расстраивайтесь, я не понял его с первого раза. Можете дополнительно ознакомиться со <a href="http://neerc.ifmo.ru/wiki/index.php?title=%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D1%81%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D0%B5%D0%BC" target="_blank" rel="external">статьёй в википедии</a>.</p>
<p>Я условно разделяю алгоритм на две стадии:</p>
<ol>
<li>стадию деления, когда массив делится на более мелкие массивы;</li>
<li>стадию сортировки, когда небольшие массивы соединяются (слиянием), чтобы сформировать один общий массив.</li>
</ol>
<h5 id="Стадия-деления"><a href="#Стадия-деления" class="headerlink" title="Стадия деления"></a>Стадия деления</h5><p><img src="/blog/images/sql_4.png" alt="иллюстрация стадии деления"></p>
<p>На стадии деления данный массив разбивается на унитарные массивы в 3 шага. Формальное число шагов можно обозначить как <code>log(N)</code> (т.к. N = 8, log(N) = 3).<br>Откуда мне это известно?<br><s>Я гений!</s> Шучу, одним словом — математика. Идея заключается в том, что каждый шаг делит размер исходного массива на 2. Количество шагов отражает, сколько раз можно разделить исходный массив на два. Это определение логарифма (по основанию 2).</p>
<h5 id="Стадия-сортировки"><a href="#Стадия-сортировки" class="headerlink" title="Стадия сортировки"></a>Стадия сортировки</h5><p><img src="/blog/images/sql_5.png" alt="иллюстрация стадии сортировки"></p>
<p>На стадии сортировки мы начинаем с унитарных массивов. На каждом шаге выполняем несколько слияний, и общее число операций составляет N = 8:</p>
<p>Первый этап: 4 слияния, каждое по 2 операции;<br>Второй этап: 2 слияния, 4 операции каждое;<br>На третьем этапе: 1 слияние в 8 операций.</p>
<p>Этапов всего <code>log(N)</code>, то есть <code>N * log(N)</code> операций.</p>
<h5 id="Преимущества-сортировки-методом-слияния"><a href="#Преимущества-сортировки-методом-слияния" class="headerlink" title="Преимущества сортировки методом слияния"></a>Преимущества сортировки методом слияния</h5><p>Так почему же этот алгоритм такой особенный?</p>
<p>Во-первых, его можно изменить, уменьшив тем самым объем занимаемой памяти, так что вам не нужно создавать новые массивы, а лишь непосредственно изменять исходный массив.<br>Такие алгоритмы называются <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="external">локальными</a>.</p>
<p>Во-вторых, вы можете изменить его и использовать одновременно дисковое пространство и небольшой объем памяти, без затратных операций чтения и записи на диск. Идея в том, чтобы загружать в память только те части, которые в данный момент обрабатываются. Это очень актуально, когда вам нужно отсортировать многогигабайтную таблицу с буфером памяти лишь 100 Мб. Такие алгоритмы называются <a href="https://en.wikipedia.org/wiki/External_sorting" target="_blank" rel="external">внешней сортировкой</a>.</p>
<p>К тому же, можно сделать так, чтобы алгоритм работал на нескольких процессах / потоках / серверах. Например, распределенная сортировка слиянием - один из ключевых компонентов Hadoop (фреймворк для больших данных).<br>В общем, этот алгоритм может превратить свинец в золото (правда ведь!).</p>
<p>Данный алгоритм сортировки используется в большинстве баз данных (если не во всех), но он не единственный. Если хотите знать больше, можете прочитать <a href="http://wwwlgis.informatik.uni-kl.de/archiv/wwwdvs.informatik.uni-kl.de/courses/DBSREAL/SS2005/Vorlesungsunterlagen/Implementing_Sorting.pdf" target="_blank" rel="external">эту научную работу</a>, в которой рассматриваются плюсы и минусы основных алгоритмов сортировки в БД.</p>
<h4 id="Массив-дерево-и-хеш-таблица"><a href="#Массив-дерево-и-хеш-таблица" class="headerlink" title="Массив, дерево и хеш-таблица"></a>Массив, дерево и хеш-таблица</h4><p>Теперь, когда вы знаете о временной сложности и сортировке, я должен рассказать вам о 3 структурах данных. Это важно, так как это основы современных баз данных. Также рассмотрим понятие индекс базы данных.</p>
<h5 id="Массив"><a href="#Массив" class="headerlink" title="Массив"></a>Массив</h5><p>Двумерный массив является простой структурой данных. Таблица может рассматриваться как массив. Например:</p>
<p><img src="/blog/images/sql_6.png" alt="картинка таблицы-массива"></p>
<p>Этот двумерный массив представляет собой таблицу со строками и столбцами. Каждая строка представляет собой предмет. Столбцы — признаки, описывающие предметы. Каждый столбец хранит определенный тип данных (целое число, строка, дата …). Для хранения и визуализации данных это удобно, но когда вам нужно найти конкретное значение — это кошмар.</p>
<p>Например, если вам потребуется найти всех людей, работающих в Великобритании, вы должны анализировать каждую строку, чтобы узнать, из Великобритании ли этот человек. Это займёт у вас N операций (где N - число строк), что не плохо, но могло быть и быстрее? Тут-то в игру вступают деревья.</p>
<p>К слову, для более эффективного хранения таблиц большинство современных баз данных обеспечивают расширенные массивы, как таблицы куч или таблицы индексов. Но это не меняет проблемы быстрого поиска по конкретному условию в группе столбцов.</p>
<h5 id="Дерево-и-индекс-БД"><a href="#Дерево-и-индекс-БД" class="headerlink" title="Дерево и индекс БД"></a>Дерево и индекс БД</h5><p>Двоичное дерево поиска - это бинарное дерево с особыми свойствами, ключи в каждом узле должны быть больше всех ключей, хранящихся в левом поддереве, и меньше всех ключей, хранящихся в правом поддереве.</p>
<p>Наглядный пример:</p>
<p><img src="/blog/images/sql_7.png" alt="иллюстрация двоичного дерева поиска"></p>
<p>Это дерево состоит из N = 15 элементов. Допустим, я ищу 208:</p>
<ul>
<li>Начинаем с корня, у которого ключ 136. Поскольку 136 &lt; 208, ищем в правом поддереве узла 136;</li>
<li>398 &gt; 208, поэтому далее ищем в левом поддереве узла 398;</li>
<li>250 &gt; 208, поэтому перемещаемся в левое поддерево узла 250;</li>
<li>200 &lt; 208, соответственно, надо искать в правом поддереве узла 200. Но 200 не имеет правого поддерева, то есть значение не существует (если бы существовало, оно должно было бы находиться в правом поддереве 200).</li>
</ul>
<p>Допустим, теперь я ищу 40:</p>
<ul>
<li>Начинаем с корня, у которого ключ 136. Поскольку 136 &gt; 40, ищем в левом поддереве узла 136;</li>
<li>80 &gt; 40, поэтому далее ищем в левом поддереве узла 80;</li>
<li>4 0 = 40, узел существует. Извлекаем id строки внутри узла (на картинке его нет) и ищем в таблице строку с данным id.</li>
</ul>
<p>Зная id строки, я точно знаю, где именно в таблице находятся нужные данные и могу сразу же их получить.</p>
<p>В итоге, оба поиска заняли количество операций, равных количеству уровней внутри дерева. Если вы внимательно читали раздел о сортировке методом слияния, то увидите, что количество уровней - <code>log(N)</code>. Таким образом, сложность поиска - <code>log(N)</code>.</p>
<h6 id="Назад-к-нашей-проблеме"><a href="#Назад-к-нашей-проблеме" class="headerlink" title="Назад к нашей проблеме"></a>Назад к нашей проблеме</h6><p>Но это всё довольно абстрактные вещи, давайте вернемся к нашей проблеме. Вместо глупого целого числа теперь страну в предыдущей таблице обозначает строка. Предположим, у вас есть дерево, которое содержит столбец таблицы “страна”:</p>
<p>Если задача - узнать, кто работает в Великобритании, вы ищете в дереве узел, представляющий Великобританию, внутри этого узла вы найдете расположение строк работников из Великобритании. Если вы напрямую используете массив, этот поиск потребует <code>log(N)</code> операций (вместо N операций). Это и есть индекс базы данных.</p>
<p>Вы можете построить дерево индекса для любой группы столбцов (строка, целое число, две строки, дата …) при условии, что у вас есть функция для сравнения ключей (т.е. группа столбцов), так что вы можете установить порядок среди ключей (что характерно для большинства БД).</p>
<h5 id="Индекс-B-деревьев"><a href="#Индекс-B-деревьев" class="headerlink" title="Индекс B+-деревьев"></a>Индекс B+-деревьев</h5><p>Поиск определённого значения в таком дереве работает неплохо, но проблемы начинаются, когда нужно найти несколько элементов между двумя данными значениями. Это займёт O(N) времени, поскольку вам придется анализировать каждый узел в дереве и проверять, есть ли он между этими двумя значениями (например, обход дерева с порядковой выборкой). Кроме того, эта операция негавтино сказывается на производительности, поскольку вы обрабатываете всё дерево целиком. Неплохо бы найти более эффективный способ запроса диапазона. Для этого современные базы данных используют модифицированную версию дерева под название B+. В таком дереве только нижние узлы (листья) хранят информацию (расположение строк в соответствующей таблице), остальные узлы во время поиска приводят к нужному узлу.</p>
<p><img src="/blog/images/sql_8.png" alt="иллюстрация индекса B+-дерева"></p>
<p>Как видите, узлов больше (в два раза). Действительно, это дополнительные, «решающие» узлы, которые помогут найти нужный узел (хранящий расположение строк в соответствующей таблице). Но сложность поиска все еще <code>O(log(N))</code> (добавлен лишь ещё один уровень). Большая разница в том, что самые нижние узлы связаны с вышестоящими преемниками.</p>
<p>В таком B+-дереве, если вы ищете значения между 40 и 100:</p>
<ul>
<li>Вы просто должны искать 40 (или ближайшие значения после 40, если 40 не существует), как мы делали в предыдущем примере с деревом;</li>
<li>Затем получить преемников 40, используя прямые ссылки на них, пока не достигнете 100.</li>
</ul>
<p>Допустим, вы нашли М преемников и дерево имеет N узлов. Поиск конкретного узла займёт <code>log(N)</code> времени, как и в предыдущем дереве. Но, как только у вас есть этот узел, вы находите в M операций М преемников со ссылками на их преемников. Этот поиск стоит всего <code>М+log(N)</code> операций, а не N операций, как в примере с предыдущим деревом. Кроме того, вам не нужно читать полное дерево (только М + log(N) узлов), то есть меньше используется диск. Если значение M невелико (например, 200 строк), а N большое (1 000 000 строк), разница будет существенной.</p>
<p>Но теперь появились новые проблемы! Если добавить или удалить строку в базе данных и, следовательно, в соответствующем индексе B+-дерева:</p>
<ul>
<li>вы должны сохранить порядок следования узлов внутри дерева, в противном случае вы не сможете найти узлы внутри беспорядочной массы;</li>
<li>вы должны стремиться к минимально возможному числу уровней в B+-дереве, иначе временная сложность O(log(N)) превратится в O(N).</li>
</ul>
<p>Таким образом, В+-дерево должно быть самоупорядоченным и сбалансированным. К счастью, это возможно с помощью смарт-удаления и вставки операций. Но у всего есть своя цена: операции вставки и удаления в B+-деревьях имеют сложность <code>O(log(N))</code>. Поэтому вы, возможно, знаете, что использовать очень много индексов - плохая идея. Вы замедляете быстрые вставку/обновление/удаление строки в таблице, поскольку базе данных нужно обновить индексы таблицы, а это дорогостоящая <code>O(log(N))</code> операция на каждый индекс. Кроме того, добавление индексов значит больше нагрузки для диспетчера транзакций (мы поговорим о нём в конце статьи).</p>
<p>Более <a href="https://en.wikipedia.org/wiki/B%2B_tree" target="_blank" rel="external">подробную информацию о B+-деревьях</a> можете прочитать в статье в Википедии. Если хотите пример B+-Tree реализации в базе данных, изучите <a href="http://blog.jcole.us/2013/01/07/the-physical-structure-of-innodb-index-pages/" target="_blank" rel="external">эту статью</a> или <a href="http://blog.jcole.us/2013/01/10/btree-index-structures-in-innodb/" target="_blank" rel="external">эту</a> от главного разработчика MySQL. Обе статьи описывают, как InnoDB (движок MySQL) обрабатывает индексы.</p>
<p>Примечание: один читатель заметил, что из-за низкоуровневой оптимизации В+-дерево должно быть полностью сбалансированным.</p>
<h5 id="Хэш-таблица"><a href="#Хэш-таблица" class="headerlink" title="Хэш-таблица"></a>Хэш-таблица</h5><p>Последняя важная структура данных, которую мы рассмотрим, - хеш-таблицы. Они очень полезны, когда нужно быстро получить нужное значение. Понимание хеш-таблиц поможет нам в дальнейшем понять типичную для БД операцию хеш-соединения. Эта структура данных также используется базами данных для хранения внутренних составляющих (например, таблиц блокировок или буферного пула, мы рассмотрим оба понятия позже).</p>
<p>Хеш-таблица - это структура данных, которая быстро находит элемент с ключом. Для построения хеш-таблицы необходимо определить:</p>
<ul>
<li>ключ для элементов;</li>
<li>хеш-функцию для ключей; вычисленные хеши ключей определяют расположение элементов (и называются сегментами (buckets));</li>
<li>функцию для сравнения ключей; как только вы нашли нужный сегмент, необходимо найти нужный элемент внутри данного сегмента с помощью этой функции.</li>
</ul>
<h6 id="Простой-пример"><a href="#Простой-пример" class="headerlink" title="Простой пример"></a>Простой пример</h6><p><img src="/blog/images/sql_9.png" alt="иллюстрация хеш-таблицы"></p>
<p>В данной хеш-таблице 10 сегментов. Из-за великой лени я нарисовал всего 5, но уверен, ваше воображение дорисует ещё 5. Я использовал хеш-функцию с ключом по модулю 10. Другими словами, я храню только последнюю цифру ключа элемента, чтобы найти его сегмент.</p>
<ul>
<li>если последняя цифра 0, элемент попадает в сегмент 0;</li>
<li>если последняя цифра 1, элемент попадает в сегмент 1;</li>
<li>если последняя цифра 2, элемент попадает в сегмент 2, и так далее.</li>
</ul>
<p>В качестве функции для сравнения я использовал простое равенство двух целых чисел.<br>Допустим, нам нужен элемент 78:</p>
<ul>
<li>хеш-таблица вычисляет хеш код для 78, равный 8;</li>
<li>первый элемент в сегменте 8 и есть нужный нам элемент 78.</li>
</ul>
<p>Поиск занимает всего 2 операции – первая вычисляет хеш код, вторая находит элемент в конкретном сегменте.</p>
<p>Например, теперь мы ищем 59:</p>
<ul>
<li>хеш-таблица вычисляет хеш код – 9;</li>
<li>первым элементом в сегменте 9 оказывается 99; поскольку 99 не равно 59, поиск продолжается;</li>
<li>далее по той же логике анализируется второй элемент (9), и следующий за ним (79) и так далее до последнего элемента в сегменте (29);</li>
<li>в данном случае необходимого элемента 59 не существует.</li>
</ul>
<p>Поиск занимает 7 операций.</p>
<h6 id="Правильная-хеш-функция"><a href="#Правильная-хеш-функция" class="headerlink" title="Правильная хеш-функция"></a>Правильная хеш-функция</h6><p>Как видите, количество необходимых операций от поиска к поиску может меняться.<br>Если я заменю фунцию из предыдущего примера на функцию с ключом по модулю 1 000 000, поиск займёт всего 1 операцию, потому что в сегменте 000059 нет элементов. Главная цель – выбрать такую хеш-функцию, которая создаст сегменты с небольшим количеством элементов.</p>
<p>В моём примере найти подходящую хеш-функцию было не трудно – потому что пример простой. Когда ключом является строка (например, фамилия), 2 строки (фамилия и имя), 2 строки и дата (фамилия, имя и дата рождения), найти хорошую функцию уже гораздо сложнее.</p>
<p>Когда хеш-функция удачная, сложность поиска по хеш-таблице составляет O(1).</p>
<h5 id="Массив-или-хеш-таблица"><a href="#Массив-или-хеш-таблица" class="headerlink" title="Массив или хеш-таблица"></a>Массив или хеш-таблица</h5><p>А почему бы не использовать только массивы?<br>Хеш-таблица может быть лишь наполовину загружена в память, остальная половина сегментов будет на диске, а для массива вы должны использовать непрерывное пространство памяти. Если вы работаете с большой таблицей, непрерывного пространства обычно не хватает. С хеш-таблицей вы можете выбрать любой ключ (например, страна и фамилия человека).</p>
<p>Можете также ознакомиться с моей статьёй, где разобран <a href="http://coding-geek.com/how-does-a-hashmap-work-in-java/" target="_blank" rel="external">пример эффективной Java хеш-таблицы</a>; вам совсем не обязательно знать Java, чтобы понять статью.</p>
<h3 id="Компоненты-БД"><a href="#Компоненты-БД" class="headerlink" title="Компоненты БД"></a>Компоненты БД</h3><p>Мы посмотрели на основные компоненты БД. Взглянем на всю картину в целом.</p>
<p>База данных это набор информации, которую легко получать и изменять. Но то же самое можно сказать о куче файлов. На самом деле, простейшие базы данных вроде SQLite это и есть куча файлов. Но продуманная и организованная куча файлов, потому что только БД позволяет использовать транзакции, обеспечивающие верную последовательность и безопасность данных, а также обрабатывать данные быстро, даже когда вы имеете дело с миллионами данных.</p>
<p>Общая структура БД выглядит примерно так:</p>
<p><img src="/blog/images/sql_10.png" alt="картинка структуры БД"></p>
<p>Перед написанием этой части я прочитал немало книг/статей, и каждый источник описывал БД по-своему. Так что не зацикливайтесь особо на том, как я организовал эту базу данных или как назвал процессы, я старался, чтобы данная часть гармонично вписывалась в общий план статьи. Главная идея в том, что <u>БД состоит из нескольких компонентов</u>, которые взаимодействуют друг с другом, а именно:</p>
<h6 id="Ключевые-компоненты"><a href="#Ключевые-компоненты" class="headerlink" title="Ключевые компоненты"></a>Ключевые компоненты</h6><ul>
<li>Диспетчер процессов: многие базы данных имеют пул процессов/потоков, которые необходимо контролировать. Кроме того, в целях экономии наносекунд, некоторые современные базы данных используют собственные потоки вместо потоков операционной системы;</li>
<li>Диспетчер сети: сетевой ввод-вывод - большая проблема, особенно для распределенных баз данных. Поэтому, у некоторых БД есть свой диспетчер сети;</li>
<li>Менеджер файловой системы: чтение или запись на диск — ещё одно слабое место БД. Поэтому важно иметь менеджер, который будет идеально обрабатывать файловую систему операционки или полностью заменит её;</li>
<li>Диспетчер памяти: чтобы избежать эпичных зависаний при чтении или записи на диск, требуется большое количество оперативной памяти. Но когда её много, вам неизбежно потребуется эффективный диспетчер памяти. Особенно когда много одновременных запросов, использующих память;</li>
<li>Диспетчер безопасности учётных записей: для управления аутентификацией и авторизацией пользователей;</li>
<li>Диспетчер клиентов: управляет клиентскими подключениями.</li>
</ul>
<h6 id="Утилиты"><a href="#Утилиты" class="headerlink" title="Утилиты"></a>Утилиты</h6><ul>
<li>Менеджер резервного копирования: для сохранения и восстановления базы данных;</li>
<li>Диспетчер восстановления: обеспечивает целостность данных при перезапуске БД после падения;</li>
<li>Диспетчер контроля: ведёт журнал активности базы данных и предоставляет инструменты для её мониторинга;</li>
<li>Диспетчер администрирования: для хранения метаданных (например, названия и структуры таблиц), а также управления базами данных, схемами, табличными пространствами.</li>
</ul>
<h6 id="Диспетчер-запросов"><a href="#Диспетчер-запросов" class="headerlink" title="Диспетчер запросов"></a>Диспетчер запросов</h6><p>Парсер запросов: проверяет, является ли запрос допустимым;<br>Рерайтер: перезаписывает запрос;<br>Оптимизатор: оптимизирует запрос;<br>Исполнитель запросов: компилирует и выполняет запрос.</p>
<h6 id="Диспетчер-данных"><a href="#Диспетчер-данных" class="headerlink" title="Диспетчер данных"></a>Диспетчер данных</h6><p>Диспетчер транзакций: обрабатывает транзакции;<br>Диспетчер кэша: помещает данные в память перед их использованием и записью на диск;<br>Менеджер доступа к данным: предоставляет доступ к данным на диске.</p>
<p>Далее я подробно остановлюсь на том, как базы данных управляет SQL-запросами с помощью диспетчеров клиентов, запросов и данных (сюда же включу и диспетчера восстановления).</p>
<h3 id="Диспетчер-клиентов"><a href="#Диспетчер-клиентов" class="headerlink" title="Диспетчер клиентов"></a>Диспетчер клиентов</h3><p><img src="/blog/images/sql_11.png" alt="картинка диспетчера клиентов"></p>
<p>Диспетчер клиентов, как несложно догадаться, обрабатывает взиамодействия с клиентом. Клиентом может быть (веб) сервер или приложение конечного пользователя. Диспетчер клиентов предоставляет доступ к базе данных через различные API: JDBC, ODBC, OLE-DB, включая некоторые проприетарные API.</p>
<p>При подключении к БД диспетчер клиентов сначала проверяет аутентификацию (логин и пароль), затем - есть ли у вас полномочия на использование базы данных. Эти права доступа устанавливаются администратором БД. Затем диспетчер проверяет, не перегружена ли БД и есть ли свободный процесс (или поток) для обработки вашего запроса. Пока необходимая информация собирается, диспетчер ожидает. Если ожидание превышает тайм-аут, диспетчер разрывает соединение и возвращает сообщение об ошибке. В дальнейшем ваш запрос перенаправляется к диспетчеру запросов. После получения данных от диспетчера запросов, промежуточные результаты сохраняются в буфер и отправляются вам. В случае каких-то проблем, соединение разрывается, возвращается сообщение, объясняющее проблему, и процесс завершается.</p>
<h3 id="Диспетчер-запросов-1"><a href="#Диспетчер-запросов-1" class="headerlink" title="Диспетчер запросов"></a>Диспетчер запросов</h3><p><img src="/blog/images/sql_12.png" alt="картинка диспетчера запросов"></p>
<p>Вот здесь-то и раскрывается вся сила базы данных. В этой части БД плохо написанный запрос трансформируется в быстрый код, после выполнения которого результаты возвращаются диспетчеру клиентов. Этот процесс состоит из следующих шагов: сначала запрос анализируется на валидность; затем он перезаписывается — это предварительная оптимизация, удаляющая бесполезные операции; далее для улучшения производительности запрос оптимизируется в план исполнения и доступа к данным, который затем компилируется и выполняется.</p>
<p>Если вы хотите лучше понять все вышеописанные процессы, рекомендую почитать:</p>
<ul>
<li>Раннее исследование (1979) на тему оптимизации с учётом затрат: <a href="http://www.cs.berkeley.edu/~brewer/cs262/3-selinger79.pdf" target="_blank" rel="external">выбор пути доступа в реляционной системе управления базами данных</a>. В статье всего 12 страниц, и она будет понятна человеку со средним уровнем компьютерной грамотности;</li>
<li>А вот очень хорошая и подробная презентация о том, <a href="http://infolab.stanford.edu/~hyunjung/cs346/db2-talk.pdf" target="_blank" rel="external">как DB2 9.Х оптимизирует запросы</a>;</li>
<li>Отличная презентация о том, <a href="http://momjian.us/main/writings/pgsql/optimizer.pdf" target="_blank" rel="external">как PostgreSQL оптимизирует запросы</a>. Не сложная, потому что это презентация не про то, какие алгоритмы используются в PostgreSQL, а о планах запросов, которые создаёт PostgreSQL в разных ситуациях;</li>
<li><a href="https://www.sqlite.org/optoverview.html" target="_blank" rel="external">Официальная документация SQLite</a> об оптимизации запросов. Читать тоже не сложно, работают простые правила. Причем, это единственная официальная документация, которая на самом деле объясняет, как оно работает.</li>
<li>Ещё одна годная презентация о том, <a href="https://blogs.msdn.com/cfs-filesystemfile.ashx/__key/communityserver-components-postattachments/00-08-50-84-93/QPTalk.pdf" target="_blank" rel="external">как SQL Server 2005 оптимизирует запросы</a>;</li>
<li>Официальное описание <a href="http://www.oracle.com/technetwork/database/bi-datawarehousing/twp-optimizer-with-oracledb-12c-1963236.pdf" target="_blank" rel="external">оптимизации в Oracle 12с</a>;</li>
<li>2 теоретических курса по оптимизации запросов от авторов книги “Системы управления БД” <a href="http://codex.cs.yale.edu/avi/db-book/db6/slide-dir/PPT-dir/ch12.ppt" target="_blank" rel="external">здесь</a> и <a href="http://codex.cs.yale.edu/avi/db-book/db6/slide-dir/PPT-dir/ch13.ppt" target="_blank" rel="external">здесь</a>. Интересные материалы про оптимизацию чтения и записи на диск, но не для новичков.</li>
<li>Ещё один <a href="https://www.informatik.hu-berlin.de/de/forschung/gebiete/wbi/teaching/archive/sose05/dbs2/slides/09_joins.pdf" target="_blank" rel="external">теоретический курс</a>, он попроще, но акцент только на операции объединения и ввода-вывода.</li>
</ul>
<h4 id="Парсер-запросов"><a href="#Парсер-запросов" class="headerlink" title="Парсер запросов"></a>Парсер запросов</h4><p>Каждый SQL-оператор отправляется в парсер, где он проверяется на правильность синтаксиса. Если вы допустили ошибку, парсер отклонит запрос. Например, если вы написали “SLECT” вместо “SELECT”, на этом обработка вашего запроса закончится. Но это ещё не всё. Парсер также проверяет, что ключевые слова используются в правильном порядке. Например, если перед “SELECT” идёт “WHERE”, запрос будет отклонён. Затем анализируются таблицы и поля запроса. Парсер использует метаданные БД, чтобы проверить, существуют ли таблицы, поля в таблице, а также возможны ли операции для конкретных типов полей (например, нельзя сравнивать целое число со строкой, нельзя использовать substring() для целого числа). Затем проверяется, есть ли у вас разрешение на чтение (или редактирование) данных таблиц. Эти права доступа определяются администратором базы данных. Во время парсинга SQL-запрос преобразуется во внутреннее представление (часто дерево). Если все хорошо, внутреннее представление направляет запрос в рерайтер.</p>
<h4 id="Рерайтер-запросов"><a href="#Рерайтер-запросов" class="headerlink" title="Рерайтер запросов"></a>Рерайтер запросов</h4><p>Итак, у нас есть внутреннее представление запроса. Основная цель рерайтера - предварительно оптимизировать запрос, чтобы избежать ненужных операций и помочь оптимизатору найти наилучшее решение. Рерайтер применяет определённый набор правил к запросу. Если запрос подходит под данное правило, правило применяется - запрос переписывается. </p>
<p>Вот неполный список правил:</p>
<ul>
<li>Слияние представлений: если вы используете представления, они преобразуются соответствующими алгоритмами SQL;</li>
<li>Слияние подзапросов: подзапросы очень трудно оптимизировать, поэтому рерайтер попытается изменить запрос, чтобы избавиться от них.</li>
</ul>
<p>Например:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> PERSON.*</div><div class="line"><span class="keyword">FROM</span> PERSON</div><div class="line"><span class="keyword">WHERE</span> PERSON.person_key <span class="keyword">IN</span></div><div class="line">(<span class="keyword">SELECT</span> MAILS.person_key</div><div class="line"><span class="keyword">FROM</span> MAILS</div><div class="line"><span class="keyword">WHERE</span> MAILS.mail <span class="keyword">LIKE</span> <span class="string">'christophe%'</span>);</div></pre></td></tr></table></figure>
<p>будет заменено на:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> PERSON.*</div><div class="line"><span class="keyword">FROM</span> PERSON, MAILS</div><div class="line"><span class="keyword">WHERE</span> PERSON.person_key = MAILS.person_key</div><div class="line"><span class="keyword">and</span> MAILS.mail <span class="keyword">LIKE</span> <span class="string">'christophe%'</span>;</div></pre></td></tr></table></figure>
<ul>
<li>Удаление лишних операторов: например, если вы используете DISTINCT, и одновременно UNIQUE, что не позволяет данным быть неуникальными, оператор DISTINCT удаляется;</li>
<li>Удаление повторных объединений: если вы дважды использовали одно и то же условие объединения, например, одно из них скрыто в представлении, или если из-за транзитивности объединение повторяется, оно будет удалено;</li>
<li>Постоянные арифметические вычисления: если ваш запрос требует вычислений, они будут произведены один раз в течение перезаписи. Например, WHERE AGE &gt; 10+2 будет преобразовано в WHERE AGE &gt; 12, а TODATE(“какая-нибудь дата”) преобразуется в дату в формате datetime;</li>
<li>(дополнительно) Отсечение разделов: если вы используете секционированные таблицы, рерайтер может определить, какие разделы использовать;</li>
<li>(дополнительно) Перезапись материализованных представлений: если у вас есть материализованное представление, которое соответствует подмножеству предикатов в запросе, рерайтер проверяет, актуально ли представление, и изменяет запрос, чтобы использовать материализованное представление вместо исходных таблиц;</li>
<li>(дополнительно) Пользовательские правила: если у вас есть пользовательские правила для изменения запроса (например, политика Oracle), рерайтер выполняет эти правила;</li>
<li>(дополнительно) OLAP преобразования: аналитические функции, звездообразные объединения, агрегирование также преобразуются (не уверен, делает ли это рерайтер или оптимизатор, скорее всего, зависит от конкретной БД).</li>
</ul>
<p>Наконец, наш переписанный запрос передаётся оптимизатору запросов, где начинается самое интересное!</p>
<p>По мотивам <a href="http://coding-geek.com/how-databases-work/" target="_blank" rel="external">Christophe</a></p>
<p>To be continued…</p>
<p>Читайте так же статьи по теме:</p>
<ul>
<li><a href="https://makeomatic.ru/blog/2015/10/12/relational_database_2/">Как работает реляционная база данных. Часть 2</a></li>
<li><a href="https://makeomatic.ru/blog/2015/11/24/relational_database_3/">Как работает реляционная база данных. Часть 3</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/images/sql_main.jpg&quot; alt=&quot;картинка с логотипами различных баз данных&quot;&gt;&lt;/p&gt;
&lt;p&gt;Когда речь заходит о реляционных базах данных, становится очевидно, что информации по этой теме не хватает. Базы данных используются повсеместно, и они очень разные - от небольшой, но функциональной SQLite до мощной Teradata. И тем не менее, достойных, подробных статей, объясняющих как они работают, практически нет.&lt;/p&gt;
    
    </summary>
    
    
      <category term="SQL" scheme="https://makeomatic.ru/blog/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>10 типичных ошибок Node.js разработчиков (Часть 2)</title>
    <link href="https://makeomatic.ru/blog/2015/05/25/10_mistakes_2_node/"/>
    <id>https://makeomatic.ru/blog/2015/05/25/10_mistakes_2_node/</id>
    <published>2015-05-25T07:00:00.000Z</published>
    <updated>2016-01-08T17:55:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><div class="text-center"><br><img src="https://makeomatic.ru/blog/images/10-mistakes_2.png" alt="10 mistakes Node.js2"><br></div><br><br></p>
<h3 id="ОШИБКА-6-Отлавливание-ошибок-внутри-колбэков"><a href="#ОШИБКА-6-Отлавливание-ошибок-внутри-колбэков" class="headerlink" title="ОШИБКА #6  Отлавливание ошибок внутри колбэков"></a>ОШИБКА #6  Отлавливание ошибок внутри колбэков</h3><p>Как и в большинстве традиционных языков программирования (C++, Java), Javascript поддерживает обработку исключений и отлавливает их с помощью блока «try – catch»:</p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">slugifyUsername</span>(<span class="params">username</span>) </span>&#123;</div><div class="line">	<span class="keyword">if</span>(<span class="keyword">typeof</span> username === <span class="string">'string’'</span>) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'expected a string username, got '</span>+(<span class="keyword">typeof</span> username))</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">	<span class="keyword">var</span> usernameSlug = slugifyUsername(username);</div><div class="line">&#125; <span class="keyword">catch</span>(e) &#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'Oh no!'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Но обработка исключений в асинхронном коде не всегда работает гладко. Например, когда вы хотите изолировать большой асинхронно выполняющийся кусок кода в одном «try – catch» блоке:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">	db.User.get(userId, <span class="function"><span class="keyword">function</span>(<span class="params">err, user</span>) </span>&#123;</div><div class="line">		<span class="keyword">if</span>(err) &#123;</div><div class="line">			<span class="keyword">throw</span> err</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// ...</span></div><div class="line">		usernameSlug = slugifyUsername(user.username)</div><div class="line">		<span class="comment">// ...</span></div><div class="line">	&#125;)</div><div class="line">&#125; <span class="keyword">catch</span>(e) &#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'Oh no!'</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Если переданный в «db.User.get» колбэк выполнится асинхронно — вне контекста блока «try – catch» — ошибки внутри этой возвратной функции не будут обработаны. Поэтому для обработки исключений в возвратных функциях в Node.js пользуйтесь проверенной схемой - первым аргументом возвратной функции ожидайте ошибку:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">callmeAsync(<span class="function"><span class="keyword">function</span> (<span class="params">err, arg1, arg2, ...</span>) </span>&#123;</div><div class="line">	<span class="comment">// ... handle error</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<!-- more -->
<h3 id="ОШИБКА-7-Математические-операции-с-числами"><a href="#ОШИБКА-7-Математические-операции-с-числами" class="headerlink" title="ОШИБКА #7  Математические операции с числами"></a>ОШИБКА #7  Математические операции с числами</h3><p>Все числа в Javascript – с плавающей десятичной запятой, целочисленного типа данных нет. При этом числа с плавающей запятой могут содержать целочисленные представления только до определённого значения,  при превышении которого и начинаются ошибки в вычислениях. Например, следующее выражение (как ни парадоксально) в Node.js вернёт значение true:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>)+<span class="number">1</span> === <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>)</div></pre></td></tr></table></figure>
<p>К сожалению, это ещё не все сюрпризы при работе с числами. При том, что сами числа — с плавающей запятой, операторы, используемые в подсчётах, предзназначены для работы с целыми типами данных. Поэтому получаем:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">5</span> % <span class="number">2</span> === <span class="number">1</span>     <span class="comment">// true</span></div><div class="line"><span class="number">5</span> &gt;&gt; <span class="number">1</span> === <span class="number">2</span>   <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>В отличие от арифметических операторов, поразрядные операторы и операторы сдвига работают только с 32 битами таких чисел. Поэтому сдвиг  <code>Math.pow(2, 53)</code> на 1 всегда вернёт значение 0. Это же число в поразрядной операции ИЛИ вернёт значене 1:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) / <span class="number">2</span> === <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">52</span>) <span class="comment">// true</span></div><div class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) &gt;&gt; <span class="number">1</span> === <span class="number">0</span> <span class="comment">// true</span></div><div class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) | <span class="number">1</span> === <span class="number">1</span> <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>Это всё не кажется серьёзной проблемой, поскольку работать с большими числами приходится редко. Но если возникает такая необходимость, есть немало библиотек для точных математических операций с большими числами, например, <a href="https://www.npmjs.com/package/bignum" target="_blank" rel="external">node-bigint</a>.</p>
<h3 id="ОШИБКА-8-Неиспользование-потоковых-API"><a href="#ОШИБКА-8-Неиспользование-потоковых-API" class="headerlink" title="ОШИБКА #8  Неиспользование потоковых API"></a>ОШИБКА #8  Неиспользование потоковых API</h3><p>Допустим, мы хотим создать небольшой прокси-сервер, который обрабатывает запросы, принимая данные с другого веб-сервера. Например, веб сервер, обрабатывающий Gravatar изображения.  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</div><div class="line"><span class="keyword">var</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>)</div><div class="line"></div><div class="line">http.createServer()</div><div class="line">	.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</div><div class="line">		<span class="keyword">var</span> email = req.url.substr(req.url.lastIndexOf(<span class="string">'/'</span>)+<span class="number">1</span>)</div><div class="line">		<span class="keyword">if</span>(!email) &#123;</div><div class="line">			res.writeHead(<span class="number">404</span>)</div><div class="line">			<span class="keyword">return</span> res.end()</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">var</span> buf = <span class="keyword">new</span> Buffer(<span class="number">1024</span>*<span class="number">1024</span>);</div><div class="line">		http.get(<span class="string">'http://www.gravatar.com/avatar/'</span>+crypto.createHash(<span class="string">'md5'</span>).update(email).digest(<span class="string">'hex'</span>), <span class="function"><span class="keyword">function</span>(<span class="params">resp</span>) </span>&#123;</div><div class="line">			<span class="keyword">var</span> size = <span class="number">0</span></div><div class="line">			resp.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</div><div class="line">				chunk.copy(buf, size)</div><div class="line">				size += chunk.length</div><div class="line">			&#125;)</div><div class="line">			.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">				res.write(buf.slice(<span class="number">0</span>, size))</div><div class="line">				res.end()</div><div class="line">			&#125;)</div><div class="line">		&#125;)</div><div class="line">	&#125;)</div><div class="line">	.listen(<span class="number">8080</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>В данном примере сервер получает изображение с Gravatar, помещает его в буфер, затем обрабатывает запрос. Такой вариант допустим, поскольку аватарки обычно небольшого размера. Но представьте, что данные, которые мы проксируем, весят тесячи мегабайт. Тогда лучше поступить так:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">http.createServer()</div><div class="line">	.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</div><div class="line">		<span class="keyword">var</span> email = req.url.substr(req.url.lastIndexOf(<span class="string">'/'</span>)+<span class="number">1</span>)</div><div class="line">		<span class="keyword">if</span>(!email) &#123;</div><div class="line">			res.writeHead(<span class="number">404</span>)</div><div class="line">			<span class="keyword">return</span> res.end()</div><div class="line">		&#125;</div><div class="line">		http.get(<span class="string">'http://www.gravatar.com/avatar/'</span>+crypto.createHash(<span class="string">'md5'</span>).update(email).digest(<span class="string">'hex'</span>), <span class="function"><span class="keyword">function</span>(<span class="params">resp</span>) </span>&#123;</div><div class="line">			resp.pipe(res)</div><div class="line">		&#125;)</div><div class="line">	&#125;)</div><div class="line">	.listen(<span class="number">8080</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Как видно из примера, мы получаем изображение с Gravatar и сразу передаём в поток клиенту. Этап буферизации данных полностью исключён.</p>
<h3 id="ОШИБКА-9-Использование-console-log-для-отладки"><a href="#ОШИБКА-9-Использование-console-log-для-отладки" class="headerlink" title="ОШИБКА #9  Использование console.log() для отладки"></a>ОШИБКА #9  Использование <code>console.log()</code> для отладки</h3><p><code>console.log()</code> – удобный способ для вывода в консоль любых ваших действий. Передайте объект — в консоли получите объектный литерал. <code>console.log()</code>  принимает любое количество аргументов и выводит их, отделив пробелами. Одним словом, искушение пользоваться таким способом для отладки багов велико. Но всё же не рекомендую. Некоторые в процессе отладки используют <code>console.log()</code> крайне активно, и так и оставляют его в коде в закомментированных строках. Лучше в таких ситуациях воспользуйтесь какой-нибудь специально предназначенной для этих целей библиотекой, например <a href="https://www.npmjs.com/package/debug" target="_blank" rel="external">debug</a>.</p>
<p>С помощью этой библиотеки можно автоматически отключить режим отладки при запуске приложения. Например, можно избежать вывода любых сообщений об ошибках в терминал, если не устанавливать переменную среды отладки DEBUG:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// app.js</span></div><div class="line"><span class="keyword">var</span> debug = <span class="built_in">require</span>(<span class="string">'debug'</span>)(<span class="string">'app’'</span>)</div><div class="line">debug(<span class="string">'Hello, %s!'</span>,<span class="string">'world'</span>)</div></pre></td></tr></table></figure>
<p>Соответственно, чтобы ошибки выводились, установите переменную со значением «app» или «*»:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DEBUG=app node app.js</div></pre></td></tr></table></figure>
<h3 id="ОШИБКА-10-Неиспользование-диспетчера"><a href="#ОШИБКА-10-Неиспользование-диспетчера" class="headerlink" title="ОШИБКА #10  Неиспользование диспетчера"></a>ОШИБКА #10  Неиспользование диспетчера</h3><p>Как на стадии девелопмента, так и в продакшене,  очень полезно использовать программу-диспетчер для управления всеми программными процессами. Опытные разработчики часто говорят, что в случае сбоя приложения, не нужно пытаться обработать ошибку — позвольте приложению прекратить работу, и диспетчер перезапустит его в считанные секунды. И это ещё не всё, на что способен диспетчер: помимо перазапуска при сбое, он также может перезапускать приложение после обновления файлов. Одним словом, разрабатывать на Node.js с диспетчером куда приятнее, чем без него.</p>
<h4 id="Примеры-программ-диспетчеров"><a href="#Примеры-программ-диспетчеров" class="headerlink" title="Примеры программ-диспетчеров:"></a>Примеры программ-диспетчеров:</h4><ul>
<li><a href="https://www.npmjs.com/package/pm2" target="_blank" rel="external">pm2</a></li>
<li><a href="https://www.npmjs.com/package/forever" target="_blank" rel="external">forever</a></li>
<li><a href="https://www.npmjs.com/package/nodemon" target="_blank" rel="external">nodemon</a></li>
<li><a href="https://www.npmjs.com/package/supervisor" target="_blank" rel="external">supervisor</a></li>
</ul>
<p>У каждой программы свои плюсы: одни хороши для управления несколькими приложениями на одной машине, другие лучше работают с логами.</p>
<h3 id="Вместо-заключения"><a href="#Вместо-заключения" class="headerlink" title="Вместо заключения"></a>Вместо заключения</h3><p>Некоторые из перечисленных ловушек могут иметь катастрофичные последствия для ваших приложений, некоторые просто сбивают с толку в процессе реализации простейших вещей на Node.js. В принципе «порог вхождения» в ноду для новичков не очень высок, и всё же подводные камни есть. Перечисленные ошибки могут быть знакомы и разработчикам на других языках программирования. Но предупреждён — значит, вооружён! Надеюсь, эта статья поможет вам не попадаться в ловушки для новичков.</p>
<p>Читайте так же: <a href="https://makeomatic.ru/blog/2015/04/28/10_mistakes_node/">10 типичных ошибок Node.js разработчиков, Часть 1</a></p>
<p>По мотивам <a href="http://www.toptal.com/nodejs/top-10-common-nodejs-developer-mistakes" target="_blank" rel="external">Mahmud Ridwan</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;div class=&quot;text-center&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://makeomatic.ru/blog/images/10-mistakes_2.png&quot; alt=&quot;10 mistakes Node.js2&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;br&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h3 id=&quot;ОШИБКА-6-Отлавливание-ошибок-внутри-колбэков&quot;&gt;&lt;a href=&quot;#ОШИБКА-6-Отлавливание-ошибок-внутри-колбэков&quot; class=&quot;headerlink&quot; title=&quot;ОШИБКА #6  Отлавливание ошибок внутри колбэков&quot;&gt;&lt;/a&gt;ОШИБКА #6  Отлавливание ошибок внутри колбэков&lt;/h3&gt;&lt;p&gt;Как и в большинстве традиционных языков программирования (C++, Java), Javascript поддерживает обработку исключений и отлавливает их с помощью блока «try – catch»:&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="https://makeomatic.ru/blog/tags/Node-js/"/>
    
      <category term="Javascript" scheme="https://makeomatic.ru/blog/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>10 типичных ошибок Node.js разработчиков</title>
    <link href="https://makeomatic.ru/blog/2015/04/28/10_mistakes_node/"/>
    <id>https://makeomatic.ru/blog/2015/04/28/10_mistakes_node/</id>
    <published>2015-04-28T07:00:00.000Z</published>
    <updated>2016-01-08T17:55:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><div class="text-center"><br><img src="/blog/images/10-mistakes.png" alt="Иллюстрация блокнота"><br></div><br><br></p>
<p>С момента выхода Node.js, многие разработчики удостаивали его высоких похвал, многие  жёстко критиковали. Подобные «холивары», вероятно, не прекратятся никогда. Важно в этих спорах то, что любую платформу и любой язык программирования критикуют за определённые слабые места, которые всегда обусловлены тем, как мы используем данный инструмент. </p>
<a id="more"></a>
<p>На Node.js непросто писать «традиционный» код, зато легко писать код асинхронный, платформа существует уже достаточно долгое время, и на ней создано огромное количество надёжных, высокотехнологичных, легко масштабируемых веб-сервисов, демонстрирующих стабильность в работе на протяжении всего времени своего существования. </p>
<p>Но при работе с любой платформой — и Node.js не исключение — разработчики совершают ошибки. Некоторые из этих ошибок снижают производительность, а некоторые создают впечатление, что Node.js непригодна вообще ни для каких целей. Давайте рассмотрим 10 типичных ошибок новичков, и способы их избежать.</p>
<h3 id="ОШИБКА-1-Блокирование-цикла-обработки-событий"><a href="#ОШИБКА-1-Блокирование-цикла-обработки-событий" class="headerlink" title="ОШИБКА 1: Блокирование цикла обработки событий"></a>ОШИБКА 1: Блокирование цикла обработки событий</h3><p>JavaScript в Node.js (как и в браузере) создаёт однопоточную среду. Это значит, никакие компоненты приложения не выполняются одновременно; вместо этого, параллелизм достигается за счет асинхронной обработки операций ввода/вывода . Например, сделав запрос к ядру СУБД, чтобы извлечь какой-нибудь документ, в ожидании ответа Node.js может параллельно работать с другой частью приложения. </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Извлекая из базы данных объект «пользователь», Node.js может выполнять другие части кода с того момента, как начнёт выполняться данная функция</span></div><div class="line">   db.User.get(userId, <span class="function"><span class="keyword">function</span>(<span class="params">err, user</span>) </span>&#123;</div><div class="line">        <span class="comment">// до момента, пока объект «пользователь» будет загружен сюда</span></div><div class="line">&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Однако, чтобы блокировать цикл обработки событий, достаточно добавить  немного нагружающего процессор кода с большим количеством подключенных клиентов — и все клиенты будут ждать в очереди. Проблемы с производительностью CPU обеспечены при попытках сортировки больших массивов, запуске очень долгого цикла, и всё в таком духе. Пример:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortUsersByAge</span>(<span class="params">users</span>) </span>&#123;</div><div class="line">        users.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">                <span class="keyword">return</span> a.age &lt; b.age ? <span class="number">-1</span> : <span class="number">1</span></div><div class="line">        &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Вызов функции <code>sortUsersByAge</code> при работе с маленьким массивом пользователей сработает на отлично, но при большом количестве юзеров снижение общей производительности может быть ужасающим. Если это абсолютно необходимо сделать и вы уверены, что при этом ничего не будет висеть в очереди (допустим, вы пишете какую-нибудь командную строку, и не страшно, если всё будет выполняться синхронно), данная проблема вам не страшна. Но стоит проделать нечто подобное на сервере Node.js с тысячами пользователей, и блокирование потока вам гарантировано.</p>
<p>Если массив пользователей извлекается из базы данных, правильным решением будет взять его уже отсортированным непосредственно в базе данных. Если цикл событий был заблокирован циклом, вычисляющим сумму очень длинной истории данных финансовых операций, этому событию лучше подключить отдельный обработчик/очередь, чтобы снять блокировку. Если человек ни разу не занимался такой борьбой с блокировками, то ему может быть непонятна фраза “подключить отдельный обработчик/очередь”, если можно тут дать пример или просто конкретизировать предложенное решение. </p>
<p>Идеальных решений в таких ситуациях не существует, в каждом случае всё индивидуально. Главная мысль — не совершать операций с высокой нагрузкой на ЦП на инстансах Node.js, к которым клиенты подключаются параллельно. </p>
<h3 id="ОШИБКА-2-Вызов-колбека-несколько-раз"><a href="#ОШИБКА-2-Вызов-колбека-несколько-раз" class="headerlink" title="ОШИБКА 2: Вызов колбека несколько раз"></a>ОШИБКА 2: Вызов колбека несколько раз</h3><p>Колбеки в Jacascript используются со времён Куликовской битвы. В веб-браузерах события обрабатываются путём передачи в функции (часто анонимные) параметров по ссылке, где функции ведут себя как колбеки. До недавнего времени колбеки в Node.js были единственным способом взаимодействия асинхронных элементов кода друг с другом — пока не появились промисы. Но колбеки никуда не делись, многие разработчики пакетов по-прежнему выстраивают API на колбеках. И типичная ошибка здесь — вызов колбека несколько раз. Обычно функция, выполняющая что-то асинхронно, ожидает в качестве последнего аргумента другую функцию, которая вызывается, когда асинхронная операция завершена. </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports.verifyPassword = <span class="function"><span class="keyword">function</span>(<span class="params">user, password, done</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> password !== ‘string’) &#123;</div><div class="line">                done(<span class="keyword">new</span> <span class="built_in">Error</span>(‘password should be a string’))</div><div class="line">                <span class="keyword">return</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        computeHash(password, user.passwordHashOpts, <span class="function"><span class="keyword">function</span>(<span class="params">err, hash</span>) </span>&#123;</div><div class="line">                <span class="keyword">if</span>(err) &#123;</div><div class="line">                        done(err)</div><div class="line">                        <span class="keyword">return</span></div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                done(<span class="literal">null</span>, hash === user.passwordHash)</div><div class="line">        &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>В примере мы видим, что в каждом вызове <code>done</code> прописан оператор <code>return</code>, за исключением последнего вызова. А всё потому, что вызов колбека не означает автоматического завершения выполнения текущей функции. Если закомментировать первый <code>return</code>, передача не строкового пароля данной функции всё равно вызовет <code>computeHash</code>. В зависимости от того, как <code>computeHash</code> сработает в данном случае, колбек «done» может вызываться нескольк раз. Для кого-то это будет неприятным сюрпризом.<br>Во избежание сюрпризов, нужно просто быть аккуратным. Некоторые разработчики выработали привычку добавлять <code>return</code> перед каждым вызовом колбека:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(err) &#123;</div><div class="line">        <span class="keyword">return</span> done(err)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Для многих асинхронных функций значение <code>return</code> не имеет почти никакого значения, зато такой подход часто позволяет избежать ошибок.</p>
<h3 id="ОШИБКА-3-Глубокая-вложенность-колбеков"><a href="#ОШИБКА-3-Глубокая-вложенность-колбеков" class="headerlink" title="ОШИБКА 3: Глубокая вложенность колбеков"></a>ОШИБКА 3: Глубокая вложенность колбеков</h3><p>Само по себе это явление, именуемое в интернетах «лапшой из колбеков», не обязательно влечёт за собой катастрофу. Но новичок может быстро потерять контроль над собственым кодом.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleLogin</span>(<span class="params">..., done</span>) </span>&#123;</div><div class="line">        db.User.get(..., <span class="function"><span class="keyword">function</span>(<span class="params">..., user</span>) </span>&#123;</div><div class="line">                <span class="keyword">if</span>(!user) &#123;</div><div class="line">                        <span class="keyword">return</span> done(<span class="literal">null</span>, ‘failed to log <span class="keyword">in</span>’)</div><div class="line">                &#125;</div><div class="line">                utils.verifyPassword(..., <span class="function"><span class="keyword">function</span>(<span class="params">..., okay</span>) </span>&#123;</div><div class="line">                        <span class="keyword">if</span>(okay) &#123;</div><div class="line">                                <span class="keyword">return</span> done(<span class="literal">null</span>, ‘failed to log <span class="keyword">in</span>’)</div><div class="line">                        &#125;</div><div class="line">                        session.login(..., <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                                done(<span class="literal">null</span>, ‘logged <span class="keyword">in</span>’)</div><div class="line">                        &#125;)</div><div class="line">                &#125;)</div><div class="line">        &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>И чем сложнее решаемая задача, тем запутаннее код — его крайне трудно читать и поддерживать. Один из способов решения - разбить задачки на микро-функции и пошагово их соединить. Хотя, наиболее простым (субъективно) решением будет использование пакетной утилиты Node.js для асинхронных шаблонов Javascript – Async.js:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleLogin</span>(<span class="params">done</span>) </span>&#123;</div><div class="line">        <span class="keyword">async</span>.waterfall([</div><div class="line">                <span class="function"><span class="keyword">function</span>(<span class="params">done</span>) </span>&#123;</div><div class="line">                        db.User.get(..., done)</div><div class="line">                &#125;,</div><div class="line">                <span class="function"><span class="keyword">function</span>(<span class="params">user, done</span>) </span>&#123;</div><div class="line">                        <span class="keyword">if</span>(!user) &#123;</div><div class="line">                        <span class="keyword">return</span> done(<span class="literal">null</span>, ‘failed to log <span class="keyword">in</span>’)</div><div class="line">                        &#125;</div><div class="line">                        utils.verifyPassword(..., <span class="function"><span class="keyword">function</span>(<span class="params">..., okay</span>) </span>&#123;</div><div class="line">                                done(<span class="literal">null</span>, user, okay)</div><div class="line">                        &#125;)</div><div class="line">                &#125;,</div><div class="line">                <span class="function"><span class="keyword">function</span>(<span class="params">user, okay, done</span>) </span>&#123;</div><div class="line">                        <span class="keyword">if</span>(okay) &#123;</div><div class="line">                                <span class="keyword">return</span> done(<span class="literal">null</span>, ‘failed to log <span class="keyword">in</span>’)</div><div class="line">                        &#125;</div><div class="line">                        session.login(..., <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                                done(<span class="literal">null</span>, ‘logged <span class="keyword">in</span>’)</div><div class="line">                        &#125;)</div><div class="line">                &#125;</div><div class="line">        ], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="comment">// ...</span></div><div class="line">        &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Аналогично <code>async.waterfall</code>, модуль Async.js предоставляет ряд других функций для работы с асинхронными шаблонами. Для краткости, примеры в статье совсем не ужасающие, в реальности бывает гораздо хуже.</p>
<h3 id="ОШИБКА-4-Ожидание-синхронных-колбеков"><a href="#ОШИБКА-4-Ожидание-синхронных-колбеков" class="headerlink" title="ОШИБКА 4: Ожидание синхронных колбеков"></a>ОШИБКА 4: Ожидание синхронных колбеков</h3><p>Асинхронное программирование с колбеками присуще не только Javascript и Node.js, но именно благодаря ему эти инструменты так популярны. Во многих других языках программирования порядок исполнения предсказуем, два выражения будут выполняться один за другим, если не указано иначе — и в любом случае мы ограничены условными выражениями, операторами цикла и вызовом функций.  </p>
<p>Но в Javascript, функция с колбелками, ожидающая завершения какой-то операции, может срабатывать не так, как было задумано. В примере ниже функция будет выполняться до конца, без остановок:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">testTimeout</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(“Begin”)</div><div class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(“Done!”)</div><div class="line">        &#125;, duration * <span class="number">1000</span>)</div><div class="line">        <span class="built_in">console</span>.log(“Waiting..”)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Вызов функции <code>testTimeout()</code> сначала напечатает «Begin», затем - «Waiting..» и лишь через секунду сообщение «Done!»</p>
<p>Всё, что должно происходить после вызова колбека, должно быть прописано внутри него.</p>
<h3 id="ОШИБКА-5-Использование-exports-вперемешку-с-module-exports"><a href="#ОШИБКА-5-Использование-exports-вперемешку-с-module-exports" class="headerlink" title="ОШИБКА 5: Использование exports вперемешку с module.exports"></a>ОШИБКА 5: Использование <code>exports</code> вперемешку с <code>module.exports</code></h3><p>Каждый файл в Node.js – небольшой изолированный модуль. Если в вашем проекте два файла, скажем, «a.js» и «b.js», то для того, чтобы файл «b.js» получил доступ к функционалу файла «a.js», значения последнего нужно экспортировать. Присвоим их параметрам объекта <code>exports</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a.js</span></div><div class="line">exports.verifyPassword = <span class="function"><span class="keyword">function</span>(<span class="params">user, password, done</span>) </span>&#123; ... &#125;</div><div class="line"><span class="built_in">module</span>.exports.verifyPassword = <span class="function"><span class="keyword">function</span>(<span class="params">...</span>)</span></div></pre></td></tr></table></figure>
<p>В результате по запросу «a.js» получим объект с функцией <code>verifyPassword</code>.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// b.js</span></div><div class="line"><span class="built_in">require</span>(‘a.js’) <span class="comment">// &#123; verifyPassword: function(user, password, done) &#123; ... &#125; &#125;</span></div></pre></td></tr></table></figure>
<p>Но что, если нам нужно экспортировать именно функцию, не как объектное значение? Для этого нужно переопределить <code>exports</code>, но как локальную, а не глобальную переменную:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a.js</span></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">user, password, done</span>) </span>&#123; ... &#125;</div><div class="line"><span class="comment">// а могу ли я здесь написать module.exports.verifyPassword = function(...) - да</span></div><div class="line"><span class="comment">//module.exports является node.js расширением, которое позволяет разработчикам экспортировать не объектные значения.</span></div></pre></td></tr></table></figure>
<p>На самом деле,  изначально <code>exports</code> и <code>module.exports</code> всегда ссылаются на один и тот же объект: <code>var exports = module.exports = {};</code>  —  и наш модуль, по сути, всегда возвращает именно <code>module.exports</code>. Но если мы в процессе присваиваем переменной <code>exports</code> другое значение, она уже не будет ссылаться на <code>module.exports</code>, и наш модуль ничего не вернёт. Простой рецепт от возможной путаницы —  всегда используйте что-то одно; безопаснее и удобнее - <code>module.exports</code>. </p>
<p>Вторая порция ошибок и способов лечения — в нашей следующей статье :) </p>
<p>По мотивам <a href="http://www.toptal.com/nodejs/top-10-common-nodejs-developer-mistakes" target="_blank" rel="external">Mahmud Ridwan</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;div class=&quot;text-center&quot;&gt;&lt;br&gt;&lt;img src=&quot;/blog/images/10-mistakes.png&quot; alt=&quot;Иллюстрация блокнота&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;br&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;С момента выхода Node.js, многие разработчики удостаивали его высоких похвал, многие  жёстко критиковали. Подобные «холивары», вероятно, не прекратятся никогда. Важно в этих спорах то, что любую платформу и любой язык программирования критикуют за определённые слабые места, которые всегда обусловлены тем, как мы используем данный инструмент. &lt;/p&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="https://makeomatic.ru/blog/tags/Node-js/"/>
    
      <category term="Javascript" scheme="https://makeomatic.ru/blog/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Flex-элементы</title>
    <link href="https://makeomatic.ru/blog/2015/03/23/flexbox2/"/>
    <id>https://makeomatic.ru/blog/2015/03/23/flexbox2/</id>
    <published>2015-03-23T07:00:00.000Z</published>
    <updated>2016-01-08T17:55:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><div class="text-center"><br><img src="/blog/images/flex2.jpg" alt="Иллюстрация блокнота"><br></div><br><br></p>
<p>О flex-контейнере и его свойствах поговорили в <a href="https://makeomatic.ru/blog/2015/02/24/flexbox/">части 1</a>, теперь поговорим о дочерних элементах.</p>
<a id="more"></a>
<h3 id="Свойства-flex-элементов"><a href="#Свойства-flex-элементов" class="headerlink" title="Свойства flex-элементов"></a>Свойства flex-элементов</h3><h4 id="order"><a href="#order" class="headerlink" title="order"></a>order</h4><p><img src="/blog/images/order2.svg" alt="Иллюстрация блокнота"></p>
<p>По умолчанию элементы в контейнере располагаются в порядке следования в html-документе. Однако, с помощью свойства order порядок можно изменять.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.item &#123;</div><div class="line">  <span class="attr">order</span>: <span class="xml"><span class="tag">&lt;<span class="name">integer</span>&gt;</span>; /*любое ваше число*/</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h4><p><img src="/blog/images/flex-grow.svg" alt="Иллюстрация блокнота"></p>
<p>Это свойство позволяет элементу при необходимости увеличиваться в размерах. Принимает пропорциональное число без единиц измерения и определяет, какое количество свободного пространства в контейнере каждый элемент может занимать. Если указанное значение flex-grow для всех элементов равно 1, каждый элемент займёт одинаковое количество пространства. Если присвоить одному элементу значение 2, он займёт в два раза больше пространства, чем остальные элементы. </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.item &#123;</div><div class="line">  flex-grow: <span class="xml"><span class="tag">&lt;<span class="name">число</span>&gt;</span>; /* по умолчанию 0 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Отрицательные значения не допустимы.</p>
<h4 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h4><p>По аналогии с предыдущим, это свойство позволяет элементу при необходимости уменьшаться в размерах.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.item &#123;</div><div class="line">  flex-shrink: <span class="xml"><span class="tag">&lt;<span class="name">число</span>&gt;</span>; /* по умолчанию 1 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Отрицательные значения не допустимы.</p>
<h4 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h4><p>Определяет размер элемента по умолчанию до распределения свободного места в контейнере. Задаёт ширину или высоту элемента — в зависимости от указанного направления flex-direction. </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.item &#123;</div><div class="line">  flex-basis: <span class="xml"><span class="tag">&lt;<span class="name">величина</span>&gt;</span> | auto; /* по умолчанию auto */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Если указано значение 0, свободное пространство вокруг содержания элемента не учитывается. Если указано значение auto, пространство распределяется в соответствии с величиной свойства flex-grow данного элемента. Подробная иллюстрация <a href="http://www.w3.org/TR/css3-flexbox/images/rel-vs-abs-flex.svg" target="_blank" rel="external">здесь</a></p>
<h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h4><p>Это короткий вариант записи свойств flex-grow, flex-shrink и flex-basis. Два последних параметра (flex-shrink и flex-basis)  - опциональны. Значения flex по умолчанию: 0 1 auto.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.item &#123;</div><div class="line">  <span class="attr">flex</span>: none | [ <span class="xml"><span class="tag">&lt;<span class="name">'flex-grow'</span>&gt;</span> <span class="tag">&lt;<span class="name">'flex-shrink'</span>&gt;</span> || <span class="tag">&lt;<span class="name">'flex-basis'</span>&gt;</span> ]</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Рекомендуется использовать это короткое свойство flex вместо прописывания каждого свойства по-отдельности.</p>
<h4 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h4><p><img src="/blog/images/align-self.svg" alt="Иллюстрация блокнота"></p>
<p>Это свойство задаёт выравнивание по перпендикулярной оси конкретному flex-элементу — и переопределяет указанное ранее для контейнера свойство align-items (возможные значения такие же - см. в разделе «Свойства flex-контейнера»). </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.item &#123;</div><div class="line">  align-self: auto | flex-start | flex-end | center | baseline | stretch;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Имейте в виду, что свойства float, clear и vertical-align не работают для flex-элементов.</p>
<h3 id="Перейдём-к-примерам"><a href="#Перейдём-к-примерам" class="headerlink" title="Перейдём к примерам"></a>Перейдём к примерам</h3><p>Начнём с примера, решаюшего тривиальную задачу — идеальное центрирование. С flexbox это просто:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">.parent &#123;</div><div class="line">  <span class="attr">display</span>: flex;</div><div class="line">  height: <span class="number">300</span>px; <span class="comment">/* любое ваше значение */</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">.child &#123;</div><div class="line">  <span class="attr">width</span>: <span class="number">100</span>px;  <span class="comment">/* любое ваше значение  */</span></div><div class="line">  height: <span class="number">100</span>px; <span class="comment">/* любое ваше значение  */</span></div><div class="line">  margin: auto;  <span class="comment">/* магия! */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Этот пример основан на том, что свойство margin: auto в flex-контейнере распределяет всё свободное пространство. Таким образом, flex-элемент идеально выравнивается по обеим осям. </p>
<p>Другой пример. Рассмотрим список из 6 элементов, в эстетических целях всем заданы фиксированные размеры, хотя они могли быть и не указаны. Нам нужно, чтобы элементы были красиво выравнены по горизонтальной оси так, чтобы при изменении размера браузера, всё оставалось по-прежнему красивым (без @media queries):</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> .flex-container &#123;</div><div class="line">  <span class="comment">/* Создаём flex контекст */</span></div><div class="line">  display: flex;</div><div class="line">  </div><div class="line">  <span class="comment">/* Определяем направление и указываем, могут ли блоки переноситься </span></div><div class="line">   * Помните, это короткий вариант записи, то же самое, что отдельно указать    </div><div class="line">   * flex-direction: row;</div><div class="line">   * flex-wrap: wrap;</div><div class="line">   */</div><div class="line">  flex-flow: row wrap;</div><div class="line">  </div><div class="line">  <span class="comment">/* Далее указываем, как будет распределяться свободное пространство */</span></div><div class="line">  justify-content: space-around;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Готово. Остальное — вопрос дизайна. Ниже вставлен пример с codepen с данным кодом. Не поленитесь, сходите на <a href="http://codepen.io/HugoGiraudel/full/LklCv/" target="_blank" rel="external">Codepen</a>, и поиграйтесь с размерами вашего браузера:</p>
<p></p><p data-height="268" data-theme-id="0" data-slug-hash="LklCv" data-default-tab="result" data-user="HugoGiraudel" class="codepen">See the Pen <a href="http://codepen.io/HugoGiraudel/pen/LklCv/" target="_blank" rel="external">Demo Flexbox 1</a> by Hugo Giraudel (<a href="http://codepen.io/HugoGiraudel" target="_blank" rel="external">@HugoGiraudel</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p><p></p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>

<p>Попробуем что-нибудь ещё. В верхней части нашего сайта имеется выравненная по правому краю навигация. Нам надо, чтобы на средних экранах она была выравнена по центру, а на малых экранах превращалась в одну колонку. Легко.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* большие экраны */</span></div><div class="line">.navigation &#123;</div><div class="line">  <span class="attr">display</span>: flex;</div><div class="line">  flex-flow: row wrap;</div><div class="line">  <span class="comment">/* Выравнивает элементы по конечной точке главной оси*/</span></div><div class="line">  justify-content: flex-end;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* средние экраны */</span></div><div class="line">@media all and (max-width: <span class="number">800</span>px) &#123;</div><div class="line">  .navigation &#123;</div><div class="line">    <span class="comment">/* Центрируем меню, равномерно распределяя пространство вокруг элементов */</span></div><div class="line">    justify-content: space-around;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* малые экраны */</span></div><div class="line">@media all and (max-width: <span class="number">500</span>px) &#123;</div><div class="line">  .navigation &#123;</div><div class="line">    <span class="comment">/* Указываем направление column для выстраивания элементов в столбик*/</span></div><div class="line">    flex-direction: column;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p></p><p data-height="268" data-theme-id="0" data-slug-hash="pkwqH" data-default-tab="result" data-user="HugoGiraudel" class="codepen">See the Pen <a href="http://codepen.io/HugoGiraudel/pen/pkwqH/" target="_blank" rel="external">Demo Flexbox 2</a> by Hugo Giraudel (<a href="http://codepen.io/HugoGiraudel" target="_blank" rel="external">@HugoGiraudel</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p><p></p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>

<p>Поиграемся с гибкостью flex-элементов. Нам нужен макет из трёх колонок, с полноразмерным header и footer, и порядком, отличным от указанного в html-коде. Выстраиваем макет по принципу mobile-first: </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">.wrapper &#123;</div><div class="line">  <span class="attr">display</span>: flex;</div><div class="line">  flex-flow: row wrap;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* Задаём всем элементам ширину 100% */</span></div><div class="line">.header, .main, .nav, .aside, .footer &#123;</div><div class="line">  <span class="attr">flex</span>: <span class="number">1</span> <span class="number">100</span>%;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* В подходе mobile-first порядок следования элементов совпадает с указанным в html-документе</span></div><div class="line"> * в нашем случае:</div><div class="line"> * 1. header</div><div class="line"> * 2. nav</div><div class="line"> * 3. main</div><div class="line"> * 4. aside</div><div class="line"> * 5. footer</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="comment">/* средние экраны */</span></div><div class="line">@media all and (min-width: <span class="number">600</span>px) &#123;</div><div class="line">  <span class="comment">/* Указываем свойство flex, чтобы оба сайдбара выстроились в один ряд */</span></div><div class="line">  .aside &#123; <span class="attr">flex</span>: <span class="number">1</span> auto; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* большие экраны */</span></div><div class="line">@media all and (min-width: <span class="number">800</span>px) &#123;</div><div class="line">  <span class="comment">/* Меняем порядок следования первого сайдбара и main</span></div><div class="line">   * И задаём элементу main ширину в два раза больше ширины сайдбаров</div><div class="line">   */</div><div class="line">  .main &#123; <span class="attr">flex</span>: <span class="number">2</span> <span class="number">0</span>px; &#125;</div><div class="line">  </div><div class="line">  .aside<span class="number">-1</span> &#123; <span class="attr">order</span>: <span class="number">1</span>; &#125;</div><div class="line">  .main    &#123; <span class="attr">order</span>: <span class="number">2</span>; &#125;</div><div class="line">  .aside<span class="number">-2</span> &#123; <span class="attr">order</span>: <span class="number">3</span>; &#125;</div><div class="line">  .footer  &#123; <span class="attr">order</span>: <span class="number">4</span>; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p></p><p data-height="268" data-theme-id="0" data-slug-hash="qIAwr" data-default-tab="result" data-user="HugoGiraudel" class="codepen">See the Pen <a href="http://codepen.io/HugoGiraudel/pen/qIAwr/" target="_blank" rel="external">Demo Flexbox 3</a> by Hugo Giraudel (<a href="http://codepen.io/HugoGiraudel" target="_blank" rel="external">@HugoGiraudel</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p><p></p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>

<h3 id="Префиксы-для-Flexbox"><a href="#Префиксы-для-Flexbox" class="headerlink" title="Префиксы для Flexbox"></a>Префиксы для Flexbox</h3><p>Для поддержки во всех возможных браузерах Flexbox требует вендорных префиксов, причём не достаточно просто приставить к свойству вендорный префикс, иногда это совсем иные названия свойств и параметров. Связано это неудобство с изменениями, вносимыми в спецификацию Flexbox с течением времени, в результате чего появился <a href="http://css-tricks.com/old-flexbox-and-new-flexbox/" target="_blank" rel="external">«старый» и «новый» синтаксис flexbox</a> . </p>
<p>Проще всего обойти это неудобство, используя новый (и окончательный) синтаксис в связке с <a href="https://github.com/postcss/autoprefixer" target="_blank" rel="external">Autoprefixer</a> .</p>
<p>Или, в качестве альтернативы, можно использовать приведённый ниже Sass @mixin:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">@mixin flexbox() &#123;</div><div class="line">  <span class="attr">display</span>: -webkit-box;</div><div class="line">  display: -moz-box;</div><div class="line">  display: -ms-flexbox;</div><div class="line">  display: -webkit-flex;</div><div class="line">  display: flex;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@mixin flex($values) &#123;</div><div class="line">  -webkit-box-flex: $values;</div><div class="line">  -moz-box-flex:  $values;</div><div class="line">  -webkit-flex:  $values;</div><div class="line">  -ms-flex:  $values;</div><div class="line">  flex:  $values;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@mixin order($val) &#123;</div><div class="line">  -webkit-box-ordinal-group: $val;  </div><div class="line">  -moz-box-ordinal-group: $val;     </div><div class="line">  -ms-flex-order: $val;     </div><div class="line">  -webkit-order: $val;  </div><div class="line">  order: $val;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.wrapper &#123;</div><div class="line">  @include flexbox();</div><div class="line">&#125;</div><div class="line"></div><div class="line">.item &#123;</div><div class="line">  @include flex(<span class="number">1</span> <span class="number">200</span>px);</div><div class="line">  @include order(<span class="number">2</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Баги"><a href="#Баги" class="headerlink" title="Баги"></a>Баги</h3><p>Есть у Flexbox и ошибки. Наиболее полный их перечень можно найти у Филиппа Уолтона и Грега Витворта по <a href="https://github.com/philipwalton/flexbugs" target="_blank" rel="external">ссылке</a>.</p>
<h3 id="Браузерная-поддержка"><a href="#Браузерная-поддержка" class="headerlink" title="Браузерная поддержка"></a>Браузерная поддержка</h3><p>разбита по «версиям» flexbox:</p>
<p>новая (подразумевает последний синтаксис спецификации — напр., display: flex;)<br>промежуточная (неофициальный синтаксис 2011 года — напр., display: flexbox;)<br>старая (старый синтаксис 2009 года — напр., display: box;)</p>
<p><img src="/blog/images/table.png" alt="Иллюстрация блокнота"></p>
<p>Браузеры Blackberry 10+ поддерживают новый синтаксис.</p>
<p>Более полная информация о том, какой синтаксис лучше использовать для наиболее полной поддержки, можно изучить <a href="http://css-tricks.com/using-flexbox/" target="_blank" rel="external">эту</a> и <a href="https://dev.opera.com/articles/advanced-cross-browser-flexbox/#fallbacks" target="_blank" rel="external">эту</a> статьи. </p>
<h3 id="Дополнительная-информация-англ-источники"><a href="#Дополнительная-информация-англ-источники" class="headerlink" title="Дополнительная информация (англ источники)"></a>Дополнительная информация (англ источники)</h3><p><a href="http://www.w3.org/TR/css3-flexbox/" target="_blank" rel="external">Flexbox in the CSS specifications</a></p>
<p><a href="http://www.w3.org/TR/css3-flexbox/" target="_blank" rel="external">Flexbox at MDN</a></p>
<p><a href="https://dev.opera.com/articles/flexbox-basics/" target="_blank" rel="external">Flexbox at Opera</a></p>
<p><a href="http://bocoup.com/weblog/dive-into-flexbox/" target="_blank" rel="external">Diving into Flexbox by Bocoup</a></p>
<p><a href="http://css-tricks.com/using-flexbox/" target="_blank" rel="external">Mixing syntaxes for best browser support on CSS-Tricks</a></p>
<p><a href="http://www.alsacreations.com/tuto/lire/1493-css3-flexbox-layout-module.html" target="_blank" rel="external">Flexbox by Raphael Goetter (FR)</a></p>
<p><a href="http://bennettfeely.com/flexplorer/" target="_blank" rel="external">Flexplorer by Bennett Feely</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;div class=&quot;text-center&quot;&gt;&lt;br&gt;&lt;img src=&quot;/blog/images/flex2.jpg&quot; alt=&quot;Иллюстрация блокнота&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;br&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;О flex-контейнере и его свойствах поговорили в &lt;a href=&quot;https://makeomatic.ru/blog/2015/02/24/flexbox/&quot;&gt;части 1&lt;/a&gt;, теперь поговорим о дочерних элементах.&lt;/p&gt;
    
    </summary>
    
    
      <category term="CSS" scheme="https://makeomatic.ru/blog/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Flex-контейнер</title>
    <link href="https://makeomatic.ru/blog/2015/02/24/flexbox/"/>
    <id>https://makeomatic.ru/blog/2015/02/24/flexbox/</id>
    <published>2015-02-24T08:00:00.000Z</published>
    <updated>2016-01-08T17:55:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><div class="text-center"><br><img src="/blog/images/flex.png" alt="Иллюстрация блокнота"><br></div><br><br></p>
<p>В настоящий момент рабочая версия спецификации гибкого макета - Flexible Box Layout (сокращённо flexbox) - находится в стадии <a href="http://www.w3.org/TR/css3-flexbox/" target="_blank" rel="external">«Last Call»</a>, и всё стремительнее приближает к нам «светлое будущее». </p>
<a id="more"></a>
<p>Главная задача этой технологии— упростить расположение элементов на странице и их распределение, выравнивание относительно друг друга, в том числе динамических блоков, размеры которых заранее не известны (отсюда название «flex» - «гибкий»). </p>
<p>Основная идея «гибкого» макета - дать контейнеру возможность изменять ширину / высоту и порядок расположения его элементов, чтобы наиболее эффективно использовать доступное пространство (и для красивого отображения при любом размере экрана и на всех типах устройств). «Гибкий» контейнер это умеет: он способен увеличивать ширину элемента, чтобы заполнить свободное пространство, или, наоборот, уменьшать, во избежание overflow.</p>
<p>Что самое приятное — flexbox отлично работает с обеими осями x и y, в отличие от стандартных макетов, где block – ориентирован на вертикальное расположение, inline – на горизонтальное. Привычные решения хорошо работают с простыми страницами, но их явно не хватает для поддержки сложных приложений, особенно где предполагается ресайзинг, изменение ориентации области просмотра, растягивание/сжатие элементов на странице. </p>
<p>Совет: лучше всего использовать flexbox для отдельных компонентов приложения и простых макетов, в сложных макетах проще работать с модульными сетками. </p>
<h3 id="Основные-свойства-и-терминология"><a href="#Основные-свойства-и-терминология" class="headerlink" title="Основные свойства и терминология"></a>Основные свойства и терминология</h3><p>Flexbox – это целый набор CSS свойств, часть из которых применяются непосредственно к контейнеру (flex container), а часть — к его дочерним элементам (flex items). </p>
<p>Если в обычном макете направление задают свойства block и inline, то в гибком макете используется концепция осей (flex-flow), о которой и пойдёт речь.  </p>
<p><img src="/blog/images/flexbox.png" alt="Иллюстрация блокнота"></p>
<p>Итак, все элементы располагаются либо по оси main axis (начинается в точке main start, заканчивается в точке main end), либо по оси cross axis (от точки cross start до cross end соответственно). </p>
<ul>
<li>main axis – главная ось, задаёт направление, в соответствии с которым располагаются все элементы контейнера (обратите внимание, совсем не обязательно по горизонтали — направление зависит от свойства flex-direction, описанного ниже);</li>
<li>main start / main end – flex-элементы располагаются в контейнере вдоль главной оси, начинаясь в точке main start и до точки main end; </li>
<li>main size – ширина или высота flex-элемента (в зависимости от направления расположения);</li>
<li>cross axis – ось, перпендикулярная главной оси (соответственно, также может быть как горизонтальной, так и вертикальной — в зависимости от параметров главной оси);</li>
<li>cross start / cross end – flex-линии заполняются flex-элементами и помещаются в контейнер от точки cross start до cross end. </li>
<li>cross size – ширина / высота flex-элемента (опять же зависит от выбранного направления расположения элементов).</li>
</ul>
<h3 id="Свойства-flex-контейнера"><a href="#Свойства-flex-контейнера" class="headerlink" title="Свойства flex-контейнера"></a>Свойства flex-контейнера</h3><p><img src="/blog/images/flex-container.svg" alt="Иллюстрация блокнота"> </p>
<h4 id="Display"><a href="#Display" class="headerlink" title="Display"></a>Display</h4><p>Display определяет наш гибкий контейнер, блочный или инлайновый в зависимости от заданного параметра, и активирует flex-контекст для всех дочерних элементов контейнера (то есть делает их «резиновыми», а не блочными):</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.container &#123;</div><div class="line">  <span class="attr">display</span>: flex; <span class="comment">/* или inline-flex */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Примечание: колонки CSS не имеют никакого влияния на flex-контейнер. </p>
<h4 id="Flex-directon"><a href="#Flex-directon" class="headerlink" title="Flex-directon"></a>Flex-directon</h4><p><img src="/blog/images/flex-direction1.svg" alt="Иллюстрация блокнота"></p>
<p>Это свойство определяет главную ось, а значит и направление расположения flex-элементов. Flexbox – однонаправленный модуль, flex-элементы выстраиваются либо в горизонтальные ряды, либо в вертикальные колонки. </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.container &#123;</div><div class="line">  flex-direction: row | row-reverse | column | column-reverse;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>row (по умолчанию) - направление слева направо (в rtl - справа налево);</li>
<li>row-reverse – направление справа налево (в rtl – слева направо);</li>
<li>column – сверху вниз;</li>
<li>column-reverse – снизу вверх</li>
</ul>
<h4 id="Flex-wrap"><a href="#Flex-wrap" class="headerlink" title="Flex-wrap"></a>Flex-wrap</h4><p><img src="/blog/images/flex-wrap.svg" alt="Иллюстрация блокнота"></p>
<p>По умолчанию все flex-элементы будут сидеть на одной строке. Вы можете это изменять, меняя значение данного свойства. В зависимости от направления возможны следующие значения:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.container&#123;</div><div class="line">  flex-wrap: nowrap | wrap | wrap-reverse;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>nowrap (по умолчанию) — одна строка без переносов, слева направо (в rtl справа налево);</li>
<li>wrap – при необходимости блоки переносятся и располагаются в несколько рядов слева направо (в rtl справа налево);</li>
<li>wrap-reverse - при необходимости блоки переносятся и располагаются в несколько рядов справа налево (в rtl наоборот);</li>
</ul>
<h4 id="Flex-flow"><a href="#Flex-flow" class="headerlink" title="Flex-flow"></a>Flex-flow</h4><p>Это короткий вариант записи свойств flex-direction и flex-wrap, им одним можно задать направления главной и перпендикулярной осей вот так:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">flex-flow: <span class="xml"><span class="tag">&lt;<span class="name">‘flex-direction’</span>&gt;</span> || <span class="tag">&lt;<span class="name">‘flex-wrap’</span>&gt;</span> (по умолчанию — row nowrap)</span></div></pre></td></tr></table></figure>
<h3 id="Justify-content"><a href="#Justify-content" class="headerlink" title="Justify-content"></a>Justify-content</h3><p><img src="/blog/images/justify-content.svg" alt="Иллюстрация блокнота"></p>
<p>Это свойство задаёт выравнивание элементов по главной оси и помогает распределить свободное пространство между блоками, если они не резиновые или когда они достигли максимальной ширины.</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.container &#123;</div><div class="line">  justify-content: flex-start | flex-end | center | space-between | space-around;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>flex-start (по умолчанию) — элементы выравниваются от начальной точки главной оси;</li>
<li>flex-end – элементы выравниваются от конечной точки главной оси; </li>
<li>center – элементы выравниваются по центру главной оси; </li>
<li>space-between – элементы выравниваются с одинаковым пространством относительно друг друга, первый элемент прижат к начальной точке главной оси, последний — к конечной точке;  </li>
<li>space-around -  элементы выравниваются с одинаковым пространством вокруг себя. </li>
</ul>
<p>Визуально элементы не выглядят выравненными, поскольку у каждого элемента одинаковое пространство с обеих сторон: первый элемент будет иметь некое количество пространства от края контейнера, но между ним и следующим элементом будет два таких пространства, поскольку у следующего элемента также пространства с двух сторон. </p>
<h4 id="Align-items"><a href="#Align-items" class="headerlink" title="Align-items"></a>Align-items</h4><p><img src="/blog/images/align-items.svg" alt="Иллюстрация блокнота"></p>
<p>Это свойство задаёт выравнивание элементов по перпендикулярной оси (по сути — это то же самое, что и свойство justify-content, но для второй оси):</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> .container &#123;</div><div class="line">  align-items: flex-start | flex-end | center | baseline | stretch;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>flex-start -  элементы выравниваются от начальной точки перпендикулярной оси;</li>
<li>flex-end - элементы выравниваются от конечной точки поперечной оси;</li>
<li>center - элементы выравниваются по центру поперечной оси;</li>
<li>baseline - элементы выравниваются по baseline;</li>
<li>stretch (по умолчанию) – элементы растягиваются, занимая всю перпендикулярную ось (значения min-width/max-width при этом сохраняются — если указаны) </li>
</ul>
<h4 id="Align-content"><a href="#Align-content" class="headerlink" title="Align-content"></a>Align-content</h4><p><img src="/blog/images/align-content.svg" alt="Иллюстрация блокнота"></p>
<p>Это свойство выравнивает несколько рядов элементов в контейнере, когда есть дополнительное свободное пространство по перпендикулярной оси. </p>
<p>Примечание: данное свойство не работает, если в контейнере всего один ряд flex-элементов.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.container &#123;</div><div class="line">  align-content: flex-start | flex-end | center | space-between | space-around | stretch;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>flex-start – ряды элементов прижаты к верхнему краю контейнера;</li>
<li>flex-end - ряды элементов прижаты к нижнему краю контейнера;</li>
<li>center – ряды элементов расположены по центру контейнера; </li>
<li>space-between – первый ряд элементов прижат к верхнему краю, последний ряд — к нижнему краю, пространство равномерно распределено между рядами;</li>
<li>space-around – ряды элементов выравнены с одинаковым пространством вокруг каждого ряда; </li>
<li>stretch (по умолчанию) – ряды растянуты и занимают всё свободное пространство.</li>
</ul>
<h3 id="Примечание"><a href="#Примечание" class="headerlink" title="Примечание"></a>Примечание</h3><p>Со свойствами flex-контейнера — разобрались!<br>Во второй части изучим свойства дочерних flex-элементов, и напишем какой-нибудь комплексный примерчик. </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;div class=&quot;text-center&quot;&gt;&lt;br&gt;&lt;img src=&quot;/blog/images/flex.png&quot; alt=&quot;Иллюстрация блокнота&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;br&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;В настоящий момент рабочая версия спецификации гибкого макета - Flexible Box Layout (сокращённо flexbox) - находится в стадии &lt;a href=&quot;http://www.w3.org/TR/css3-flexbox/&quot;&gt;«Last Call»&lt;/a&gt;, и всё стремительнее приближает к нам «светлое будущее». &lt;/p&gt;
    
    </summary>
    
    
      <category term="CSS" scheme="https://makeomatic.ru/blog/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Полезное сквозное тестирование с Protractor</title>
    <link href="https://makeomatic.ru/blog/2015/01/17/Protractor_testing2/"/>
    <id>https://makeomatic.ru/blog/2015/01/17/Protractor_testing2/</id>
    <published>2015-01-17T08:00:00.000Z</published>
    <updated>2016-01-08T17:55:51.000Z</updated>
    
    <content type="html"><![CDATA[<div class="text-center"><br><img src="/blog/images/Protractor_testing2.jpg" alt="Тестирование с помощью Protractor"><br></div>

<h3 id="Тестируем-список-issues"><a href="#Тестируем-список-issues" class="headerlink" title="Тестируем список issues"></a>Тестируем список issues</h3><p>От тестов работы элемента <code>&lt;input&gt;</code> перейдём к тестам функционала нашего списка.</p>
<a id="more"></a>
<p><img src="/blog/images/listing.png" alt="Иллюстрация блокнота"></p>
<p>Поскольку все остальные тесты будут совершаться на странице списка, поместим их внутрь отдельного блока <code>describe()</code>. Это позволит добавить ещё один блок с <code>beforeEach()</code>. Для тестов возьмём репозиторий на гитхабе <code>angular/angular.js</code>.</p>
<p>Блок <code>describe()</code> будет вести себя, как пользователь, который заходит на главную страницу, заполняет поле ввода и жмёт enter. Вам может показаться излишним такой тест, но не забывайте, что сквозное тестирование и предполагает автоматизацию взаимодействия пользователя с системой.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">describe(<span class="string">'listing page'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  beforeEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    element(by.input(<span class="string">'repo.name'</span>)).sendKeys(<span class="string">'angular/angular.js\n'</span>);</div><div class="line">  &#125;);</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  <span class="comment">// тест списка будет здесь</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>На странице со списком <code>issues</code> будет ряд элементов, которые мы будем перебирать с помощью <code>ng-repeat</code>. Используя API GitHub, по умолчанию загрузим 30 issues. Соответственно, необходимо убедиться, что на странице реально появляется 30 вопросов.</p>
<p>Чтобы выбрать элемент в <code>ng-repeat</code>, воспользуемся опцией  <code>by.repeater()</code>. Этот метод перебирает директивы <code>ng-repeat</code> на странице и находит те, которые соответствуют заданному выражению. В данном случае мы задаём Angular выражение <code>d in data | orderBy:created_at:false</code> .</p>
<p>Соответственно, запускаем цикл:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">by.repeater(<span class="string">'d in data | orderBy:created_at:false'</span>)</div></pre></td></tr></table></figure>
<p>Можно как детально прописывать фильтры (что мы сделали выше), так и задать более общее выражение:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">by.repeater(<span class="string">'d in data'</span>);</div></pre></td></tr></table></figure>
<p>Метод <code>by.repeater()</code> возвращает ссылку на метод, извлекающий элементы, а не сами элементы. Поэтому, если мы попытаемся проверить объект, возвращенный by.repeater(), мы получим ошибку. Protractor устроен таким образом потому что он использует promises для асинхронных операций, поэтому для работы с полученными объектами мы должны использовать функцию <code>element.all()</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> elems = element.all(by.repeater(<span class="string">'d in data'</span>));</div></pre></td></tr></table></figure>
<p>Найдя элемент, чтобы подсчитать количество, применяем <code>count()</code> к объекту <code>element.all()</code>, и задаём ожидаемое количество — 30 элементов:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">it(<span class="string">'should have 30 issues'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> elems = element.all(by.repeater(<span class="string">'d in data'</span>));</div><div class="line">  expect(elems.count()).toBe(<span class="number">30</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Отлично, копнём глубже и убедимся, что для каждого из повторяющихся элементов отображается аватар. Логично предположить, что каждый элемент это, по сути, повтор предыдущего, поэтому создадим тест и проверим лишь один элемент.</p>
<p>Для получения элементов со страницы воспользуемся уже знакомым методом <code>by.repeater()</code>. Метод <code>element.all()</code> возвращает объект, содержащий несколько методов, которые  можем использовать для взаимодействия с повторяющимися элементами списка. В нашем случае, применим метод <code>first()</code> для нахождения первого элемента списка.</p>
<p>Поскольку список ещё не появился на странице, метод <code>first()</code> получает promise, который будет выполнен с появлением первого элемента.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">it(<span class="string">'includes a user gravatar per-element'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> elems = element.all(by.repeater(<span class="string">'d in data'</span>));</div><div class="line">  elems.first().then(<span class="function"><span class="keyword">function</span>(<span class="params">elm</span>) </span>&#123;</div><div class="line">    <span class="comment">// elm – первый элемент</span></div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Так как нам нужен конкретный дочерний элемент, применим метод <code>findElement()</code> для нахождения элемента <code>&lt;img&gt;</code>. Получить этот элемент можно разными методами, мы воспользуемся <code>by.tagName()</code>.  Как и в случае с методом <code>first()</code>, метод <code>findElement()</code> возвращает promise.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">it(<span class="string">'includes a user gravatar per-element'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> elems = element.all(by.repeater(<span class="string">'d in data'</span>));</div><div class="line">  elems.first().then(<span class="function"><span class="keyword">function</span>(<span class="params">elm</span>) </span>&#123;</div><div class="line">    elm.findElement(by.tagName(<span class="string">'img'</span>)).then(<span class="function"><span class="keyword">function</span>(<span class="params">img</span>) </span>&#123;</div><div class="line">      <span class="comment">// img - элемент &lt;img&gt;</span></div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Нам важно, чтобы атрибут src содержал URL граватара. Поэтому протестируем ещё глубже структуру элемента. Применим метод <code>getAttribute()</code> для нахождения атрибута src. Как и в двух предыдущих случаях, мы имеем дело с promises:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">it(<span class="string">'includes a user gravatar per-element'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> elems = element.all(by.repeater(<span class="string">'d in data'</span>));</div><div class="line">  elems.first().then(<span class="function"><span class="keyword">function</span>(<span class="params">elm</span>) </span>&#123;</div><div class="line">    elm.findElement(by.tagName(<span class="string">'img'</span>)).then(<span class="function"><span class="keyword">function</span>(<span class="params">img</span>) </span>&#123;</div><div class="line">      img.getAttribute(<span class="string">'src'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">src</span>) </span>&#123;</div><div class="line">        <span class="comment">// src - источник текста</span></div><div class="line">      &#125;);</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Получив атрибут src, зададим ожидание, что он соответствует <code>gravatar.com</code>, поскольку на гитхабе используется именно Gravatar.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">it(<span class="string">'includes a user gravatar per-element'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> elems = element.all(by.repeater(<span class="string">'d in data'</span>));</div><div class="line">  elems.first().then(<span class="function"><span class="keyword">function</span>(<span class="params">elm</span>) </span>&#123;</div><div class="line">    elm.findElement(by.tagName(<span class="string">'img'</span>)).then(<span class="function"><span class="keyword">function</span>(<span class="params">img</span>) </span>&#123;</div><div class="line">      img.getAttribute(<span class="string">'src'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">src</span>) </span>&#123;</div><div class="line">        expect(src).toMatch(<span class="regexp">/gravatar\.com\/avatar/</span>);</div><div class="line">      &#125;);</div><div class="line">    &#125;)</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="Тестируем-навигацию"><a href="#Тестируем-навигацию" class="headerlink" title="Тестируем навигацию"></a>Тестируем навигацию</h3><p>Последняя часть функционала, которую необходимо протестировать — навигация. Как и прежде, мы привяжем наши тесты к действиям, совершаемым на странице. В данном случае, протестируем ссылку <code>/about</code>, используя CSS и click по ссылке.</p>
<p>Наш HTML выглядит следующим образом:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;div class="header"&gt;</div><div class="line">  &lt;ul class="nav"&gt;</div><div class="line">    &lt;li ng-class="&#123;'active': isCurrentPage('')&#125;"&gt;&lt;a id="homelink" ng-href="#"&gt;Home&lt;/a&gt;&lt;/li&gt;</div><div class="line">    &lt;li ng-class="&#123;'active': isCurrentPage('about')&#125;"&gt;&lt;a id='aboutlink' ng-href="#/about"&gt;About&lt;/a&gt;&lt;/li&gt;</div><div class="line">  &lt;/ul&gt;</div><div class="line">  &lt;h3 class="text-muted"&gt;protractorer&lt;/h3&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>Ссылка <code>/about</code> — второй элемент в списке <code>header.nav</code>. Наиболее просто выбрать список с помощью селектора CSS и метода <code>by.css()</code>.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">it(<span class="string">'should navigate to the /about page when clicking'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> link = element(by.css(<span class="string">'.header ul li:nth-child(2)'</span>))</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Теперь у нас есть ссылка, на которую можно кликнуть, чтобы попасть на новую страницу. Переместившись на страницу <code>/about</code>, следует убедиться, что содержание страницы отображается или что url содержит путь <code>/about</code>. Поскольку мы подразумеваем, что Angular роутер работает как положено, очевидно, что страница будет грузиться, если url страницы ведёт на <code>/about</code>. Поэтому просто проверяем последнее условие. Получим url с помощью метода <code>getCurrentUrl()</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">it(<span class="string">'should navigate to the /about page when clicking'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  element(by.css(<span class="string">'.header ul li:nth-child(2)'</span>)).click();</div><div class="line">  expect(ptor.getCurrentUrl()).toMatch(<span class="regexp">/\/about/</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Наконец, тк мы тестируем клиентский интерфейс, ожидаем, что к ссылке будет добавляться класс <code>active</code>, который вешает на кнопку новый стиль color.</p>
<p>Запускаем то же действие, что и раньше — клик по ссылке <code>/about</code>. Всякий раз, когда мы дублируем код, разумно вложить тесты в отдельный блок <code>describe()</code>, и переместить туда дублируемый код. Переместим наши тесты в блок <code>describe()</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">describe(<span class="string">'page navigation'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> link;</div><div class="line">  beforeEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    link = element(by.css(<span class="string">'.header ul li:nth-child(2)'</span>));</div><div class="line">    link.click();</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  it(<span class="string">'should navigate to the /about page when clicking'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    expect(ptor.getCurrentUrl()).toMatch(<span class="regexp">/\/about/</span>);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  it(<span class="string">'should add the active class when at /about'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// должен иметь класс active</span></div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Последний тест проверяет, что список классов содержит строку <code>active</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">expect(link.getAttribute(<span class="string">'class'</span>)).toMatch(<span class="regexp">/active/</span>);<span class="string">`</span></div></pre></td></tr></table></figure>
<h3 id="Ещё-аргументы"><a href="#Ещё-аргументы" class="headerlink" title="Ещё аргументы?"></a>Ещё аргументы?</h3><p>Protractor – очень мощный инструмент для e2e тестирования, активно развивающийся на гитхабе. Вскоре он заменит Karma, став официальным фреймворком для Angular.</p>
<p>Исходный код тестов доступен по <a href="http://j.mp/1m4xdma" target="_blank" rel="external">ссылке</a>.<br>Спасибо за внимание, и продуктивного тестирования!</p>
]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;text-center&quot;&gt;&lt;br&gt;&lt;img src=&quot;/blog/images/Protractor_testing2.jpg&quot; alt=&quot;Тестирование с помощью Protractor&quot;&gt;&lt;br&gt;&lt;/div&gt;

&lt;h3 id=&quot;Тестируем-список-issues&quot;&gt;&lt;a href=&quot;#Тестируем-список-issues&quot; class=&quot;headerlink&quot; title=&quot;Тестируем список issues&quot;&gt;&lt;/a&gt;Тестируем список issues&lt;/h3&gt;&lt;p&gt;От тестов работы элемента &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; перейдём к тестам функционала нашего списка.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="https://makeomatic.ru/blog/tags/Javascript/"/>
    
      <category term="AngularJS" scheme="https://makeomatic.ru/blog/tags/AngularJS/"/>
    
  </entry>
  
  <entry>
    <title>Эффективное сквозное тестирование с Protractor</title>
    <link href="https://makeomatic.ru/blog/2015/01/05/Protractor_testing/"/>
    <id>https://makeomatic.ru/blog/2015/01/05/Protractor_testing/</id>
    <published>2015-01-05T08:00:00.000Z</published>
    <updated>2016-01-08T17:55:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/images/Protractor_testing.png" alt="Иллюстрация блокнота"></p>
<p>С AngularJS действительно удобно работать, поскольку тестам изначально придаётся большое значение - каждое изменение, внесённое в исходники, тестируется перед сохранением в ядро.</p>
<a id="more"></a>
<p>Тестирование крайне важно, особенно в Javascript - языке с динамической проверкой типов. Тесты позволяют отловить ошибки до того, как они попадут в продакшн. Уже не говоря о том, что они повышают качество кода.</p>
<p>Баги неизбежны в любом коде, и наша задача уметь их отыскать и постараться починить до  того, как они проявят себя в конечном продукте. В тестовой среде появляется возможность изолировать части функционала и «пощупать» приложение изнутри.</p>
<h4 id="Тестирование-—-неотъемлемая-часть-работы-если-мы-хотим-понимать-что-происходит-в-приложении"><a href="#Тестирование-—-неотъемлемая-часть-работы-если-мы-хотим-понимать-что-происходит-в-приложении" class="headerlink" title="Тестирование — неотъемлемая часть работы, если мы хотим понимать, что происходит в приложении."></a>Тестирование — неотъемлемая часть работы, если мы хотим понимать, что происходит в приложении.</h4><p>В данной статье мы рассмотрим сквозное (e2e) тестирование приложений. Сквозное тестирование — это поведенческое тестирование по методу «чёрного ящика» (проверка выполнения приложением заданных функциональных требований, при которой не используются знания о внутренней структуре тестируемого объекта). То есть мы тестируем, что система работает, как планировалось, с точки зрения конечного пользователя.</p>
<p>Пользователю всё равно, работает ли приложение «как планировалось», ему важно, чтобы функционал работал в соответствии с его собственными ожиданиями. Тестирование по сути это  автоматизированный запуск приложения в браузере и последовательные действия, проверяющие весь функционал пользовательского интерфейса. Совершать все эти действия вручную было бы крайне неэффективно, поэтому создадим автоматические тесты.</p>
<h3 id="Автоматизация-с-помощью-Protractor"><a href="#Автоматизация-с-помощью-Protractor" class="headerlink" title="Автоматизация с помощью Protractor"></a>Автоматизация с помощью Protractor</h3><p>Protractor –  рекомендуемый фреймворк для сквозного тестирования.  В отличие от стандартного исполнителя сценариев Angular, Protractor сделан на основе Selenium <a href="https://code.google.com/p/selenium/wiki/WebDriverJs" target="_blank" rel="external">WebDriver</a> - инструмента для автоматизированного тестирования веб-приложений, с API и набором расширений, позволяющих управлять поведением браузера. Расширения WebDriver есть для всех типов браузеров, включая наиболее популярные. Таким образом, мы получаем быстрое и стабильное тестирование в реальной браузерной среде.</p>
<p>К счастью, Protractor работает в связке с Jasmine, так что тем, кто знаком с этим фреймворком, не придётся изучать новый. Но можно установить его и как самостоятельный исполнитель тестов или использовать как библиотеку.</p>
<h3 id="Установка"><a href="#Установка" class="headerlink" title="Установка"></a>Установка</h3><p>В отличие от стандартного исполнителя сценариев, для работы Protractor нужно запустить отдельный сервер по адресу  <code>http://location:4444</code> (можно перенастроить). К счастью, в дистрибутиве Protractor имеется утилита, упрощающая процесс установки Selenium Server. Чтобы воспользоваться скриптом, необходимо установить Protractor локально в корневой каталог тестируемого Angular приложения.</p>
<p><code>$ npm install protractor</code></p>
<p>Далее запускаем скрипт-загрузчик Selenium (расположен в локальном каталоге <code>node_modules/</code>) командой:</p>
<p><code>$ ./node_modules/protractor/bin/webdriver-manager update</code></p>
<p>Этот скрипт загружает файлы, необходимые для запуска Selenium, и создаёт соответствующий каталог. Когда всё загружено, запускаем Selenium с драйвером Chrome командой старт:</p>
<p><code>$ ./node_modules/protractor/bin/webdriver-manager start</code></p>
<p>Если у вас возникают проблемы при запуске Selenium, попробуйте обновить ChromeDriver, загрузив последнюю версию <a href="http://chromedriver.storage.googleapis.com/" target="_blank" rel="external">здесь</a>.</p>
<p>Теперь можем работать с Protractor, подключившись к серверу Selenium, который работает в фоновом режиме.</p>
<h3 id="Настройка"><a href="#Настройка" class="headerlink" title="Настройка"></a>Настройка</h3><p>Наподобие таск-раннера Karma, для запуска и работы с Selenium нужен конфигурационный файл.  Наиболее простой способ создания конфигурационного файла Protractor - скопировать базовую конфигурацию из каталога установки.</p>
<p><code>$ cp ./node_modules/protractor/example/chromeOnlyConf.js protractor_conf.js</code></p>
<p>Для старта Protractor в файле необходимо сделать несколько изменений. Во-первых,  по умолчанию конфигурационный файл использует драйвер Chrome, которого нет в текущей директории. Поэтому мы должны указать путь к драйверу в локальной папке <code>./node_modules</code>.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chromeDriver: <span class="string">'./node_modules/protractor/selenium/chromedriver'</span>,</div></pre></td></tr></table></figure>
<p>Далее нужно изменить путь массива specs, указав на наши локальные тесты.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">specs: [<span class="string">'test/e2e/**/*_spec.js'</span>],</div></pre></td></tr></table></figure>
<p>При настройке тестов в Protractor существует множество различных параметров конфигурации. В этой статье мы затронем некоторые из них, но помните, что существует и немало других опций.</p>
<p>Есть два варианта запуска тестов. Первый, автономный режим — использовать Protractor для запуска Selenium, когда запускаем наши тесты. Пример файла конфигурации в данной статье использует этот метод.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chromeOnly: <span class="literal">true</span>,</div><div class="line"><span class="attr">chromeDriver</span>: <span class="string">'./node_modules/protractor/selenium/chromedriver'</span>,</div></pre></td></tr></table></figure>
<p>Второй вариант предполагает подключение к отдельно запущенному серверу Selenium. Когда тесты становятся более сложными, вероятно, целесообразнее использовать этот вариант.</p>
<p>В этом случае нужно удалить указанные выше настройки (chromeOnly и chromeDriver), и добавить параметр seleniumAddress, указывающий путь к запущенному серверу Selenium:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">seleniumAddress: <span class="string">'http://0.0.0.0:4444/wd/hub'</span>,</div></pre></td></tr></table></figure>
<h3 id="Написание-тестов"><a href="#Написание-тестов" class="headerlink" title="Написание тестов"></a>Написание тестов</h3><p>При написании тестов в Protractor используется фреймворк Jasmine. То есть мы пишем тесты точно так же, как для Karma. Пример простого теста в Protractor:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">describe(<span class="string">'homepage'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  beforeEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// функция before</span></div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  it(<span class="string">'should load the page'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// далее тест</span></div><div class="line">    expect(...).toEqual(<span class="string">'hello'</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>В примере приведён не полный код, но структура узнаваема — синтаксис Jasmine. Для создания структуры тестов используем функции <code>beforeEach()</code>, <code>afterEach()</code>  и вложенные блоки <code>describe()</code>. Для выполнения тестов используем синтаксис Jasmine – <code>expect()</code>.<br>При написании тестов в Protractor нам понабодятся некоторые его глобальные переменные. Ниже приведены некоторые из них.<br>browser – оболочка вебдрайвера, используется для навигации и получения информации о странице.</p>
<h4 id="Browser"><a href="#Browser" class="headerlink" title="Browser"></a>Browser</h4><p>Можем использовать переменную browser для перехода на страницу с помощью функции <code>get()</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">beforeEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  browser.get(<span class="string">'http://127.0.0.1:9000/'</span>);</div><div class="line">&#125;);</div><div class="line">С объектом browser можно также проделывать разные штуки. Например, дебаггинг с помощью метода <span class="keyword">debugger</span>() :</div><div class="line">it(<span class="string">'should find title element'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  browser.get(<span class="string">'app/index.html'</span>);</div><div class="line"></div><div class="line">  browser.debugger();</div><div class="line"></div><div class="line">  element(by.binding(<span class="string">'user.name'</span>));</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Для использования этого теста в отладчике node, запускаем его в режиме отладки:</p>
<p><code>$ protractor debug conf.js</code></p>
<p>Запуская Protractor в режиме отладки, мы получаем бонус — выполнение в браузере останавливается, и теперь все клиентские скрипты Protractor доступны нам из консоли. Чтобы получить к ним доступ, нужно вызвать объект Protractor – <code>window.clientSideScripts.</code></p>
<h3 id="Начнём-тестировать"><a href="#Начнём-тестировать" class="headerlink" title="Начнём тестировать!"></a>Начнём тестировать!</h3><p>Можно долго рассказывать о том, для чего нужно использовать Protractor, гораздо сложнее его нормально настроить. Тк мы стремимся к высокому качеству материалов по Angular, давайте уже углубимся в тестирование приложения и различные стратегии.</p>
<h3 id="Наше-приложение"><a href="#Наше-приложение" class="headerlink" title="Наше приложение"></a>Наше приложение</h3><p>Давайте для примера возьмём приложение, реализующее свой вариант просмотра <a href="https://github.com/" target="_blank" rel="external">Github issues</a>. Простое приложение, у которого всего несколько функций:</p>
<ul>
<li>Оно позволяет указывать владельца репозитория и URL через окно ввода;</li>
<li>В нём имеется главная страница и страница About;</li>
<li>issues упорядочены друг под другом;</li>
<li>используется Gravatar пользователя.</li>
</ul>
<p>Наше конечное приложение выглядит вот так (картинка 1 a, b - из статьи):</p>
<p><img src="/blog/images/protractor1.png" alt="Иллюстрация блокнота"></p>
<p><img src="/blog/images/protractor2.png" alt="Иллюстрация блокнота"></p>
<p>При написании тестов для каждого приложения необходимо продумать стратегию.  Можно написать слишком много тестов для очень простого приложения, а можно, наоборот, слишком мало. Найдя правильный баланс между двумя крайностями, мы здорово поможем себе, когда возьмёмся за реализацию приложения и тестов к нему.  </p>
<h3 id="Стратегия-тестирования"><a href="#Стратегия-тестирования" class="headerlink" title="Стратегия тестирования"></a>Стратегия тестирования</h3><p>По опыту, наилучший баланс между написанием тестов и написанием кода достигается тогда, когда вы чётко понимаете, что тестировать и как именно тестировать. Когда мы пишем тест, важно, чтобы он проверял именно то поведение, которое задумано. То есть, мы не должны писать тест, чтобы проверить, меняется ли содержание тэга <code>h1</code>,  потому что мы вводим текст в поле <code>&lt;input&gt;</code>.  А вот проверить фильтрацию нашей фичи «поиск в режиме реального времени» (Live Search) нужно.</p>
<p>Мы пришли к выводу, что писать тесты заранее, на стадии прототипирования, не имеет смысла. В этой стадии можно написать пару тестов максимум, потому что мы всё ещё продумываем функции нашего приложения. А вот по мере роста приложения уже стоит писать больше тестов, чтобы убедиться, что оно ведёт себя так, как задумано в продакшене.</p>
<p>Наконец, нужно структурировать тесты так, чтобы каждый блок проверял какую-то свою, очень маленькую задачу. В идеале тест должен проверять не более 1 ожидаемого события.</p>
<p>Ну, хватит теории, применим стратегию на практике.</p>
<p>Во-первых, нужно проверить, что наше приложение добавляет название репозитория, с которым мы будем работать. Используя функционал Angular, приложение делает <code>http</code> запрос к <code>github.com</code>. Этот запрос возвращается, и мы заполняем оставшиеся поля главной страницы.</p>
<p>Во-вторых, необходимо протестировать изменение навигации и содержания страницы. Этот тест предполагает нажатие навигационной кнопки для изменения местоположения <code>$location</code>.</p>
<p>Поехали!</p>
<h3 id="Создаём-первые-тесты"><a href="#Создаём-первые-тесты" class="headerlink" title="Создаём первые тесты"></a>Создаём первые тесты</h3><p>Наш файл конфигурации Protractor довольно прост и почти не отличается от базового конфига, который поставляется при установке:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// пример файла конфигурации</span></div><div class="line">exports.config = &#123;</div><div class="line">  <span class="attr">seleniumAddress</span>: <span class="string">'http://0.0.0.0:4444/wd/hub'</span>,</div><div class="line">  <span class="attr">capabilities</span>: &#123; <span class="string">'browserName'</span>: <span class="string">'chrome'</span> &#125;,</div><div class="line">  <span class="attr">specs</span>: [<span class="string">'test/e2e/**/*.spec.js'</span>],</div><div class="line">  <span class="attr">jasmineNodeOpts</span>: &#123;</div><div class="line">    <span class="attr">showColors</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">defaultTimeoutInterval</span>: <span class="number">30000</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>Будем писать тесты в папке <code>test/e2e</code>, как и указали в конфигурационном файле в виде <code>[name].spec.js</code>. Создадим наш первый тест под названием <code>main.spec.js</code>.</p>
<p>Набросаем простую «рыбу»:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// в test/e2e/main.spec.js</span></div><div class="line">describe(<span class="string">'E2E: main page'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// здесь будут наши тесты</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Тк мы пишем тесты на фреймворке Jasmine, воспользуемся блоком <code>beforeEach()</code>. Также необходимо отслеживать экземпляр Protractor, создадим для этого переменную <code>ptor</code>. Для каждого теста будем использовать объект browser для перехода на главную страницу.</p>
<p>При сквозном тестировании,  нужен запущенный сервер, на котором будут осуществляться наши тесты.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">describe(<span class="string">'E2E: main page'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> ptor;</div><div class="line"></div><div class="line">  beforeEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    browser.get(<span class="string">'http://127.0.0.1:9000/'</span>);</div><div class="line">    ptor = protractor.getInstance();</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Вместо того, чтобы указывать полный URL каждый раз, когда хотим протестировать страницу, можем добавить параметр <code>baseUrl</code> в конфигурационный файл Protractor. Далее будем считать, что этот параметр в конфиге у нас выглядит так:</p>
<p><code>baseUrl: &#39;http://127.0.0.1:9000/&#39;,</code></p>
<p>Первый тест убедится, что главная страница загружается: проверим наличие элемента на странице. Поскольку на главной странице есть идентификатор  #home, создадим ожидание, проверяющее наше условие.</p>
<p>Сначала выберем <code>&lt;div&gt;</code> с идентификатором <code>#main</code> с помощью функции <code>by.id()</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">it(<span class="string">'should load the home page'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> ele = by.id(<span class="string">'home'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Получив нужный элемент, с помощью Protractor метода <code>isElementPresent()</code>: зададим ожидание, проверяющее присутствие элемента на странице:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">it(<span class="string">'should load the home page'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> ele = by.id(<span class="string">'home'</span>);</div><div class="line">  expect(ptor.isElementPresent(ele)).toBe(<span class="literal">true</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Для тестирования необходимо запустить сервер Selenium. К счастью, <code>webdriver-manager</code> облегчает нам жизнь (эта утилита автоматически включена в Protractor). Итак, запускаем  <code>webdriver-manager</code>:</p>
<p><code>$ ./node_modules/protractor/bin/webdriver-manager start</code></p>
<p>Запускаем Protractor в новом терминале. Двоичный файл <code>Protractor</code> принимает один аргумент — конфигурационный файл:</p>
<p><code>$ ./node_modules/protractor/bin/protractor protractor_conf.js</code></p>
<p><img src="/blog/images/protractor3.png" alt="Иллюстрация блокнота"></p>
<h3 id="Тестируем-поле-ввода"><a href="#Тестируем-поле-ввода" class="headerlink" title="Тестируем поле ввода"></a>Тестируем поле ввода</h3><p>Приступим к тестированию <code>&lt;input&gt;</code>.  Главная страница загружает одну форму с одним полем ввода, которое отображается, если пользователь сам не выбрал репозиторий для поиска issues. <code>input type=&quot;text&quot;</code> привязан к модели <code>repoName</code>. После заполнения, форма исчезает и появляется нужный список issues.</p>
<p><img src="/blog/images/protractor5.png" alt="Иллюстрация блокнота"></p>
<p>HTML выглядит так:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;div id=<span class="string">"repoform"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"main"</span> ng-<span class="keyword">if</span>=<span class="string">"!repoName"</span>&gt;</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">ng-submit</span>=<span class="string">"getIssues()"</span> <span class="attr">class</span>=<span class="string">"input-group"</span>&gt;</span></span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"input-group"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">ng-model</span>=<span class="string">'repo.name'</span> <span class="attr">placeholder</span>=<span class="string">'Enter repo name'</span> /&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"input-group-btn"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">class</span>=<span class="string">"btn btn-primary"</span> <span class="attr">value</span>=<span class="string">"Search"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Нам важно протестировать, что заполненная форма исчезает, и на её месте появляется нужный список issues. Поэтому в следующем тесте  выбираем элемент <code>&lt;input&gt;</code> и заполняем его, для этого применим к нему метод <code>sendKeys()</code>. Для выделения самого элемента <code>input</code> воспользуемся методом  <code>by.input()</code> , который найдёт элементы <code>&lt;input&gt;</code>, содержащие привязку к <code>ng-model</code>:</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> it(<span class="string">'the input box should go away on submit'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  element(by.input(<span class="string">'repo.name'</span>)).sendKeys(<span class="string">'angular/angular.js\n'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>При прогоне этого теста увидим, что  поле <code>&lt;input&gt;</code> заполняется. Никаких ожиданий нет, тк мы их ещё не написали, но видим, что в поле ввода появляется <code>angular/angular.js</code>.  </p>
<p>Чтобы поле ввода исчезло, нужно отправить заполненную форму. Наиболее просто это сделать, сымитировав нажатие клавиши enter. Поэтому в методе <code>sendKeys()</code> добавили сочетание <code>\n</code> , которое имитирует нажатие enter в элементе <code>&lt;input&gt;</code>.  </p>
<p>Теперь осталось написать ожидание, что элемент <code>repoForm</code> более не существует на странице (тк мы прячем его с помощью <code>ng-if</code>).</p>
<p>Используем для этого упомянутый ранее метод:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">it(<span class="string">'the input box should go away on submit'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  element(by.input(<span class="string">'repo.name'</span>)).sendKeys(<span class="string">'angular/angular.js\n'</span>);</div><div class="line">  expect(ptor.isElementPresent(by.id(<span class="string">'repoform'</span>))).toBe(<span class="literal">false</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>В части 2 мы протестируем список <code>&lt;issues&gt;</code> и навигацию. Держите руку на пульсе!</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/images/Protractor_testing.png&quot; alt=&quot;Иллюстрация блокнота&quot;&gt;&lt;/p&gt;
&lt;p&gt;С AngularJS действительно удобно работать, поскольку тестам изначально придаётся большое значение - каждое изменение, внесённое в исходники, тестируется перед сохранением в ядро.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="https://makeomatic.ru/blog/tags/Javascript/"/>
    
      <category term="AngularJS" scheme="https://makeomatic.ru/blog/tags/AngularJS/"/>
    
  </entry>
  
  <entry>
    <title>Замена конструкции switch на объектные литералы</title>
    <link href="https://makeomatic.ru/blog/2014/12/17/Switch_statement/"/>
    <id>https://makeomatic.ru/blog/2014/12/17/Switch_statement/</id>
    <published>2014-12-17T08:00:00.000Z</published>
    <updated>2016-01-08T17:55:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/images/switch.jpg" alt="Иллюстрация блокнота"><br>Во многих языках программирования есть конструкция <code>switch</code> – но стоит ли её применять?</p>
<p>Если вы JS-программист, вы постоянно работаете с объектами: создаёте, инициализируете и совершаете с ними разные манипуляции. Объекты очень гибкие — в javascript практически всё на них построено, и именно их я в последнее время использую вместо <code>switch</code>.<br><a id="more"></a></p>
<h3 id="Что-такое-конструкция-switch"><a href="#Что-такое-конструкция-switch" class="headerlink" title="Что такое конструкция switch?"></a>Что такое конструкция switch?</h3><p>Если вы ранее не использовали <code>switch</code> или не очень понимаете, что данная конструкция делает, давайте разберёмся. <code>Switch</code> последовательно сравнивает выражение со всеми указанными константами и выводит найденное соответствие, например, исполняемый блок кода.</p>
<p>Взглянем на типичное использование <code>switch</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> type = <span class="string">'coke'</span>;</div><div class="line"><span class="keyword">var</span> drink;</div><div class="line"><span class="keyword">switch</span>(type) &#123;</div><div class="line"><span class="keyword">case</span> <span class="string">'coke'</span>:</div><div class="line">  drink = <span class="string">'Coke'</span>;</div><div class="line">  <span class="keyword">break</span>;</div><div class="line"><span class="keyword">case</span> <span class="string">'pepsi'</span>:</div><div class="line">  drink = <span class="string">'Pepsi'</span>;</div><div class="line">  <span class="keyword">break</span>;</div><div class="line"><span class="keyword">default</span>:</div><div class="line">  drink = <span class="string">'Unknown drink!'</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(drink); <span class="comment">// 'Coke'</span></div></pre></td></tr></table></figure>
<p>Напоминает условную конструкцию <code>else</code> и <code>if</code>, но <code>switch</code> сравнивает с одним значением в каждом случае <code>case</code> нашей конструкции.<br>Когда в коде много условий <code>else if</code>, вероятно, что-то не так – в подобных случаях целесообразнее использовать <code>switch</code>. Вот пример злоупотребления <code>else if</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">getDrink</span> (<span class="params">type</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (type === <span class="string">'coke'</span>) &#123;</div><div class="line">    type = <span class="string">'Coke'</span>;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">'pepsi'</span>) &#123;</div><div class="line">    type = <span class="string">'Pepsi'</span>;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">'mountain dew'</span>) &#123;</div><div class="line">    type = <span class="string">'Mountain Dew'</span>;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">'lemonade'</span>) &#123;</div><div class="line">    type = <span class="string">'Lemonade'</span>;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">'fanta'</span>) &#123;</div><div class="line">    type = <span class="string">'Fanta'</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// выступает в качестве «дефолтного» значения</span></div><div class="line">    type = <span class="string">'Unknown drink!'</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="string">'You\'ve picked a '</span> + type;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Данный вариант — слишком общий, допускает ошибки и крайне многословен (повторы). Он допускает и всякие хаки, тк можно сравнивать несколько значений в каждом <code>else if</code>, например: <code>else if (type === &#39;coke&#39; &amp;&amp; somethingElse !== &#39;apples&#39;)</code>. В таких ситуациях <code>switch</code> был идеальным решением, хотя и приходилось не забывать добавлять оператор <code>break</code>; в конце каждого случая case для предотвращения автоматического исполнения кода следующего case (частая ошибка switch).  </p>
<h3 id="Проблемы-switch"><a href="#Проблемы-switch" class="headerlink" title="Проблемы switch"></a>Проблемы switch</h3><p>В использовании <code>switch</code> есть много неприятных моментов: процедурный поток управления, нестандартный синтактис блоков кода — в javascript стандартно используются фигурные скобки,  в конструкции <code>switch</code> – нет. В целом, синтаксис <code>switch</code> – не лучший пример javascript. Мы вынуждены вручную добавлять break для каждого case, что может усложнить дальнейшую отладку ошибок, а если где-то забудем break, это спровоцирует ошибки в последующих случаях case. Дуглас Крокфорд не раз об этом писал и рассказывал, он рекомендует использовать <code>switch</code> с осторожностью.</p>
<p>В javascript мы часто обращаемся к объектам для решения всевозможных задач, включая те, для которых нам бы и в голову не пришло использовать <code>switch</code>. Так почему бы не использовать объектный литерал вместо <code>switch</code>? Это сделает наш код более гибким, читаемым, поддерживаемым, и не нужно будет вручную добавлять к кейсам break! Также это упрощает работу новичкам, поскольку это стандартные объекты.</p>
<p>По мере увеличения количества case производительность объектов (хэш-таблиц) становится лучше, чем у конструкции <code>switch</code> (где важна последовательность кэйсов). Объектный подход это поиск по хеш-таблицам, а конструкция <code>switch</code> должна оценивать каждый case, пока не найдёт соответствие и <code>break</code>.</p>
<h3 id="Поиск-по-объектным-литералам"><a href="#Поиск-по-объектным-литералам" class="headerlink" title="Поиск по объектным литералам"></a>Поиск по объектным литералам</h3><p>Мы постоянно используем объекты как конструкторы или литералы, часто для операций поиска — получения значений свойств объекта.<br>Создадим простой объект, который возвращает только строковое значение:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDrink</span> (<span class="params">type</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> drinks = &#123;</div><div class="line">    <span class="string">'coke'</span>: <span class="string">'Coke'</span>,</div><div class="line">    <span class="string">'pepsi'</span>: <span class="string">'Pepsi'</span>,</div><div class="line">    <span class="string">'lemonade'</span>: <span class="string">'Lemonade'</span>,</div><div class="line">    <span class="string">'default'</span>: <span class="string">'Default item'</span></div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">return</span> <span class="string">'The drink I chose was '</span> + (drinks[type] || drinks[<span class="string">'default'</span>]);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> drink = getDrink(<span class="string">'coke'</span>);</div><div class="line"><span class="comment">// The drink I chose was Coke</span></div><div class="line"><span class="built_in">console</span>.log(drink);</div></pre></td></tr></table></figure>
<p>Наш код на пару строк короче, чем пример со <code>switch</code>, и, мне кажется, лучше читается. Упростим его, убрав дефолтное значение:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDrink</span> (<span class="params">type</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">'The drink I chose was '</span> + &#123;</div><div class="line">    <span class="string">'coke'</span>: <span class="string">'Coke'</span>,</div><div class="line">    <span class="string">'pepsi'</span>: <span class="string">'Pepsi'</span>,</div><div class="line">    <span class="string">'lemonade'</span>: <span class="string">'Lemonade'</span></div><div class="line">  &#125;[type];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Однако, нам может понадобиться более сложное значение, чем строка, способное храниться в функции. Для краткости и простоты, я верну эти же строки в только что созданные функции:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> type = <span class="string">'coke'</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> drinks = &#123;</div><div class="line">  <span class="string">'coke'</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'Coke'</span>;</div><div class="line">  &#125;,</div><div class="line">  <span class="string">'pepsi'</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'Pepsi'</span>;</div><div class="line">  &#125;,</div><div class="line">  <span class="string">'lemonade'</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'Lemonade'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>Разница в том, что нам нужно вызвать функцию объекта:<br><code>drinks[type]();</code></p>
<p>Такой код - легче поддерживать, приятнее читать. Простой объект. Можно забыть про <code>break</code> и ошибки, связанные с его отсутствием в конце case.</p>
<p>В случае со <code>switch</code> мы бы поместили его в функцию и <code>return</code> значение, сделаем то же самое с объектом, превратив его в практичную функцию:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDrink</span> (<span class="params">type</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> drinks = &#123;</div><div class="line">    <span class="string">'coke'</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="string">'Coke'</span>;</div><div class="line">    &#125;,</div><div class="line">    <span class="string">'pepsi'</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="string">'Pepsi'</span>;</div><div class="line">    &#125;,</div><div class="line">    <span class="string">'lemonade'</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="string">'Lemonade'</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">return</span> drinks[type]();</div><div class="line">&#125;</div><div class="line"><span class="comment">// вызовем функцию</span></div><div class="line"><span class="keyword">var</span> drink = getDrink(<span class="string">'coke'</span>);</div><div class="line"><span class="built_in">console</span>.log(drink); <span class="comment">// 'Coke'</span></div></pre></td></tr></table></figure>
<p>Всё отлично, но не учтён дефолтный случай. Это легко исправить:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDrink</span> (<span class="params">type</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> fn;</div><div class="line">  <span class="keyword">var</span> drinks = &#123;</div><div class="line">    <span class="string">'coke'</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="string">'Coke'</span>;</div><div class="line">    &#125;,</div><div class="line">    <span class="string">'pepsi'</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="string">'Pepsi'</span>;</div><div class="line">    &#125;,</div><div class="line">    <span class="string">'lemonade'</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="string">'Lemonade'</span>;</div><div class="line">    &#125;,</div><div class="line">    <span class="string">'default'</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="string">'Default item'</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">  <span class="comment">// если объект drinks содержит переданный параметр,</span></div><div class="line">  <span class="comment">// используем его</span></div><div class="line">  <span class="keyword">if</span> (drinks[type]) &#123;</div><div class="line">    fn = drinks[type];</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// в ином случае, приравняем к дефолтному значению drinks.default</span></div><div class="line">    <span class="comment">// удобно и логично использовать везде квадратные скобки</span></div><div class="line">    fn = drinks[<span class="string">'default'</span>];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> fn();</div><div class="line">&#125;</div><div class="line"><span class="comment">// вызываем с параметром "dr pepper"</span></div><div class="line"><span class="keyword">var</span> drink = getDrink(<span class="string">'dr pepper'</span>);</div><div class="line"><span class="built_in">console</span>.log(drink); <span class="comment">// 'выдаст дефолтное значение'</span></div></pre></td></tr></table></figure>
<p>Можно упростить нашу конструкцию <code>else</code> и <code>if</code>, используя в выражении оператор <code>||</code> «или»:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDrink</span> (<span class="params">type</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> drinks = &#123;</div><div class="line">    <span class="string">'coke'</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="string">'Coke'</span>;</div><div class="line">    &#125;,</div><div class="line">    <span class="string">'pepsi'</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="string">'Pepsi'</span>;</div><div class="line">    &#125;,</div><div class="line">    <span class="string">'lemonade'</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="string">'Lemonade'</span>;</div><div class="line">    &#125;,</div><div class="line">    <span class="string">'default'</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="string">'Default item'</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">return</span> (drinks[type] || drinks[<span class="string">'default'</span>])();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Мы поставили операции поиска по объекту <code>()</code>, что делает их выражением. И затем вызвали результат выражения. Если <code>drinks [type]</code> не будет найден, вернётся <code>drinks[&#39;default&#39;]</code> — элементарно!</p>
<p>Не обязательно всегда делать <code>return</code> внутри функции, можем присвоить результат любой переменной и затем вызвать её.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDrink</span> (<span class="params">type</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> drink;</div><div class="line">  <span class="keyword">var</span> drinks = &#123;</div><div class="line">    <span class="string">'coke'</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      drink = <span class="string">'Coke'</span>;</div><div class="line">    &#125;,</div><div class="line">    <span class="string">'pepsi'</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      drink = <span class="string">'Pepsi'</span>;</div><div class="line">    &#125;,</div><div class="line">    <span class="string">'lemonade'</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      drink = <span class="string">'Lemonade'</span>;</div><div class="line">    &#125;,</div><div class="line">    <span class="string">'default'</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      drink = <span class="string">'Default item'</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">    <span class="comment">// вызываем выражение</span></div><div class="line">  (drinks[type] || drinks[<span class="string">'default'</span>])();</div><div class="line"></div><div class="line">  <span class="comment">// возвращаем строку с выбранным напитком drink</span></div><div class="line">  <span class="keyword">return</span> <span class="string">'The drink I chose was '</span> + drink;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> drink = getDrink(<span class="string">'coke'</span>);</div><div class="line"><span class="comment">// The drink I chose was Coke</span></div><div class="line"><span class="built_in">console</span>.log(drink);</div></pre></td></tr></table></figure>
<ul>
<li>Это самые базовые примеры;</li>
<li>Объектные литералы содержат функцию, которая возвращает строку;</li>
</ul>
<p>Если вам нужна только строка, вы можете использовать строку как значение ключа — но иногда всё же логичнее использовать функции. Если вы используете и строки и функции, возможно, будет проще всегда использовать функции — для безопасного поиска параметра и дальнейшего вызова — мы ведь не хотим пытаться вызывать строку.</p>
<h3 id="“Проскакивание”-объектов"><a href="#“Проскакивание”-объектов" class="headerlink" title="“Проскакивание” объектов"></a>“Проскакивание” объектов</h3><p>В случае со <code>switch</code> мы можем позволить кейсу «проскочить» — когда к одному блоку кода применяется более одного случая case.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> type = <span class="string">'coke'</span>;</div><div class="line"><span class="keyword">var</span> snack;</div><div class="line"><span class="keyword">switch</span>(type) &#123;</div><div class="line"><span class="keyword">case</span> <span class="string">'coke'</span>:</div><div class="line"><span class="keyword">case</span> <span class="string">'pepsi'</span>:</div><div class="line">  snack = <span class="string">'Drink'</span>;</div><div class="line">  <span class="keyword">break</span>;</div><div class="line"><span class="keyword">case</span> <span class="string">'cookies'</span>:</div><div class="line"><span class="keyword">case</span> <span class="string">'crisps'</span>:</div><div class="line">  snack = <span class="string">'Food'</span>;</div><div class="line">  <span class="keyword">break</span>;</div><div class="line"><span class="keyword">default</span>:</div><div class="line">  drink = <span class="string">'Unknown type!'</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(snack); <span class="comment">// 'Drink'</span></div></pre></td></tr></table></figure>
<p>Мы позволяем <code>coke</code> и <code>pepsi</code> «проскочить» и не завершаем цикл <code>switch</code>, поскольку не добавляем оператор <code>break</code>. То же самое легко и более наглядно можно сделать с объектными литералами — это сделает наш код структурированным, читаемым и многократно используемым, а также убережёт от ошибкам.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSnack</span> (<span class="params">type</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> snack;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">isDrink</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> snack = <span class="string">'Drink'</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">isFood</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> snack = <span class="string">'Food'</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> snacks = &#123;</div><div class="line">    <span class="string">'coke'</span>: isDrink,</div><div class="line">    <span class="string">'pepsi'</span>: isDrink,</div><div class="line">    <span class="string">'cookies'</span>: isFood,</div><div class="line">    <span class="string">'crisps'</span>: isFood,</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">return</span> snacks[type]();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> snack = getSnack(<span class="string">'coke'</span>);</div><div class="line"><span class="built_in">console</span>.log(snack); <span class="comment">// 'Drink'</span></div></pre></td></tr></table></figure>
<p>####Выводы</p>
<p>Применение объектов даёт больший контроль над кодом, конструкция <code>switch</code> –  немного устарела, не изящна в синтаксисе и сложна в отладке ошибок. Объекты проще расширять, поддерживать и тестировать. Они привычны, поскольку являются основополагающим звеном Javascript, и мы используем их в работе каждый день для самых разных задач. Объектные литералы могут содержать функции и любые другие <a href="http://toddmotto.com/understanding-javascript-types-and-reliable-type-checking/" target="_blank" rel="external">типы объектов</a>, что делает их очень гибкими. У функций в литералах есть область действия (scope), поэтому мы можем вернуть замыкание из вызываемой родительской функции (в нашем случае <code>getDrink</code> возвращает замыкание).</p>
<p>Комментарии и фидбэк можно найти на <a href="http://www.reddit.com/r/javascript/comments/2b4s6r/deprecating_the_switch_statement_for_object" target="_blank" rel="external">Reddit</a>  </p>
<p>По мотивам <a href="http://toddmotto.com/deprecating-the-switch-statement-for-object-literals/" target="_blank" rel="external">Todd Motto</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/images/switch.jpg&quot; alt=&quot;Иллюстрация блокнота&quot;&gt;&lt;br&gt;Во многих языках программирования есть конструкция &lt;code&gt;switch&lt;/code&gt; – но стоит ли её применять?&lt;/p&gt;
&lt;p&gt;Если вы JS-программист, вы постоянно работаете с объектами: создаёте, инициализируете и совершаете с ними разные манипуляции. Объекты очень гибкие — в javascript практически всё на них построено, и именно их я в последнее время использую вместо &lt;code&gt;switch&lt;/code&gt;.&lt;br&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="https://makeomatic.ru/blog/tags/Javascript/"/>
    
      <category term="AngularJS" scheme="https://makeomatic.ru/blog/tags/AngularJS/"/>
    
  </entry>
  
  <entry>
    <title>Приёмы и хитрости для быстрой front-end разработки</title>
    <link href="https://makeomatic.ru/blog/2014/12/06/Tips_and_Tricks/"/>
    <id>https://makeomatic.ru/blog/2014/12/06/Tips_and_Tricks/</id>
    <published>2014-12-06T08:00:00.000Z</published>
    <updated>2016-01-08T17:55:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/images/tips.jpg" alt="Иллюстрация блокнота"></p>
<h3 id="Вступление"><a href="#Вступление" class="headerlink" title="Вступление"></a>Вступление</h3><p>Давайте по-честному, настраивая инструмент для сборки проектов (таск-менеджер), большинство разработчиков ищут предыдущий проект с подходящей структурой и просто копируют Grunt или Gulp файл и вносят необходимые правки (меняют названия папок для нового проекта и так далее).<br><a id="more"></a></p>
<p>Даже переход с одного таск-менеджера Grunt на другой, более новый, Gulp – это обычно поиск соответсвующего npm-пакета для Gulp, наподобие аналогичного плагина grunt-contrib. Раньше работали со связкой Grunt-contrib-Stylus? Значит, для нового таск-менеджера выбираем Gulp-Stylus. Необходим grunt-contrib-jshint? Наверняка, аналогичный пакет gulp-jshint выполняет те же задачи. А дальше — лишь соответствующие изменения синтактиса. </p>
<p>Таким способом можно быстро и особо не задумываясь настроить таск-менеджер для маленьких проектов. Но после нескольких месяцев работы в Pellucid над приложением, которое в моей практике является самым крупным проектом на Javascript, когда на выполнение задач такс-менеджера всё чаще должно уходить не более 10 секунд, пришлось задуматься об оптимизации.</p>
<p>###Представляем наш демонстрационный проект</p>
<p>В качестве небольшого примера для тестов и экспериментов, я создал <a href="https://github.com/mlms13/build-optimizations" target="_blank" rel="external">демо-репозиторий</a>. В проекте используется jQuery, Lo-dash и Handlebars, а также порядка 50 CommonJS модулей (около 0,5 Mb), чтобы Browserify было, с чем работать.</p>
<p>В этом репозитории наш идеальный таск-менеджер (идеальный вдвойне, потому что очень быстрый — но об этом чуть позже) будет делать следующее: </p>
<ul>
<li>предварительная обработка, префиксация и сжатие CSS; </li>
<li>анализ нашего javascript-кода с подсказками (Lint/Hint), сборка файлов с Browserify и их минификация с Uglify; </li>
<li>отслеживание изменений и применение к ним задач, указанных выше.</li>
</ul>
<p>В наших рабочих проектах Pellucid задач при настройке таск-менеджера обычно бывает больше, но эти — самые времязатратные, и в этом примере мы рассмотрим  общий случай,  применимый ко многим front-end проектам. </p>
<h3 id="Ускорим-процессы"><a href="#Ускорим-процессы" class="headerlink" title="Ускорим процессы"></a>Ускорим процессы</h3><p>В идеальном мире наш Gulpfile мог бы выглядеть <a href="https://github.com/mlms13/build-optimizations/blob/master/Gulpfile.js" target="_blank" rel="external">так</a>. Довольно просто: мы взяли наш список преобразований и разбили его на Gulp-задачи. Код быстро пишется, легко читается и выполняет всё, что от него требуется.</p>
<p>Однако, даже в нашем сравнительно небольшом демо-приложении, на моём ноутбуке это занимает более 4 секунд (показатель time gulp). Для первоначальной компиляции это допустимое время, но в связи с рекомпиляцией после каждого внесённого изменения благодаря нашей команде watch, время ожидания на тестирование наших изменений становится значительным.  </p>
<p>Давайте запустим одни из самых медленных процессов и подумаем, как их ускорить.</p>
<h4 id="Связка-Browserify-Watchify"><a href="#Связка-Browserify-Watchify" class="headerlink" title="Связка Browserify-Watchify"></a>Связка Browserify-Watchify</h4><p>Склеивание модулей с помощью Browserify, пожалуй, наиболее времязатратный процесс в нашей сборке, занимающий около 3 секунд. К счастью, это проще всего исправить. Прежде всего, переключим нашу задачу watch на использование библиотеки <a href="https://github.com/substack/watchify" target="_blank" rel="external">Watchify</a>. Она создана <a href="https://github.com/substack" target="_blank" rel="external">тем же человеком</a>, что и Browserify, и в неё встроен механизм, позволяющий пересобирать только необходимые нам файлы. Для Gulp уже есть <a href="https://github.com/gulpjs/gulp/blob/master/docs/recipes/fast-browserify-builds-with-watchify.md" target="_blank" rel="external">готовый способ сборки с Watchify</a>, воспользуемся им для начала.</p>
<p>Наш js-task будет по-прежнему использовать Browserify (чтобы компилировать Javascript без запуска команды watch) , но давайте вместо gulp-browserify, который <a href="https://github.com/gulpjs/plugins/blob/master/src/blackList.json#L3" target="_blank" rel="external">был внесён в чёрный список разработчиками Gulp</a>, воспользуемся Browserify напрямую. </p>
<p>Прим.: gulp-browserify <a href="https://github.com/deepak1556/gulp-browserify/blob/master/package.json#L14" target="_blank" rel="external">блокирует работу Browserify</a>  в версии 3.x. Используя Browserify напрямую, мы можем работать с последней версией 5.x, в которой другие настройки конфигурации.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'js'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> browserify = <span class="built_in">require</span>(<span class="string">'browserify'</span>),</div><div class="line">      source     = <span class="built_in">require</span>(<span class="string">'vinyl-source-stream'</span>);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> browserify(<span class="string">'./js/main.js'</span>, &#123;<span class="attr">debug</span>: <span class="literal">true</span>&#125;)</div><div class="line">    .bundle()</div><div class="line">    .pipe(source()) <span class="comment">// convert to a stream gulp understands</span></div><div class="line">    <span class="comment">// ... continue with uglify</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>А для мониторинга нашей системы файлов мы воспользуемся Watchify, вместо аналогичного Gulp watch.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'watch'</span>, [<span class="string">'stylus'</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> watchify   = <span class="built_in">require</span>(<span class="string">'watchify'</span>),</div><div class="line">        browserify = <span class="built_in">require</span>(<span class="string">'browserify'</span>),</div><div class="line">        bundler    = watchify(browserify(<span class="string">'./js/main.js'</span>, &#123;</div><div class="line">            <span class="attr">cache</span>: &#123;&#125;,</div><div class="line">            <span class="attr">packageCache</span>: &#123;&#125;,</div><div class="line">            <span class="attr">fullPaths</span>: <span class="literal">true</span>,</div><div class="line">            <span class="attr">transform</span>: [<span class="string">'hbsfy'</span>],</div><div class="line">            <span class="attr">debug</span>: <span class="literal">true</span></div><div class="line">        &#125;));</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">rebundle</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> bundler.bundle()</div><div class="line">            .pipe(source(<span class="string">'main.js'</span>))</div><div class="line">            .pipe(gulp.dest(<span class="string">'./dist'</span>));</div><div class="line">    &#125;</div><div class="line">    bundler.on(<span class="string">'update'</span>, rebundle);</div><div class="line">    <span class="comment">// run any other gulp.watch tasks</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> rebundle();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Большинство новых параметров, которые мы передаём Browserify, необходимы для работы Watchify. Как вы заметили, мы убрали задачу uglify на этапе watch. Поскольку с помощью этой задачи мы делаем тестовые сборки, не имеет смысла замедлять процесс минификацией.</p>
<p>Теперь, благодаря Watchify, время сборки после пересохранения JS файлов в нашем тестовом проекте уменьшилось с 3-4 секунд до 200 мили-секунд. В Pellucid эти показатели были — с 7 секунд до одной. Одного этого улучшения было бы достаточно, чтобы возгордиться собой и закончить с оптимизацией. Однако, мы можем сделать кое-что ещё.</p>
<h4 id="Дополнительная-оптимизация-Browserify"><a href="#Дополнительная-оптимизация-Browserify" class="headerlink" title="Дополнительная оптимизация Browserify"></a>Дополнительная оптимизация Browserify</h4><p>Если в своём проекте вы используете библиотеки, для работы которых не нужны сторонние модули, Browserify этого не знает, и будет парсить код на предмет команды require() в любом случае, что часто крайне времязатратно. Чтобы ускорить процесс, вы можете передать Browserify массив модулей, которые не нужно парсить:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">  browserify(<span class="string">'./js/main.js'</span>, &#123;</div><div class="line">    <span class="attr">noparse</span>: [<span class="string">'jquery'</span>, <span class="string">'lodash'</span>, <span class="string">'q'</span>]</div><div class="line">    <span class="comment">// other options</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>Это никак не скажется на времени наших последующих сборок, зато сэкономит нам 200-300мс при первоначальной сборке. Но имейте в виду, если вы используете browserify-shim и сторонний плагин, вы <a href="https://github.com/thlorenz/browserify-shim/issues/17" target="_blank" rel="external">не сможете</a> использовать noparse в зависимостях этого плагина. И, напоследок, если вы используете Browserify в автономной сборке, которая не зависит от контекста CommonJS, работайте с последней версией Browserify, поскольку предыдущие версии использовали <a href="https://github.com/calvinmetcalf/derequire" target="_blank" rel="external">derequire</a>, что может сильно <a href="https://github.com/substack/node-browserify/issues/633" target="_blank" rel="external">замедлить работу</a> вашей сборки. Если вы ограничены версией ранее 5.x., не включайте в задачу watch автономные сборки.</p>
<h4 id="Фильтруем-неизменённые-файлы"><a href="#Фильтруем-неизменённые-файлы" class="headerlink" title="Фильтруем неизменённые файлы"></a>Фильтруем неизменённые файлы</h4><p>Ещё одна задача, занимающая много времени — анализ кода с подсказками (hinting). Работа jshint в нашем демо-репозитории занимает лишь 500мс, однако, в крупном проекте это время доходит до нескольких секунд. </p>
<p>Для работы с Gulp сборками рекомендуется использовать специальные инструменты, и одним из лучших является gulp-cached. Подключаете в вашу сборку <a href="https://github.com/wearefractal/gulp-cached" target="_blank" rel="external">gulp-cached</a>, который кэширует в памяти содержание всех файлов. При последующем выполнении задач, Gulp сначала сравнивает файлы с кэшированными, и подвергает дальнейшим преобразованиям только те файлы, в которые были внесены изменения. </p>
<p>В наших проектах Pellucid эта хитрость экономит несколько секунд в JSHint операциях. Даже в нашем с вами тестовом приложении такой подход уменьшил время на hinting с 500мс до менее 100мс.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'hint'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> cached  = <span class="built_in">require</span>(<span class="string">'gulp-cached'</span>),</div><div class="line">        jshint  = <span class="built_in">require</span>(<span class="string">'gulp-jshint'</span>),</div><div class="line">        stylish = <span class="built_in">require</span>(<span class="string">'jshint-stylish'</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./js/**/*.js'</span>)</div><div class="line">      .pipe(cached(<span class="string">'hinting'</span>))</div><div class="line">        .pipe(jshint())</div><div class="line">        .pipe(jshint.reporter(stylish));</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Этот метод будет работать и с другими файлами, которые должны быть обработаны только в случае внесения изменений. Например, если вы сжимаете большое количество изображений, обрабатывая только изменённые фотографии, вы существенно увеличиваете скорость работы. </p>
<p>Если вы беспокоитесь, что это займёт много памяти, особенно в случае с большим количеством изображений, можно установить флаг optimizeMemory, который будет хранить md5 hash вместо полного содержания файлов. Кроме того, можно использовать <a href="https://github.com/sindresorhus/gulp-changed" target="_blank" rel="external">gulp-change</a> и <a href="https://github.com/tschaub/gulp-newer" target="_blank" rel="external">gulp-newer</a>, которые сравнивают временные метки вместо сохранения содержимого в памяти.</p>
<p>Если понадобится вернуть файлы в поток данных, например, если вы применили hint лишь для изменённых файлов, а связать (concatenate) хотите все имеющиеся файлы — это можно сделать с помощью <a href="https://github.com/ahaurw01/gulp-remember" target="_blank" rel="external">gulp-remember</a>.</p>
<h4 id="Разделение-рабочих-задач"><a href="#Разделение-рабочих-задач" class="headerlink" title="Разделение рабочих задач"></a>Разделение рабочих задач</h4><p>Мы не минифицируем (uglify) нашу тестовую JS-сборку, но можно применить кое-какие хитрости и для рабочих сборок. Это несколько увеличит скорость работы, тк мы будем выполнять операции, необходимые лишь для той или иной сборки. Для начала, разрешим передавать флаг –prod в Gulp сборку с помощью <a href="https://github.com/gulpjs/gulp-util" target="_blank" rel="external">gulp-util</a>, и сохраним в переменной для быстрого доступа.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> gulp  = <span class="built_in">require</span>(<span class="string">'gulp'</span>),</div><div class="line">    gutil = <span class="built_in">require</span>(<span class="string">'gulp-util'</span>),</div><div class="line">    prod  = gutil.env.prod;</div></pre></td></tr></table></figure>
<p>Теперь внутри различных задачек в зависимости от наличия или отсутствия –prod мы либо выполняем нужные операции, либо применяем gutil.noop() , который просто передаётся в поток.</p>
<p>Например, в нашем Browserify таске, мы создадим карты исходников (source maps) для тестовой сборки, а для рабочей — применим Uglify:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'js'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> browserify = <span class="built_in">require</span>(<span class="string">'browserify'</span>),</div><div class="line">      source     = <span class="built_in">require</span>(<span class="string">'vinyl-source-stream'</span>),</div><div class="line">      streamify  = <span class="built_in">require</span>(<span class="string">'gulp-streamify'</span>);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> browserify(<span class="string">'./js/main.js'</span>, &#123;</div><div class="line">      <span class="attr">debug</span>: !prod</div><div class="line">    &#125;)</div><div class="line">    .bundle()</div><div class="line">    .pipe(source()) <span class="comment">// convert to a stream gulp understands</span></div><div class="line">    .pipe(prod ? stream(uglify()) : gutil.noop())</div><div class="line">    .pipe(gulp.dest(<span class="string">'./build'</span>));</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Аналогично, в нашем Stylus таске, номера строк (или, если хотите, <a href="https://github.com/stevelacy/gulp-stylus/blob/master/examples/gulpfile.js#L10" target="_blank" rel="external">новые подключенные карты исходников</a>) - для тестовой сборки, а минификация — для рабочей:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'stylus'</span>, [<span class="string">'cleancss'</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> stylus = <span class="built_in">require</span>(<span class="string">'gulp-stylus'</span>),</div><div class="line">        prefix = <span class="built_in">require</span>(<span class="string">'gulp-autoprefixer'</span>),</div><div class="line">        minify = <span class="built_in">require</span>(<span class="string">'gulp-minify-css'</span>);</div><div class="line"></div><div class="line">    gulp.src(<span class="string">'./styl/main.styl'</span>)</div><div class="line">        .pipe(stylus(&#123;<span class="attr">linenos</span>: !prod&#125;))</div><div class="line">        .pipe(prefix())</div><div class="line">        .pipe(prod ? minify() : gutil.noop())</div><div class="line">        .pipe(gulp.dest(<span class="string">'./dist/css'</span>));</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Если вам привычнее вместо параметра –prod работать с таском gulp prod, можно делать и так, с помощью <a href="https://github.com/OverZealous/run-sequence" target="_blank" rel="external">run-sequence</a>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'setProduction'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// global prod variable that we added above</span></div><div class="line">  prod = <span class="literal">true</span>;</div><div class="line">&#125;);</div><div class="line">gulp.task(<span class="string">'prod'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> sequence = <span class="built_in">require</span>(<span class="string">'run-sequence'</span>);</div><div class="line"></div><div class="line">  <span class="comment">// first set our prod flag, then run other tasks</span></div><div class="line">  sequence(<span class="string">'setProduction'</span>, [<span class="string">'stylus'</span>, <span class="string">'js'</span>]);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>###Подытожим</p>
<p>Изменения, которые мы внесли в Gulp file, существенно ускорили работу наших сборок , особенно последующих, что крайне важно. Использование Watchify дало наилучший результат, сократив время с 3с до 200мс. Кэширование файлов также сэкономило нам несколько сотен миллисекунд в таске hint. Мы разделили тестовые и рабочие задачи, что позволило совершать только те операции, которые необходимы в данный момент. Это позволит добавлять source maps, отлаживать hints в тестовой сборке, и минифицировать всё — в рабочей.</p>
<p>Для сравнения, <a href="https://github.com/mlms13/build-optimizations/blob/master/Gulpfile.js" target="_blank" rel="external">вот</a>  наш первоначальный Gulpfile, собирающий и пересобирающий всё в течение 4 секунд. А вот наш <a href="https://github.com/mlms13/build-optimizations/blob/incremental/Gulpfile.js" target="_blank" rel="external">оптимизированный Gulpfile</a>, с более высокой скоростью сборки и пересборкой в 10 раз быстрее.  </p>
<p>###Подождите, а как же… Broccoli?</p>
<p>Broccoli – новый инструмент для сборки проектов, с акцентом на улучшенные пересборки. Если вы внимательно прочитаете пост о <a href="http://www.solitr.com/blog/2014/02/broccoli-first-release/" target="_blank" rel="external">первом релизе Broccoli</a>,  заметите, что этот таск-менеджер создавался для решения проблем, со многими из которых мы боролись выше. </p>
<p>«Broccoli serve автоматически определяет, какие файлы отслеживать (watch) и пересобирает только те, которые того требуют. Наша цель — менее 200мс на пересборку с типичным стеком сборки».</p>
<p>Звучит отлично, с одной оговоркой. <a href="https://github.com/gingerhendrix/broccoli-browserify/issues/10" target="_blank" rel="external">Поддерживаемый сообществом плагин Browserify для Broccoli</a> не работает с Watchify. Способность Broccoli “пересобирать только те файлы, которые того требуют” не применима в контексте полноценной Browserify сборки. Поскольку Browserify с самого начала был нашей основной головной болью, отсутствие Watchify делает Broccoli не привлекательным вариантом на данный момент.</p>
<p>####А как насчёт предварительной обработки CSS?</p>
<p>Признаюсь, об этой теме мы немного умолчали. Рекомендованные Gulp инструменты для последующих сборок, такие как gulp-cached, не сильно нам помогут в тех случаях, когда нужно обрабатывать большое количество входных файлов, объединяя их в один конечный файл. Для последующих CSS сборок понадобится специальный инструмент, делающий примерно то же, что Watchify для Browserify, и подобные инструменты для Stylus мне не известны.</p>
<p>В Pellucid, компиляция более, чем 300 Stylus файлов, содержащих более 2300 селекторов, занимает 2-3 секунды. Изменения в файлы стилей вносятся не так часто, как в javascript файлы, поэтому это допустимые показатели.</p>
<p>Я наслышан ужастиков о компиляции Ruby Sass, занимающей 20-30 и более секунд. В этом случае вам стоит задуматься о переходе на port C в Sass, который в разы быстрее. Вот отличная <a href="http://blog.teamtreehouse.com/tale-front-end-sanity-beware-sass-import" target="_blank" rel="external">статья в блоге Treehouse</a>, в которой они рассказали, как сократили время Sass-сборки с 50 до 3 секунд.</p>
<p>####Что ещё можно автоматизировать?</p>
<p>Существует немало способов атвоматизации сборок, что, несомненно, ускоряет рабочий процесс. Существует множество разнообразных способов настраивания вашего Gulp File: от популярных, таких как <a href="https://github.com/vohof/gulp-livereload" target="_blank" rel="external">LiveReload</a> и <a href="https://github.com/sindresorhus/gulp-mocha" target="_blank" rel="external">автоматизированных тестов</a>, до более сложных — <a href="https://github.com/stevelacy/gulp-bump" target="_blank" rel="external">поднятие пакетных версий</a> (gulp-bump) и <a href="https://gist.github.com/mlms13/4ed66cb920caf734ab1c" target="_blank" rel="external">развёртывание на Heroku</a>. </p>
<p>Надеюсь, в этой статье мы затронули самые наболевшие вопросы: типичные задачи, работающие с большим количеством файлов, запускаемые и перезапускаемые при каждом последующем пересохранении файлах. Если вы заметили, что ещё какие-то задачи замедляют вашу работу — и, особенно, если вы придумали, как эту проблему решить — обязательно поделитесь с нами в комментариях! </p>
<p>По мотивам Michael Martin-Smucker </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/images/tips.jpg&quot; alt=&quot;Иллюстрация блокнота&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Вступление&quot;&gt;&lt;a href=&quot;#Вступление&quot; class=&quot;headerlink&quot; title=&quot;Вступление&quot;&gt;&lt;/a&gt;Вступление&lt;/h3&gt;&lt;p&gt;Давайте по-честному, настраивая инструмент для сборки проектов (таск-менеджер), большинство разработчиков ищут предыдущий проект с подходящей структурой и просто копируют Grunt или Gulp файл и вносят необходимые правки (меняют названия папок для нового проекта и так далее).&lt;br&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="https://makeomatic.ru/blog/tags/Javascript/"/>
    
      <category term="AngularJS" scheme="https://makeomatic.ru/blog/tags/AngularJS/"/>
    
  </entry>
  
  <entry>
    <title>Обзор конференции YAC2014</title>
    <link href="https://makeomatic.ru/blog/2014/11/05/YAC2014/"/>
    <id>https://makeomatic.ru/blog/2014/11/05/YAC2014/</id>
    <published>2014-11-05T08:00:00.000Z</published>
    <updated>2016-01-08T17:55:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/images/YAC2014.png" alt="Иллюстрация блокнота"></p>
<h3 id="Makeomatic-на-YAC2014"><a href="#Makeomatic-на-YAC2014" class="headerlink" title="Makeomatic на YAC2014"></a>Makeomatic на YAC2014</h3><p>30 октября прошла очередная ежегодная конференция Яндекса Yet Another Conference 2014. Программа была довольно насыщенная, почти все время доклады шли параллельно в 5 потоков (3 зала, воркшопы, подиум). На момент написания заметки, была еще доступна <a href="http://yandex.ru/yac2014/program/" target="_blank" rel="external">ссылка с программой</a>. </p>
<a id="more"></a>
<p>И через 2 недели после конференции (в середине ноября) обещали выложить <a href="https://tech.yandex.ru/" target="_blank" rel="external">лекции</a> на странице технологий Яндекса.  </p>
<h4 id="Программа-YAC2014"><a href="#Программа-YAC2014" class="headerlink" title="Программа YAC2014"></a>Программа YAC2014</h4><p>Организаторы структурировали программу так, что если вас интересует какой-то конкретный аспект разработки (backend, администрирование, мобильная разработка и т.д.), то вы выбираете свой путь и идете по нему в течение всего дня, не теряя лекции и не разрываясь между залами. Тем не менее, у меня так не получилось, и, просмотрев внимательно программу за день до начала, я понял, что все- таки разрываюсь между направлениями, и составил свое собственное расписание. Может быть, мне повезло, но расписание мне показалось очень сбалансированным и удобным по времени. Причем во время конференции все, посещенные мной, доклады производили впечатление идеально вписанных в отведенное время. Очевидно, что все докладчики очень тщательно готовились.<br>Точно не скажу, но, как мне показалось, примерно половина докладов презентовали представители Яндекса, а другая половина была от приглашенных специалистов (из громких компаний, к примеру, представители из Docker, Facebook, Netflix). </p>
<p>####Ближе к делу<br>Сразу скажу, что пересказывать доклады я не буду, поскольку лекции будут выложены, и я позволю себе ограничиться рекомендацией к просмотру тех или иных тем. </p>
<p>Структуру оставляю в хронологическом порядке. И имейте в виду, что, по меньшей мере, половину докладов я физически не имел возможности посетить, так что я и сам полезу смотреть лекции после их публикации.</p>
<h3 id="Секретный-доклад"><a href="#Секретный-доклад" class="headerlink" title="Секретный доклад"></a>Секретный доклад</h3><p>Секретный доклад был посвящен двум развивающимся (уже вполне развившимся, но продолжающим эволюционировать) технологиям Яндекса - Яндекс.Диктовке, и Метрике (в контексте мобильных приложений). </p>
<p>####Яндекс.Диктовка </p>
<p>Яндекс.Диктовка- это приложение, созданное на базе API Yandex SpeechKit. Сейчас доступна в Yandex.Store, вот-вот дождется аппрува в App Store.Были рассмотрены элементы системы, этапы ее работы в процессе коммуникации с человеком (распознавание, активация, озвучивание, выделение смысловых объектов).</p>
<p>####Мобильная метрика</p>
<p>Мобильная метрика- мощный инструмент для тестирования и продвижения приложений. Осуществляет анализ данных в real-time (что является большим шагом вперед, поскольку раньше многие жаловались на низкую скорость работы метрики).</p>
<p>Была описана, разработанная в Яндексе, clickHouse, столбцовая СУБД. В двух словах, суть в том, что столбцовые СУБД лучше для аналитики, экономят ресурсы при поиске выборки, поскольку с диска считываются только нужные столбцы (не готов дискутировать на эту тему, за дополнительной информацией лучше обратиться сначала к оригинальной лекции). Был предоставлен ряд тестов, где clickHouse показывала лучшие данные в сравнении с аналогичными СУБД. Кроме того, как еще один способ оптимизации, был упомянут метод приближенного выбора, что позволяет получать значительный рост производительности при незначительной потери точности.</p>
<p>Также были рассмотрены проблемы анализа трафика в мобильных приложениях и пути их решения. Здесь основная сложность в том, чтобы обнаружить, откуда пользователь узнал о приложении, в то время как в случае с веб-сайтами- это достаточно тривиальная задача. Для приложений все несколько сложнее.</p>
<h3 id="Настоящее-и-будущее-рекомендательных-систем"><a href="#Настоящее-и-будущее-рекомендательных-систем" class="headerlink" title="Настоящее и будущее рекомендательных систем"></a>Настоящее и будущее рекомендательных систем</h3><p>(Михаил Ройзнер)<br>Я раньше не касался этой темы, поэтому пошел послушать не из профессиональной необходимости, а просто ради интереса, и не пожалел. Доклад определенно предполагал таких слушателей, как я.</p>
<p>Михаил начал доклад с экскурса в историю. Одним из основополагающих в этой сфере событий считается конкурс, организованный компанией Netflix, основанный в 2006 и закончившийся в 2009 году (Netflix Prize).<br>Задание было сформулированное предельно просто: “улучшить точность рекомендаций на 10%, в качестве приза было обещано 1 млн. долларов”<br><a href="http://en.wikipedia.org/wiki/Netflix_Prize" target="_blank" rel="external">Источник</a></p>
<p>В результате, разработчики пришли к выводу, что наилучший результат дает композиция различных алгоритмов (User-based, Item-based, SVD, RBM), и именно сочетание алгоритмов позволило преодолеть барьер в 10%, в то время как по отдельности методы давали 5-8%. Однако, Netflix так и не внедрили эти методы, они плохо масштабировались и их было тяжело улучшить.</p>
<p>Далее приведу несколько тезисов, которые мне запомнились и показались интересными. </p>
<ul>
<li>Не имеет смысла рекомендовать популярное  </li>
<li>Не имеет смысла рекомендовать очень похожие товары  </li>
<li>Доверие (нужно, чтобы пользователь поверил в то, что рекомендации должны ему подойти, то есть включить знакомые пользователю элементы)  </li>
<li>Объяснение рекомендаций (почему был рекомендован тот или иной товар).  </li>
</ul>
<p>Какие-то факты откровенно удивили, например, сервис персонального радио Pandora выделили 450 атрибутов треков (i.e. тональность, инструменты, голос вокалиста), и профессионалы (люди) прослушивают треки и размечают их атрибутами, которые потом используются для подбора плейлиста.</p>
<p>В то время как Spotify извлекают атрибуты треков с помощью нейронных сетей.</p>
<p>Ebay занялись рекомендацией одежды. Фотографии из блогов о моде =&gt; распознавание предметов =&gt; модель сочетаемости одежды по ее характеристикам. У них есть приложения по подбору одежды.<br>И просто оставлю здесь кусок конспекта.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LDA (скрытое распределение Дирихле). Если согласовать LDA с SVD, они будут влиять друг на друга, улучшая качество друг друга.</div></pre></td></tr></table></figure>
<p>Закончился доклад рассуждениями о перспективах, о том, что одновременное использование данных о погоде, физическом состоянии человека (например, данные спортивных и медицинских гаджетов), данные о местоположении и прочее открывают широкие перспективы для рекомендательных систем. Появляется вопрос: “Как не отпугнуть человека тем, что компьютер владеет о нем огромным количеством информации?”</p>
<h3 id="Документация-интерфейсов"><a href="#Документация-интерфейсов" class="headerlink" title="Документация интерфейсов"></a>Документация интерфейсов</h3><p>Мы документируем код, и это хорошо, и вам это нужно. Прошу прощения у читателей, но видимо здесь мой мозг потребовал перерыв между лекциями, которого до этого не получилось. Надеюсь, во выложенных материалах это будет выглядеть содержательнее.</p>
<p>Далее по roadmap-у у меня стоял круглый стол Docker-а, но начался он довольно бессодержательно, так что я перебрался в лекцию по frontend-у, послушать незнакомые слова, и, конечно, удовлетворил свой интерес. </p>
<h3 id="От-пояса-с-инструментами-к-полноценной-лаборатории"><a href="#От-пояса-с-инструментами-к-полноценной-лаборатории" class="headerlink" title="От пояса с инструментами к полноценной лаборатории"></a>От пояса с инструментами к полноценной лаборатории</h3><p>Здесь я выложу слегка отредактированный конспект со ссылками на упомянутые блоги и технологии.</p>
<p>Source-map-visualization<br>post-css принимает source map от препроцессора  </p>
<h4 id="Терминал-окружение-сборка-тестирование"><a href="#Терминал-окружение-сборка-тестирование" class="headerlink" title="Терминал (окружение, сборка тестирование)"></a>Терминал (окружение, сборка тестирование)</h4><p><a href="https://mathiasbynens.be/" target="_blank" rel="external">https://mathiasbynens.be/</a><br><a href="http://zachholman.com/" target="_blank" rel="external">http://zachholman.com/</a><br><a href="http://ohmyz.sh/" target="_blank" rel="external">http://ohmyz.sh/</a>  </p>
<ul>
<li>Yeoman  </li>
<li>Grunt task runner  </li>
<li>Gulp- сборщик на основе streaming-а (проблема в том, как передавать source map)  </li>
<li>Broccoli - сборщик на основе файловой системы (есть кеширование, работает быстро)<br>Можно их всех использовать одновременно (напр. модуль Broccoli в Broccoli)  </li>
</ul>
<h4 id="Тестирование"><a href="#Тестирование" class="headerlink" title="Тестирование"></a>Тестирование</h4><ul>
<li>DalekJS - кроссбраузерное тестирование  </li>
<li>PhantomCSS - визуальное тестирование на регрессии  </li>
</ul>
<h4 id="Браузеры-редакторы-песочницы"><a href="#Браузеры-редакторы-песочницы" class="headerlink" title="Браузеры, редакторы, песочницы"></a>Браузеры, редакторы, песочницы</h4><ul>
<li>Песочницы CodePen, JS Bin, jsFiddle, Dabblet, CSSDeck   </li>
<li>Поддержка препроцессоров csspre.com/convert   </li>
<li>Получение диффа отредактированного кода (History в панели хрома)  </li>
<li>Tincr, Chrome Workspaces, Emmet LiveStyle (!)  </li>
<li>CSS Shapes (правим объекты в браузере, изменения сразу отображаются в коде).   Моментальная обратная связь  </li>
</ul>
<h4 id="Перспективы"><a href="#Перспективы" class="headerlink" title="Перспективы"></a>Перспективы</h4><ul>
<li>Промежуточные шаги в картах кода  </li>
<li>Более глубокая интеграция инструментов в ОС  </li>
<li>Emmet LiveStyle с поддержкой препроцессоров  </li>
</ul>
<h3 id="Открытый-код-Томита-парсера"><a href="#Открытый-код-Томита-парсера" class="headerlink" title="Открытый код Томита-парсера"></a>Открытый код Томита-парсера</h3><p>Томита-парсер - инструмент для извлечения формальных данных из человеческой речи. В коротком рассказе был описан алгоритм работы парсера, разобраны <a href="https://tech.yandex.ru/tomita/" target="_blank" rel="external">пара примеров</a>.  </p>
<h3 id="inFront-на-передовой-событий-в-мире-фронтенда"><a href="#inFront-на-передовой-событий-в-мире-фронтенда" class="headerlink" title="inFront: на передовой событий в мире фронтенда"></a>inFront: на передовой событий в мире фронтенда</h3><p>Эту лекцию имеет смысл посмотреть для расширения кругозора и получения кратких обзоров о frontend (в основном) конференциях по всему миру. Раз уж я что-то (не все) записал, оставлю здесь конспект для общего представления. Отдельно обращаю внимания (я например не знал, что все так удобно) на доступность видео со многих конференций на <a href="http://vimeo.com/fronteers" target="_blank" rel="external">vimeo</a>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">fronteers (весной заявка, осенью конференция, Амстердам)</div><div class="line">campJS</div><div class="line">lanyrd.com - подписаться на спикера</div><div class="line">eventbrite.com</div><div class="line">smashingmagazine.xom - web dev web design </div><div class="line">texh.yandex.ru</div><div class="line"></div><div class="line">Подкасты, видео</div><div class="line">vimeo.com/fronteer …..</div><div class="line">.. (много еще конференций на vimeo)</div><div class="line">radio.js</div><div class="line">node.js podcast</div><div class="line"></div><div class="line">Блоги, журналы, etc</div><div class="line">Smashing magazine</div><div class="line">html5 weekly</div><div class="line">javascript weekly</div><div class="line">fronender magazine </div><div class="line"></div><div class="line">codeacandemy</div><div class="line">html academy</div><div class="line">w3schools</div><div class="line">html5 rocks</div><div class="line">khan academy</div><div class="line">coursera</div></pre></td></tr></table></figure>
<p>Далее мой roadmap привел меня в секцию администрирования, на доклад бывшего сотрудника яндекса (сейчас он работает в Facebook) на тему: “кэширование”.</p>
<h3 id="Кэширование-в-Facebook-делаем-граф-быстрее"><a href="#Кэширование-в-Facebook-делаем-граф-быстрее" class="headerlink" title="Кэширование в Facebook: делаем граф быстрее"></a>Кэширование в Facebook: делаем граф быстрее</h3><p>Это был интересный доклад. Советую его посмотреть. Если лекцию не выложат, тогда я пересмотрю и структурирую записи. В настоящий момент я понимаю, что как бы я ни старался, ценнее будет посмотреть оригинал.  </p>
<p>Были рассмотрены вопросы, решаемые кэшированием, акцент на то, что для некоторых систем (в частности Facebook) кэширование из способа оптимизации превращается в жизненную необходимость. Было сформулировано какими требованиями должен обладать идеальный cache и как это решается в Facebook, с помощью разработанного ими (но opensource) протокола <a href="https://github.com/facebook/mcrouter" target="_blank" rel="external">Mcrouter</a>.  </p>
<p>Далее по расписанию для меня самым интересным показался доклад ребят из Яндекса (Александр Денисов, Евгений Дымов) про использование JavaScript в iOS.</p>
<h3 id="Зачем-нужен-JavaScript-в-iOS-приложениях"><a href="#Зачем-нужен-JavaScript-в-iOS-приложениях" class="headerlink" title="Зачем нужен JavaScript в iOS-приложениях"></a>Зачем нужен JavaScript в iOS-приложениях</h3><p>Пытаюсь подыскать новые слова, но не нахожу. Этот доклад тоже был интересным и, конечно, его стоит посмотреть всем, кто связан с разработкой по iOS, в особенности нативной.  </p>
<p>Были рассмотрены способы использования WebView, преимущества WKWebView (released in iOS8) над UIWebView. WKWebView быстрее, имеет более богатый API, хотя, строго говоря, большую часть его функционала можно (и, видимо, пока придется, поскольку iOS7) реализовать посредством UIWebView.  </p>
<p>Во второй части доклада был рассмотрен фреймворк (не уверен в терминологии) JavaScriptCore и написана игра c логикой на JavaScript, но с нативной отрисовкой.<br>Темп доклада был достаточно высокий, очевидно из-за жесткого тайминга, так что эта лекция у меня в списке к просмотру после публикации.   </p>
<h3 id="Разработка-со-скоростью-света"><a href="#Разработка-со-скоростью-света" class="headerlink" title="Разработка со скоростью света"></a>Разработка со скоростью света</h3><p>(Станислав Жуковский)<br>Вдохновляющая речь о прелестях независимой разработки. Как не терять вдохновения, и насколько это реально сделать рабочую программу самому или небольшой командой. Перечень полезных инструментов (не гарантирую, что все вспомню).  </p>
<ul>
<li>Cocoa Controls  </li>
<li>CocoaPods  </li>
<li>Parse - БД в облаке  </li>
<li>decksetapp.com - утилита для создания презентаций на markdown.  </li>
</ul>
<h4 id="Заключение"><a href="#Заключение" class="headerlink" title="Заключение"></a>Заключение</h4><p>На этом содержательная часть моего доклада заканчивается. К сожалению, за кадром осталась значительная часть, возможно более интересная, поскольку в результате я понял, что посетил наименее наукоемкие темы, больше по инструментарию и каким-то прикладным (на базовом уровне) вещам, в то время как в других докладах рассматривались темы по машинному обучению, обходу свежего контента, AI, так что я с не меньшим интересом жду публикаций материалов конференции. Еще раз приведу <a href="https://tech.yandex.ru/" target="_blank" rel="external">ссылку</a> страницы технологий Яндекса.</p>
<p>Спасибо организаторам за такое событие. Все было прекрасно организовано, как в масштабах всего мероприятия, так и в масштабах каждого отдельного доклада. Было много информации, интересных, открытых к общению и сотрудничеству людей.  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/images/YAC2014.png&quot; alt=&quot;Иллюстрация блокнота&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Makeomatic-на-YAC2014&quot;&gt;&lt;a href=&quot;#Makeomatic-на-YAC2014&quot; class=&quot;headerlink&quot; title=&quot;Makeomatic на YAC2014&quot;&gt;&lt;/a&gt;Makeomatic на YAC2014&lt;/h3&gt;&lt;p&gt;30 октября прошла очередная ежегодная конференция Яндекса Yet Another Conference 2014. Программа была довольно насыщенная, почти все время доклады шли параллельно в 5 потоков (3 зала, воркшопы, подиум). На момент написания заметки, была еще доступна &lt;a href=&quot;http://yandex.ru/yac2014/program/&quot;&gt;ссылка с программой&lt;/a&gt;. &lt;/p&gt;
    
    </summary>
    
    
      <category term="YAC2014" scheme="https://makeomatic.ru/blog/tags/YAC2014/"/>
    
  </entry>
  
  <entry>
    <title>Оптимизация AngularJS: с 1200ms до 35ms</title>
    <link href="https://makeomatic.ru/blog/2014/10/22/Optimizing_AngularJS/"/>
    <id>https://makeomatic.ru/blog/2014/10/22/Optimizing_AngularJS/</id>
    <published>2014-10-22T07:00:00.000Z</published>
    <updated>2016-01-08T17:55:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/images/Optimizing.png" alt="Иллюстрация локального сайта"></p>
<p>Ребята из Scalyr недавно приступили к полному переписыванию веб-клиента. Их приложение - это инструмент для разнопланового мониторинга и анализа логов. Разработанная ими база данных логов обрабатывает запросы за десятки миллисекунд, но каждое действие, требующее загрузки страницы, отнимает несколько секунды у пользователя.<br><a id="more"></a></p>
<p>Использование <a href="http://en.wikipedia.org/wiki/Single-page_application" target="_blank" rel="external">одностраничного приложения</a> позволило бы использовать быстродействие бекенда на полную, поэтому они занялись поиском подходящего фреймворка и Ангуляр им показался достойным кандидатом. Следуя принципу “обломайся по-быстрому”, они приступили к нашему самому жесткому испытанию, просмотру логов.</p>
<p>Это по-настоящему серьезное испытание для фреймворка. Пользователь может кликнуть по любому слову для поиска соответствующих ему сообщений в логах, а на странице могут быть тысячи таких элементов; еще они хотят мгновенную реакцию при навигации по логам. Они уже сделали предварительную выборку следующей страницы, так что обновление пользовательского интерфейса было целым испытанием. При первичном использовании Ангуляра, переход к следующей страницы лога занимал 1.2 секунды, но после некоторой оптимизации удалось снизить это время до 35 миллисекунд. Эти оптимизации также оказались полезными и в других частях приложения и прекрасно вписывались в философию AngularJS, поэтому они выделили несколько правил, которые будут описаны в этой статье.</p>
<p><img src="/blog/images/log-view.png" alt="Иллюстрация локального сайта"></p>
<p>Журнал Github изменений, из <a href="https://www.scalyr.com/logStart" target="_blank" rel="external">демо версии</a></p>
<h3 id="Просмотрщик-логов-на-AngularJS"><a href="#Просмотрщик-логов-на-AngularJS" class="headerlink" title="Просмотрщик логов на AngularJS"></a>Просмотрщик логов на AngularJS</h3><p>По сути, отображение журнала событий- это просто отображение списка сообщений. Каждое слово кликабельно и поэтому должно быть помещено в отдельный DOM элемент. Простая реализация на AngularJS выглядит приблизительно так:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;span <span class="class"><span class="keyword">class</span></span>=’logLine’ ng-repeat=’line <span class="keyword">in</span> logLinesToShow’&gt;<span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">’logToken’</span> <span class="attr">ng-repeat</span>=<span class="string">’token</span> <span class="attr">in</span> <span class="attr">line</span>’&gt;</span>&#123; &#123;token | formatToken&#125; &#125; <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>На одной странице запросто может быть несколько тысяч таких токенов. В предыдущих тестах они выяснили, что переход к следующей странице лога вызывает агонии javascript интерпретатора на несколько минут. Хуже всего, что несвязанные действия (такие, как клик на выпадающем меню навигации) сейчас выполнялись со значительными задержками. Традиционнные рекомендации по AngularJS говорили, что нельзя допускать количество связанных элементов на странице больше 200. При условии, что у них каждым элементом было слово, то и до этой цифры им было слишком далеко.</p>
<h3 id="Анализ-Причины-лагов"><a href="#Анализ-Причины-лагов" class="headerlink" title="Анализ. Причины лагов"></a>Анализ. Причины лагов</h3><p>Используя профайлер Google Chrome, мы быстро обнаружили две причины тормозов.</p>
<p>Первое, при каждом обновлении много времени занимало создание и удаление DOM элементов. Если в новом виде было другое количество строк или в любой строке было другое количество слов, то директива AngularJS <code>ng-repeat</code> соответсвенно создает или удаляет DOM элементы. Как оказалось, это достаточно затратно.</p>
<p>Второе, у каждого слова был свой обработчик изменений, который AngularJS запускал при каждом клике мыши. Это и было причиной лагов таких событий, как клик по выпадающей навигации.</p>
<p>###Оптимизация #1: Кеширование Dom элементов</p>
<p>Они создали свою реализацию директивы <code>ng-repeat</code>. В их версии, когда количество слов-элементов уменьшалось, лишние DOM элементы прятались, а не удалялись. Если после количество слов увеличивалось, то они переиспользуют закешированные элементы для вставки новых слов.</p>
<p>###Оптимизация #2: Объединение обработчиков</p>
<p>Время, потраченное на запуск обработчиков изменений, шло впустую. В приложении данные, связанные с каждым словом не изменяются, пока весь массив сообщений не изменится. Чтобы задействовать это, ребята создали директиву, которая “прячет” обработчики изменений дочерних элементов, запуская их только тогда, когда значение определенного родительского выражения изменится. Эта модернизация позволила им избежать запуска тысячей обработчиков каждого слова на каждый клик или более мелкое событие. (Чтобы добиться этого, им пришлось слегка сломать уровень абстракции AngularJS. Об этом чуть больше в заключении)</p>
<p>###Оптимизация #3: Откладывание создания элементов</p>
<p>Как было сказано ранее, сотрудники Scalyr создают отдельный DOM элемент для каждого слова в логе. Они могут получить тот же вид с одним элементом на строку; дополнительные элементы нужны только при взаимодействии мышью. Поэтому они решили отложить создание элементов для каждого слово до того момента, как курсов не пройдет над строкой.<br>Чтобы сделать это, программисты создают две версии каждой строки. Первая, обычный текст всего сообщения. Вторая - плейсхолдер, будет показан с элементом на каждое слово. Изначально, плейсхолдер не отображается. Когда курсор мыши проходит над этой строкой, он появляется, а простой текст прячется.</p>
<p>###Оптимизация #4: Обходной путь вотчеров для спрятанных элементов</p>
<p>Программисты написали еще одну директиву, которая блокирует выполнение обработчика (или его “детей”), если элемент спрятан). Это дополняет Оптимизацию #1, убирая любые лишние “расходы” для элементов, которые были спрятаны по причине ненадобности. Также дополняет Оптимизацию #3, облегчая откладывание обертки каждого слова в элемент, пока строка с токеном не будет показана.</p>
<p>Вот как выглядит код после всех нововведений. Пользовательские директивы выделены жирным шрифтом:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;span <span class="class"><span class="keyword">class</span></span>=’logLine’ sly-repeat=’line <span class="keyword">in</span> logLinesToShow’ sly-evaluate-only-when=’logLines’&gt;<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-mouseenter</span>=<span class="string">”mouseHasEntered</span> = <span class="string">true”</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">ng-show</span>=<span class="string">’!mouseHasEntered’</span>&gt;</span>&#123; &#123;logLine | formatLine &#125; &#125; <span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-show</span>=<span class="string">’mouseHasEntered’</span> <span class="attr">sly-prevent-evaluation-when-hidden</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">’logToken’</span> <span class="attr">sly-repeat</span>=<span class="string">’tokens</span> <span class="attr">in</span> <span class="attr">line</span>’&gt;</span>&#123; &#123;token | formatToken &#125; &#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">&lt;br&gt;</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p><code>sly-repeat</code>- вариант <code>ng-repeat</code>, это наш вариант ng-repeat, который скрывает лишние DOM элементы, вместо того, чтобы их уничтожать.<br><code>sly-evaluate-only-when</code> блокирует  внутренние обработчики изменений, пока переменная <code>logLines</code>  не изменится, что говорит о переходе пользователя к новой части лога.</p>
<p>И <code>sly-prevent-evaluation-when-hidden</code> препятствует выполнению внутренних пунктов, пока курсор не пройдет над строкой и не <code>div</code> не отобразится.</p>
<p>Вышеперечисленное показывает мощь AngularJS в инкапусуляции и выделении проблемы. Они провели довольно тонкие оптимизации без сильного затрагивания шаблонов. (Это не точный код, который они используем на продакшне, но он илюстрирует большинство элементов)</p>
<h3 id="Результаты-Оптимизаций-AngularJS"><a href="#Результаты-Оптимизаций-AngularJS" class="headerlink" title="Результаты Оптимизаций AngularJS"></a>Результаты Оптимизаций AngularJS</h3><p>Чтобы замерить производительность, разработчики добавили код, который засекает время с момента клика и до конца <code>$digest</code>-цикла (что говорит, что бы обновили DOM). Полученное время показывается в виджете сбоку на странице. Они замерили время действия кнопки “следующая страница” просматривая лог доступа Tomcat в Chrome на недавнем Macbook Pro. И вот результаты (каждое число - результат 10 прогонов):</p>
<table class="table"><br>    <thead><br>        <tr><br>           <th>&nbsp;</th><br>           <th>Data already cached</th><br>           <th>Data fetched from server</th><br>        </tr><br>    </thead><br>    <tbody><br>        <tr><br>           <td>Simple AngularJS</td><br>           <td>1190 ms</td><br>           <td>1300 ms</td><br>        </tr><br>        <tr><br>           <td>With Optimizations</td><br>           <td>35 ms</td><br>           <td>201 ms</td><br>        </tr><br>    </tbody><br></table>

<p>Сюда не включено время на отрисовку браузером (после каждого выполнения Javascript), это 30 миллисекунд в каждом случае. В любом случае, разница существенная: время “следующей страницы” сократилось с чудовищных 1.2 секунд до незаметных 35 миллисекунд (65 с рендерингом).</p>
<p>“Данные, запрошенные с сервера” включает время AJAX-запроса к серверу для получения лога. Это нестандартно для “следующей страницы”, учитывая то, что данные перезагружаются, но применимо для других компонент интерфейса. Но и здесь все работает мгновенно.</p>
<h4 id="Заключение"><a href="#Заключение" class="headerlink" title="Заключение"></a>Заключение</h4><p>Этот код был в продакшне 2 месяца и ребята из Scalyr очень довольны результатами. Вы можете увидеть его в действии в <a href="https://www.scalyr.com/login?prefillEmail=demo-account@scalyr.com&amp;prefillPassword=demodemo&amp;originalUrl=https://www.scalyr.com/logStart" target="_blank" rel="external">Scalyr лог демо</a>. После входа, нажмите на ссылку “Log view” и поиграйтесь с кнопками “Next/Prev”. Работает настолько быстро, что трудно поверить, что мы имеем дело с данными с реального сервера.</p>
<p>Применение этих оптимизаций заняло приличное количество времени. Наверное, было бы легче создать одну директиву, которая бы генерировала весь HTML для отображения логов, не используя <code>ng-repeat</code>. Но это бы шло вразрез с духом Angular, усложняя поддержку кода, его тестируемость и многое другое. Так как отображение логов являлось нашим тестовым заданием для AngularJS, они хотели убедится, что чистое решение возможно. К тому же, директивы, которые они создали, уже использовались в других частях приложения.</p>
<p>Программисты сделали все возможное, чтобы следовать философии AngularJS, но им пришлось изменить слой абстракций, чтобы применить некоторые из этих оптимизаций. Они переписали <code>$watch scope</code>-a, чтобы перехватывать регистрацию обработчиков и потом производить осторожные манипуляции с переменными <code>scope</code>, чтобы контролировать, какие обработчики будут выполнятся во время <code>$digest</code>-цикла.</p>
<h4 id="В-следующий-раз"><a href="#В-следующий-раз" class="headerlink" title="В следующий раз"></a>В следующий раз</h4><p>Эта статья охватила множество техник, которые были использованы для оптимизации времени исполнения Javascript кода в их экземпляре AngularJS. Мы уверены в том, что следует максимально увеличивать производительность и это только часть трюков, которые используются. В следующих статьях ми опишем техники уменьшения запросов сети, задержки сети, и времени выполнения кода на сервере. Мы так же предлагаем обсудить опыт с AngularJS и подход, который был использован для структурирования кода приложения. Если вам стало интересно, напишите нам в комментариях.</p>
<p>По мотивам Steve Newman</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/images/Optimizing.png&quot; alt=&quot;Иллюстрация локального сайта&quot;&gt;&lt;/p&gt;
&lt;p&gt;Ребята из Scalyr недавно приступили к полному переписыванию веб-клиента. Их приложение - это инструмент для разнопланового мониторинга и анализа логов. Разработанная ими база данных логов обрабатывает запросы за десятки миллисекунд, но каждое действие, требующее загрузки страницы, отнимает несколько секунды у пользователя.&lt;br&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="https://makeomatic.ru/blog/tags/Javascript/"/>
    
      <category term="AngularJS" scheme="https://makeomatic.ru/blog/tags/AngularJS/"/>
    
  </entry>
  
  <entry>
    <title>Интернационализация в AngularJS</title>
    <link href="https://makeomatic.ru/blog/2014/10/08/internationalisation/"/>
    <id>https://makeomatic.ru/blog/2014/10/08/internationalisation/</id>
    <published>2014-10-08T07:00:00.000Z</published>
    <updated>2016-01-08T17:55:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/images/Internationalisation.jpg" alt="Иллюстрация локального сайта"><br>Интернационализация охватывает много вопросов. В этой небольшой статье я расскажу о том, как начать работать с angular-translate. А вот и его возможности, о которых мы с вами узнаем:<br><a id="more"></a></p>
<ul>
<li>предоставление нескольких языков с помощью json файлов (языковая таблица)</li>
<li>асинхронная загрузка языков с помощью расширения angular-translate - StaticFilesLoader</li>
<li>подключение запасного языка, если перевод слова на текущем не был найден.</li>
</ul>
<p>###Настройка angular-translate</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">angular.module(<span class="string">"myapp"</span>, [<span class="string">'pascalprecht.translate'</span>])</div><div class="line">.config(<span class="function"><span class="keyword">function</span> (<span class="params">$translateProvider</span>) </span>&#123;</div><div class="line">    <span class="comment">//язык по умолчанию</span></div><div class="line">    $translateProvider.preferredLanguage(<span class="string">'en'</span>);</div><div class="line">    <span class="comment">//запасной язык, если запись не была найдена на текущем языке</span></div><div class="line">    $translateProvider.fallbackLanguage(<span class="string">'es'</span>);</div><div class="line">    <span class="comment">//загружаем записи языков из файлов</span></div><div class="line">    $translateProvider.useStaticFilesLoader(&#123;</div><div class="line">        <span class="attr">prefix</span>: <span class="string">''</span>, <span class="comment">//относительный путь, например: /languages/</span></div><div class="line">        suffix: <span class="string">'.json'</span> <span class="comment">//расширение файлов</span></div><div class="line">    &#125;);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>###Использование angular-translate</p>
<p>Ниже вы можете увидеть использование директивы в качестве атрибута и фильтра. В контроллере вы можете использовать сервис <code>$translate</code>.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;h1 translate=<span class="string">"title"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></div><div class="line">&lt;h1&gt;&#123; &#123;title | translate&#125; &#125;&lt;<span class="regexp">/h1&gt;</span></div></pre></td></tr></table></figure></p>
<p>###Выбор языка </p>
<p>А тут приведен код выпадающего меню для выбора языка и контроллера:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;!-- html код --&gt;</div><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">ng-model</span>=<span class="string">"selectedLanguage"</span> <span class="attr">ng-change</span>=<span class="string">"changeLanguage()"</span>&gt;</span></span></div><div class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"en"</span> <span class="attr">translate</span>=<span class="string">"global_language_en"</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"es"</span> <span class="attr">translate</span>=<span class="string">"global_language_es"</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">//контроллер</span></div><div class="line">.controller(<span class="string">"Controller"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$scope, $translate</span>) </span>&#123;</div><div class="line">    <span class="comment">//переменная для хранения выбранного языка</span></div><div class="line">    $scope.selectedLanguage = $translate.proposedLanguage(); <span class="comment">//по умолчанию</span></div><div class="line"></div><div class="line">    $scope.changeLanguage = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="comment">//значение, передаваемое в метод use, должно быть обозначением локали, например: en-UK, en и т.д.</span></div><div class="line">      $translate.use($scope.selectedLanguage);</div><div class="line">    &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>По мотивам Gerard Sans “Angular internationalisation”</p>
<p><a href="http://angular-translate.github.io/docs/#/guide" target="_blank" rel="external">Источники</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/images/Internationalisation.jpg&quot; alt=&quot;Иллюстрация локального сайта&quot;&gt;&lt;br&gt;Интернационализация охватывает много вопросов. В этой небольшой статье я расскажу о том, как начать работать с angular-translate. А вот и его возможности, о которых мы с вами узнаем:&lt;br&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="https://makeomatic.ru/blog/tags/Javascript/"/>
    
      <category term="AngularJS" scheme="https://makeomatic.ru/blog/tags/AngularJS/"/>
    
  </entry>
  
  <entry>
    <title>Разбираемся с системой событий $emit, $broadcast и $on в $scope и $rootScope Ангуляра</title>
    <link href="https://makeomatic.ru/blog/2014/10/07/Angular_scope_rootScope/"/>
    <id>https://makeomatic.ru/blog/2014/10/07/Angular_scope_rootScope/</id>
    <published>2014-10-07T07:00:00.000Z</published>
    <updated>2016-01-08T17:55:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/images/angular_scope.png" alt="Иллюстрация блокнота"></p>
<p><code>$emit</code>, <code>$broadcast</code> и <code>$on</code> Ангуляра попадают под общий концепт “publish/subscribe”, так же называемый “могу сделать”, в которой вы публикуете событие и подписываетесь/отписываетесь от него еще где-то. Система событий в AngularJS великолепна, что делает вещи безупречными и легкими в исполнении (как и следовало ожидать!), но концепт, который стоит за этой простотой не так легок для освоения в совершенстве, поэтому очень часто у вас будет возникать недоумение по поводу того, почему все работает не так, как вы думаете.<br><a id="more"></a></p>
<p>Для тех, кому работа с Ангуляром в новинку, и кто не использовал или не видел <code>$emit</code>, <code>$broadcast</code>или <code>$on</code>, поясним, что они делают, перед тем, как мы рассмотрим <code>$scope</code> и <code>$rootScope</code>отношения событий, областей видимости и того, как корректно применить данную систему событий, а так же поймем, что же действительно происходит.</p>
<h3 id="scope-emit-вверх-scope-broadcast-вниз"><a href="#scope-emit-вверх-scope-broadcast-вниз" class="headerlink" title="$scope.$emit вверх, $scope.$broadcast вниз"></a>$scope.$emit вверх, $scope.$broadcast вниз</h3><p>Используя <code>$scope.$emit</code>- событие запускается вверх по области видимости. Используя <code>$scope.$broadcast</code>- событие запускается вниз по области видимости. Когда мы используем <code>$scope.$on</code> - мы “подписываемся” на прослушивание данных событий. Быстрый пример:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// запускаем событие вверх</span></div><div class="line">$scope.$emit(<span class="string">'myCustomEvent'</span>, <span class="string">'Data to send'</span>);</div><div class="line"></div><div class="line"><span class="comment">// запускаем событие вниз</span></div><div class="line">$scope.$broadcast(<span class="string">'myCustomEvent'</span>, &#123;</div><div class="line">  <span class="attr">someProp</span>: <span class="string">'Sending you an Object!'</span> <span class="comment">// посылайте что хотите</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// слушаем событие в нужном нам $scope</span></div><div class="line">$scope.$on(<span class="string">'myCustomEvent'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event, data</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// Данные, которые нам прислали</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="scope-emit-broadcast"><a href="#scope-emit-broadcast" class="headerlink" title="$scope.($emit/$broadcast)"></a>$scope.($emit/$broadcast)</h3><p>Ключевой момент для запоминания при использовании <code>$scope</code> для запуска ваших событий - это то, что они будут коммуницировать только с непосредственной родительской областью видимости или с ближайшими потомками! При этом области видимости не всегда потомки или родители: у нас могут быть “братские” области видимости, к примеру, с одним и тем же родителем. Используя <code>$scope</code> для запуска, мы пропустим такие области видимости и запустим его лишь вниз или вверх, но никогда не по сторонам.</p>
<p>Самый простой путь имитации родительских и дочерних областей видимости - использовать контроллеры. Каждый контроллер создает новый <code>$scope</code>, который Ангуляр аккуратно выводит для нас в виде класса <code>ng-scope</code> на элементах, с новыми областями видимости:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-controller</span>=<span class="string">"ParentCtrl as parent"</span> <span class="attr">class</span>=<span class="string">"ng-scope"</span>&gt;</span></div><div class="line">  &#123; &#123; parent.data &#125; &#125;</div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-controller</span>=<span class="string">"SiblingOneCtrl as sib1"</span> <span class="attr">class</span>=<span class="string">"ng-scope"</span>&gt;</span></div><div class="line">      &#123; &#123; sib1.data &#125; &#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Мы могли бы запустить событие вниз из <code>ParentCtrl</code> в <code>SiblingOneCtrl</code>, используя <code>$broadcast</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">app.controller(<span class="string">'ParentCtrl'</span>,</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">ParentCtrl</span> (<span class="params">$scope</span>) </span>&#123;</div><div class="line"></div><div class="line">  $scope.$broadcast(<span class="string">'parent'</span>, <span class="string">'Some data'</span>); <span class="comment">// идет вниз!</span></div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">app.controller(<span class="string">'SiblingOneCtrl'</span>,</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">SiblingOneCtrl</span> (<span class="params">$scope</span>) </span>&#123;</div><div class="line"></div><div class="line">  $scope.$on(<span class="string">'parent'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event, data</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(data); <span class="comment">// ‘Some data’</span></div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Если бы мы захотели передать сигнал вверх, из <code>SiblingOneCtrl</code> в <code>ParentCtrl</code>, как вы уже догадались, вы можете использовать <code>$emit</code>.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">app.controller(<span class="string">'ParentCtrl'</span>,</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">ParentCtrl</span> (<span class="params">$scope</span>) </span>&#123;</div><div class="line">  $scope.$on(<span class="string">'child'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event, data</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(data); <span class="comment">// 'Some data'</span></div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">app.controller(<span class="string">'SiblingOneCtrl'</span>,</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">SiblingOneCtrl</span> (<span class="params">$scope</span>) </span>&#123;</div><div class="line"></div><div class="line">  $scope.$emit(<span class="string">'child'</span>, <span class="string">'Some data'</span>); <span class="comment">// идем наверх!</span></div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Чтобы продемонстрировать как <code>$scope</code>работает, в момент запуска события, вот простая иерархия:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;div ng-controller=<span class="string">"ParentCtrl as parent"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"ng-scope"</span>&gt;</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-controller</span>=<span class="string">"SiblingOneCtrl as sib1"</span> <span class="attr">class</span>=<span class="string">"ng-scope"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line">  &lt;div ng-controller=<span class="string">"SiblingTwoCtrl as sib2"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"ng-scope"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line">&lt;<span class="regexp">/div&gt;</span></div></pre></td></tr></table></figure>
<p>Если <code>SiblingTwoCtrl</code> запустил <code>$scope.$broadcast</code>, тогда <code>SiblingOneCtrl</code> никогда не узнает, что случилось. Это может быть помехой, ее можно исправить, поставив небольшой костыль:</p>
<p><code>$scope.$parent.$broadcast(&#39;myevent&#39;, &#39;Some data&#39;);</code></p>
<p>Данный код обращается к <code>ParentCtrl</code> и уже оттуда запускает событие через<code>$broadcast</code></p>
<h3 id="rootScope-emit-broadcast"><a href="#rootScope-emit-broadcast" class="headerlink" title="$rootScope.($emit/$broadcast)"></a>$rootScope.($emit/$broadcast)</h3><p>Если вам все еще просто, то давайте добавим <code>$rootScope</code>. <code>$rootScope</code> - родительский элемент всех областей видимости, который делает каждый вновь созданный <code>$scope</code> его потомком! Выше я упомянул о том, как  <code>$scope</code>ограничен в направлениях распространения событий, а вот<code>$rootScope</code>- это то, как мы можем с легкостью передавать сигнал через все области видимостей. Данный подход будет решать некоторые проблемы с большей легкостью. К сожалению, все не настолько просто, как с передачей событий вверх или вниз…</p>
<h4 id="rootScope-emit-против-rootScope-broadcast"><a href="#rootScope-emit-против-rootScope-broadcast" class="headerlink" title="$rootScope.$emit против $rootScope.$broadcast"></a>$rootScope.$emit против $rootScope.$broadcast</h4><p>Объект $rootScope имеет аналогичные методы <code>$emit</code>, <code>$broadcast</code>и <code>$on</code>, но они работают немного иначе, нежели в <code>$scope</code>. Так как <code>$rootScope</code> не имеет <code>$parent</code> (родительской области видимости), использование $emit  было бы бессмысленным. Вместо этого <code>$rootScope.$emit</code> запустит событие только для слушателей, подписанных через <code>$rootScope.$on</code>. Самое интересное в том, что <code>$rootScope.$broadcast</code>уведомит как все <code>$rootScope.$on</code>, так и <code>$scope.$on</code> слушателей и это тонкое, но очень важное отличие, которое поможет избежать проблем с вашим приложением.</p>
<h4 id="rootScope-примеры"><a href="#rootScope-примеры" class="headerlink" title="$rootScope примеры"></a>$rootScope примеры</h4><p>Давайте рассмотрим еще более глубокую иерархию:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-controller</span>=<span class="string">"ParentCtrl as parent"</span> <span class="attr">class</span>=<span class="string">"ng-scope"</span>&gt;</span></div><div class="line">  // ParentCtrl</div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-controller</span>=<span class="string">"SiblingOneCtrl as sib1"</span> <span class="attr">class</span>=<span class="string">"ng-scope"</span>&gt;</span></div><div class="line">    // SiblingOneCtrl</div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-controller</span>=<span class="string">"SiblingTwoCtrl as sib2"</span> <span class="attr">class</span>=<span class="string">"ng-scope"</span>&gt;</span></div><div class="line">    // SiblingTwoCtrl</div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-controller</span>=<span class="string">"ChildCtrl as child"</span> <span class="attr">class</span>=<span class="string">"ng-scope"</span>&gt;</span></div><div class="line">      // ChildCtrl</div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>В примере выше есть 3 лексические области видимости (где родительские области видимости доступны в текущей области видимости, несколько разрывает голову при мысли об этом с точки зрения определения областей видимостей в DOM, но концептуально то что нам нужно там) и 4 области видимости в Ангуляре: <code>ParentCtrl</code>, <code>SiblingOneCtrl</code>, <code>SiblingTwoCtrl</code> и <code>ChildCtrl</code>. Две “братские” области видимости.</p>
<p>Используя <code>$scope.$emit</code>внутри <code>ChildCtrl</code> выльется в то,  что только <code>SiblingTwoCtrl</code> и <code>ParentCtrl</code> получат уведомления, так как событие вообще не распространилось на сиблингов, и затронуло лишь прямых предков (полностью игнорируя <code>SiblingOneCtrl</code>). Если бы мы использовали <code>$rootScope</code>, тогда бы мы могли затронуть и слушателей событий в  <code>$rootScope</code>.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">app.controller(<span class="string">'SiblingOneCtrl'</span>,</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">SiblingOneCtrl</span> (<span class="params">$rootScope</span>) </span>&#123;</div><div class="line"></div><div class="line">  $rootScope.$on(<span class="string">'rootScope:emit'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event, data</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(data); <span class="comment">// 'Emit!'</span></div><div class="line">  &#125;);</div><div class="line"></div><div class="line"></div><div class="line">  $scope.$on(<span class="string">'rootScope:broadcast'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event, data</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(data); <span class="comment">// 'Broadcast!'</span></div><div class="line">  &#125;);</div><div class="line"></div><div class="line"> $rootScope.$on(<span class="string">'rootScope:broadcast'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event, data</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(data); <span class="comment">// 'Broadcast!'</span></div><div class="line">  &#125;);</div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">app.controller(<span class="string">'ChildCtrl'</span>,</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">ChildCtrl</span> (<span class="params">$rootScope</span>) </span>&#123;</div><div class="line">  $rootScope.$emit(<span class="string">'rootScope:emit'</span>, <span class="string">'Emit!'</span>); <span class="comment">// $rootScope.$on</span></div><div class="line">  $rootScope.$broadcast(<span class="string">'rootScope:broadcast'</span>, <span class="string">'Broadcast'</span>); <span class="comment">// $rootScope.$on &amp;&amp; $scope.$on</span></div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="Отписываемся-от-событий-в-Angular-JS"><a href="#Отписываемся-от-событий-в-Angular-JS" class="headerlink" title="Отписываемся от событий в Angular.JS"></a>Отписываемся от событий в Angular.JS</h3><p><code>unsubscribe</code> - часто системы событий в AngularJS. Вы можете прекратить прослушку событий в любое время со слушателем <code>$on</code>. В отличие от других библиотек, здесь нет <code>$off</code> метода. Документация Ангуляра не особо внятно объясняет нам то, как правильно “прекращать прослушку”, она говорит, что <code>$on</code> “Возвращает функцию отмены регистрации для слушателя событий.” Мы можем предположить, что под этим они подразумевают замыкание, которое позволит нам прекращать прослушку событий.</p>
<p>Внутри исходного кода v1.3.0-beta.11, мы можем определить местонахождение $on метода и подтвердить подозрения на наличие замыкания:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">$on: <span class="function"><span class="keyword">function</span>(<span class="params">name, listener</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> namedListeners = <span class="keyword">this</span>.$$listeners[name];</div><div class="line">  <span class="keyword">if</span> (!namedListeners) &#123;</div><div class="line">    <span class="keyword">this</span>.$$listeners[name] = namedListeners = [];</div><div class="line">  &#125;</div><div class="line">  namedListeners.push(listener);</div><div class="line"></div><div class="line">  <span class="keyword">var</span> current = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">do</span> &#123;</div><div class="line">    <span class="keyword">if</span> (!current.$$listenerCount[name]) &#123;</div><div class="line">      current.$$listenerCount[name] = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    current.$$listenerCount[name]++;</div><div class="line">  &#125; <span class="keyword">while</span> ((current = current.$parent));</div><div class="line"></div><div class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    namedListeners[indexOf(namedListeners, listener)] = <span class="literal">null</span>;</div><div class="line">    decrementListenerCount(self, <span class="number">1</span>, name);</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Мы можем подписать и прекратить прослушку событий очень простым способом:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">app.controller(<span class="string">'ParentCtrl'</span>,</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">ParentCtrl</span> (<span class="params">$scope</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// подписываемся...</span></div><div class="line">  <span class="keyword">var</span> myListener = $scope.$on(<span class="string">'child'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event, data</span>) </span>&#123;</div><div class="line">    <span class="comment">// что-нибудь делаем</span></div><div class="line">  &#125;);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// отписываемся...</span></div><div class="line">  <span class="comment">// помещаем этот код куда-нибудь в колбэк или что-то подобное</span></div><div class="line">  myListener();</div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="scope-on-destroy"><a href="#scope-on-destroy" class="headerlink" title="$scope.$on $destroy"></a>$scope.$on $destroy</h3><p>Когда мы используем <code>$rootScope.$on</code>,  нам нужно отключать этих слушателей каждый раз, когда <code>$scope</code> уничтожается. Слушатели <code>$scope.$on</code> автоматически высвобождаются, но нам понадобится вызывать вышеупомянутое замыкание вручную в событии <code>$destroy</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">app.controller(<span class="string">'ParentCtrl'</span>,</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">ParentCtrl</span> (<span class="params">$scope</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// $rootScope $on</span></div><div class="line">  <span class="keyword">var</span> myListener = $rootScope.$on(<span class="string">'child'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event, data</span>) </span>&#123;</div><div class="line">    <span class="comment">//</span></div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  <span class="comment">// $scope $destroy</span></div><div class="line">  $scope.$on(<span class="string">'$destroy'</span>, myListener);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="Отмена-событий"><a href="#Отмена-событий" class="headerlink" title="Отмена событий"></a>Отмена событий</h3><p>Если вы выбрали использование <code>$emit</code>, один из слушателей событий в <code>$scope</code> может отменить его, и предотвратить распространение события вверх по цепочке. При использовании <code>$broadcast</code>событие не может быть отменено! Отмена события, которое было отправлено через <code>$emit</code> выглядит следующим образом:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$scope.$on(<span class="string">'myCustomEvent'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event, data</span>) </span>&#123;</div><div class="line">  event.stopPropagation();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="rootScope-listeners"><a href="#rootScope-listeners" class="headerlink" title="$rootScope.$$listeners"></a>$rootScope.$$listeners</h3><p>У каждого объекта AngularJS есть некоторые свойства, мы можем покопаться в них и наблюдать за тем, что случается “под капотом”. Мы можем взглянуть на <code>$rootScope.$$listeners</code>, чтобы наблюдать за жизненным циклом слушателей.<br>Мы так же можем прекратить прослушку событий с его помощью (но я бы не советовал вам этого делать):</p>
<p><code>$rootScope.$$listeners.myEventName = [];</code></p>
<h3 id="Распределение-событий-по-пространствам-имен"><a href="#Распределение-событий-по-пространствам-имен" class="headerlink" title="Распределение событий по пространствам имен"></a>Распределение событий по пространствам имен</h3><p>Обычно, если я работаю над конкретной фабрикой, я коммуницирую с другими директивами, контроллерами или даже фабриками, используя выделенное пространство имен для более чистой имплементации <code>pub/sub</code>, что делает код последовательным и позволяет избегать конфликтов имен.<br>Если бы я строил email приложение с ящиком входящих сообщений, то мы могли бы использовать пространство имен <code>inbox</code>для этого специального раздела. Это легко иллюстрируется несколькими простыми примерами:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$scope.$emit(<span class="string">'inbox:send'</span>[, data]);</div><div class="line">$scope.$on(<span class="string">'inbox:send'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event, data</span>) </span>&#123;...&#125;);</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$scope.$broadcast(<span class="string">'inbox:delete'</span>[, data]);</div><div class="line">$scope.$on(<span class="string">'inbox:delete'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event, data</span>) </span>&#123;...&#125;);</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$scope.$emit(<span class="string">'inbox:save'</span>[, data]);</div><div class="line">$scope.$on(<span class="string">'inbox:save'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event, data</span>) </span>&#123;...&#125;);</div></pre></td></tr></table></figure>
<p>По мотивам <a href="http://toddmotto.com/" target="_blank" rel="external">Todd Motto</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/images/angular_scope.png&quot; alt=&quot;Иллюстрация блокнота&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$emit&lt;/code&gt;, &lt;code&gt;$broadcast&lt;/code&gt; и &lt;code&gt;$on&lt;/code&gt; Ангуляра попадают под общий концепт “publish/subscribe”, так же называемый “могу сделать”, в которой вы публикуете событие и подписываетесь/отписываетесь от него еще где-то. Система событий в AngularJS великолепна, что делает вещи безупречными и легкими в исполнении (как и следовало ожидать!), но концепт, который стоит за этой простотой не так легок для освоения в совершенстве, поэтому очень часто у вас будет возникать недоумение по поводу того, почему все работает не так, как вы думаете.&lt;br&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="https://makeomatic.ru/blog/tags/Javascript/"/>
    
      <category term="AngularJS" scheme="https://makeomatic.ru/blog/tags/AngularJS/"/>
    
  </entry>
  
  <entry>
    <title>Создание модели данных в Angular.js</title>
    <link href="https://makeomatic.ru/blog/2014/09/18/Angular_data_modelling/"/>
    <id>https://makeomatic.ru/blog/2014/09/18/Angular_data_modelling/</id>
    <published>2014-09-18T07:00:00.000Z</published>
    <updated>2016-01-08T17:55:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><div class="text-center"><br>  <img src="/blog/images/modelling.jpg" alt="Иллюстрация блокнота"><br></div><br><br></p>
<p>Когда я впервые коснулся Ангуляра, у меня уже был опыт работы с EmberJS и BackboneJS, а так же были определенные представления относительно клиентских фреймворков. На первый взгляд, порог вхождения был ниже, чем у других фреймворков. Это хорошо, так как за короткий срок вы можете добиться значительных результатов в его освоении.<br><a id="more"></a></p>
<p>Для меня большой проблемой стала модель данных. Ангуляр позволяет вам самим решать этот вопрос.  С одной стороны, это хорошо, так как дает нам достаточную свободу, но за свободу всегда приходится чем-то платить.</p>
<p>EmberJS и BackboneJS имеют свои собственные Model/Store (Ember) и Model/Collection (Backbone) решения, итак давайте посмотрим как я справился с этой проблемой в Angular.<br>Для начала я приведу достаточно простой пример взаимодействия с API, с помощью которого мы получаем данные в виде JSON.</p>
<figure class="highlight js"><figcaption><span>Article.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line">app.factory(<span class="string">'Article'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$http, $q</span>) </span>&#123;</div><div class="line">  <span class="comment">// Сохраняем адресс API</span></div><div class="line">  <span class="keyword">var</span> apiUrl = <span class="string">'http://api.example.local'</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Объявляем класс модели данных</span></div><div class="line">  <span class="keyword">var</span> ArticleModel = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (data) &#123;</div><div class="line">      <span class="keyword">this</span>.setData(data);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="comment">// Добавляем prototype методы каждому объекту</span></div><div class="line">  ArticleModel.prototype.setData = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">    angular.extend(<span class="keyword">this</span>, data);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  ArticleModel.prototype.delete = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    $http.delete(apiUrl + <span class="string">'/articles/'</span> + <span class="keyword">this</span>._id).success(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">       <span class="comment">// Как-нибудь обрабатываем успешный запрос</span></div><div class="line">    &#125;).error(<span class="function"><span class="keyword">function</span>(<span class="params">data, status, headers, config</span>) </span>&#123;</div><div class="line">       <span class="comment">// Что-нибудь делаем в случае ошибки</span></div><div class="line">    &#125;);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  ArticleModel.prototype.update = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> $http.put(apiUrl + <span class="string">'/articles/'</span> + <span class="keyword">this</span>._id, <span class="keyword">this</span>).success(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="comment">// Как-нибудь обрабатываем успешный запрос</span></div><div class="line">    &#125;).error(<span class="function"><span class="keyword">function</span>(<span class="params">data, status, headers, config</span>) </span>&#123;</div><div class="line">      <span class="comment">// Что-нибудь делаем в случае ошибки</span></div><div class="line">    &#125;);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  ArticleModel.prototype.create = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    $http.post(apiUrl + <span class="string">'/articles/'</span>, <span class="keyword">this</span>).success(<span class="function"><span class="keyword">function</span>(<span class="params">r</span>) </span>&#123;</div><div class="line">      <span class="comment">// Как-нибудь обрабатываем успешный запрос</span></div><div class="line">    &#125;).error(<span class="function"><span class="keyword">function</span>(<span class="params">data, status, headers, config</span>) </span>&#123;</div><div class="line">      <span class="comment">// Что-нибудь делаем в случае ошибки</span></div><div class="line">    &#125;);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="comment">// Объявляем класс, который делаем запрос к API и возвращает объект модели с промисами</span></div><div class="line">  <span class="keyword">var</span> article = &#123;</div><div class="line"></div><div class="line">    <span class="attr">findAll</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> deferred = $q.defer();</div><div class="line">      <span class="keyword">var</span> scope = <span class="keyword">this</span>;</div><div class="line">      <span class="keyword">var</span> articles = [];</div><div class="line">      $http.get(apiUrl + <span class="string">'/articles'</span>).success(<span class="function"><span class="keyword">function</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">        array.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">          articles.push(<span class="keyword">new</span> ArticleModel(data));</div><div class="line">        &#125;);</div><div class="line">        deferred.resolve(articles);</div><div class="line">      &#125;).error(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        deferred.reject();</div><div class="line">      &#125;);</div><div class="line">      <span class="keyword">return</span> deferred.promise;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="attr">findOne</span>: <span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> deferred = $q.defer();</div><div class="line">      <span class="keyword">var</span> scope = <span class="keyword">this</span>;</div><div class="line">      <span class="keyword">var</span> data = &#123;&#125;;</div><div class="line">      $http.get(apiUrl + <span class="string">'/articles/'</span> + id).success(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">        deferred.resolve(<span class="keyword">new</span> ArticleModel(data));</div><div class="line">      &#125;)</div><div class="line">      .error(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        deferred.reject();</div><div class="line">      &#125;);</div><div class="line">      <span class="keyword">return</span> deferred.promise;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="attr">createEmpty</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ArticleModel(&#123;&#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> article;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Сейчас вы легко можете использовать ваши данные в контроллере, выводить в шаблоне, одним словом, делать с ними все, что хотите.<br>Используйте IndexController.js, чтобы загрузить все объекты из API. Используйте Check ShowController.js, для загрузки одного объекта из API:</p>
<figure class="highlight js"><figcaption><span>IndexController.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">app.controller(<span class="string">'IndexController'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$scope, Article</span>) </span>&#123;</div><div class="line">  <span class="comment">// Получаем все статьи</span></div><div class="line"> Articles.findAll().then(<span class="function"><span class="keyword">function</span>(<span class="params">articles</span>) </span>&#123;</div><div class="line">   $scope.articles = articles;</div><div class="line"> &#125;);</div><div class="line"> &#125;);</div></pre></td></tr></table></figure>
<figure class="highlight js"><figcaption><span>ShowController.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">app.controller(<span class="string">'ShowController'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$scope, Article</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// Получаем одну статью</span></div><div class="line">  <span class="keyword">var</span> articleId = <span class="number">1</span>; <span class="comment">// You have to get articleId from route paramters or as you want</span></div><div class="line">  Article.findOne(articleId).then(<span class="function"><span class="keyword">function</span>(<span class="params">article</span>) </span>&#123;</div><div class="line">    $scope.article = article;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Это только один из примеров применения. Существует несколько, а может и бесконечное количество вариантов получения данных с сервера, но данный вариант хорошо подошел для моего проекта.</p>
<p>В следующей части, я приведу более подробные и сложные примеры обработки данных в Ангуляр.</p>
<p>Все файлы для данного примера:</p>
<figure class="highlight js"><figcaption><span>EditController.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">app.controller(<span class="string">'EditController'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$scope, Article</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// Получаем одну статью</span></div><div class="line">  <span class="keyword">var</span> articleId = <span class="number">1</span>; <span class="comment">// Вы должны получить Id статьи из параметров url</span></div><div class="line">  Article.findOne(articleId).then(<span class="function"><span class="keyword">function</span>(<span class="params">article</span>) </span>&#123;</div><div class="line">    $scope.article = article;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  <span class="comment">// Изменим и обновим</span></div><div class="line">  $scope.article.title = <span class="string">"Some title"</span>;</div><div class="line">  $scope.article.update();</div><div class="line"></div><div class="line">  <span class="comment">// Удалим</span></div><div class="line">  $scope.article.delete();</div><div class="line"></div><div class="line">  <span class="comment">// Новая статья (создаем пустую модель)</span></div><div class="line">  $scope.newArticle = Article.createEmpty();</div><div class="line">  $scope.newArticle.title = <span class="string">"Some new title"</span>;</div><div class="line">  $scope.newArticle.create();</div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<figure class="highlight js"><figcaption><span>NewController.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">app.controller(<span class="string">'NewController'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$scope, Article</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// Новая статья (создаем пустую модель)</span></div><div class="line">  $scope.article = Article.createEmpty();</div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<figure class="highlight html"><figcaption><span>article.edit.html</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- Когда вы находитесь в шаблоне и у вас есть форма, вы можете использовать такие формовые элементы:: --&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"title"</span> <span class="attr">ng-model</span>=<span class="string">"article.title"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">ng-click</span>=<span class="string">"article.update()"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">ng-click</span>=<span class="string">"article.delete()"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- <span class="doctag">NOTE:</span> In this case do not forget to handle the success method on delete. For eg. redirect the user to another view --&gt;</span></div></pre></td></tr></table></figure>
<p>По мотивам Zoltan Radics</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;div class=&#39;text-center&#39;&gt;&lt;br&gt;  &lt;img src=&quot;/blog/images/modelling.jpg&quot; alt=&quot;Иллюстрация блокнота&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Когда я впервые коснулся Ангуляра, у меня уже был опыт работы с EmberJS и BackboneJS, а так же были определенные представления относительно клиентских фреймворков. На первый взгляд, порог вхождения был ниже, чем у других фреймворков. Это хорошо, так как за короткий срок вы можете добиться значительных результатов в его освоении.&lt;br&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="https://makeomatic.ru/blog/tags/Javascript/"/>
    
      <category term="AngularJS" scheme="https://makeomatic.ru/blog/tags/AngularJS/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch - наш ответ бюрократическим проволочкам в международной доставке!</title>
    <link href="https://makeomatic.ru/blog/2014/08/20/elastic_distribut/"/>
    <id>https://makeomatic.ru/blog/2014/08/20/elastic_distribut/</id>
    <published>2014-08-20T07:00:00.000Z</published>
    <updated>2016-01-08T17:55:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/images/elastic_distribut.png" alt="Иллюстрация блокнота"></p>
<p>Решать проблемы, с которыми ежедневно сталкиваются люди и компании, независимо от их сложности, стало обыденной практикой для нас в Makeomatic. Но когда к нам за помощью обратился клиент, с более чем 15-ти летним опытом в оказании услуг международной доставки, мы оказались в тупике. У нас не было даже представления о том, насколько сложным, запутанным и обманчивым может стать процесс отправки чего-либо за рубеж.<br>Потребовалось значительное время, чтобы подробно изучить эту область и предложить клиенту решение. Мы решили положится на высокие технологии, такие как Elasticsearch, Angular.js и Node.js. В результате нам удалось получить простую систему поиска кодов системы описания и кодирования товаров.</p>
<a id="more"></a>
<p>####Поиск по кодам доставки</p>
<p>Решение, предложенное Makeomatic, является частью проекта Distribut.io, который сэкономит вам кучу времени, взяв на себя бремя бумажной волокиты по оформлению зарубежной доставки. Но что делает его уникальным, так это возможность эффективного поиска по тысячам различных кодов, таможенных норм и правил.</p>
<p>Это все благодаря <a href="http://www.elasticsearch.org/" target="_blank" rel="external">Elasticsearch</a>, поисковому движку с открытым исходным кодом. Решение makeomatic не просто обрабатывает данные, он также предоставляет возможности искусственного интеллекта. Наша техническая составляющая способна в считанные секунды найти то, что надо в тоннах информации, именно поэтому она используется такими гигантами, как Foursquare, аудио-платформой Soundcloud, социальной сетью для разработчиков Github, рекомендательным сервисом StumbleUpon и многими другими. Elasticsearch анализирует данные в реальном времени, а также предоставляет обширные средства полнотекстового поиска. А теперь это все служит во благо пользователей Distribut.io.</p>
<p>Elasticsearch позволяет Distribut.io производить поиск по международным таможенным тарифам, международной стандартизированной системе имен и номеров для классификации торговой продукции, известной также, как таможенная гармонизированная система (Harmonized System, HS). <a href="https://ru.wikipedia.org/wiki/%D0%93%D0%B0%D1%80%D0%BC%D0%BE%D0%BD%D0%B8%D0%B7%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%B0%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D0%BE%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D1%8F_%D0%B8_%D0%BA%D0%BE%D0%B4%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F_%D1%82%D0%BE%D0%B2%D0%B0%D1%80%D0%BE%D0%B2" target="_blank" rel="external">HS</a> состоит из 21 секции и 96 глав, которые сопровождаются общими правилами толкования  пояснительными заметками и замечаниями, делая ручной поиск просто проклятьем.<br>Ниже представлена HS таблица с кодами в стандартном формате. Как быстро вы можете найти подзаголовок 1602 10, 1602 50 31 или 1602 50 95, чтобы определить соответствие экспортируемого товара HS коду?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">0206299132 10,07/01/96 12:00 AM,,EN,10,- - - - - ,Other</div><div class="line">0206299132 20,07/01/96 12:00 AM,,EN,10,- - - - - - ,&quot;Thin skirt, whole&quot;</div><div class="line">0206299132 30,07/01/96 12:00 AM,,EN,10,- - - - - - - ,Intended for processing</div><div class="line">0206299132 80,07/01/96 12:00 AM,,EN,10,- - - - - - - - ,&quot;For the manufacture of products falling within subheadings 1602 10, 1602 50 31 or 1602 50 95, not containing meat other than that of animals of the bovine species, with a collagen/protein ratio of no more than 0,45 and containing by weight at least 20% of lean meat (excluding offal and fat) with meat and jelly accounting for at least 85% of the total net weight	 the products must be subjected to a heat treatment sufficient to ensure the coagulation of meat proteins in the whole of the product and which therefore shows no traces of a pinkish liquid on the cut surface when the product is cut along a line passing through its thickest part (A-products)&quot;</div><div class="line">0206299134 80,07/01/96 12:00 AM,,EN,10,- - - - - - - - ,&quot;For the manufacture of products other than those falling within subheadings ex 0210 20, 0210 99 51, 0210 99 90, 1602 50 10 and 1602 90 61 (B-products)&quot;</div><div class="line">0206299136 80,07/01/96 12:00 AM,,EN,10,- - - - - - - - ,Other</div><div class="line">0206299139 80,01/01/89 12:00 AM,,EN,10,- - - - - - - ,Other</div><div class="line">0206299150 10,07/01/96 12:00 AM,,EN,10,- - - - - - ,Other</div><div class="line">0206299150 20,07/01/96 12:00 AM,,EN,10,- - - - - - - ,Intended for processing</div></pre></td></tr></table></figure>
<p>А что если подходящее описание, которое было так сложно найти, в свою очередь, содержит ссылки, отправляющие вас в очередной поиск?</p>
<p>А ведь то время, что вы затратили на то, чтобы разобраться в этом бюрократическом хаосе, вы могли бы использовать более полезно и эффективно. С Distribut.io вы можете больше не вспоминать об этих мучениях.  Вам больше не придется сравнивать HS коды. С помощью Elasticsearch, Distribut.io эффективно помогает подобрать нужный HS код для нужного товара, экономит время и деньги и позволяет владельцам малого и среднего бизнеса сосредоточится на реальном развитии их дела.</p>
<p>#####Разработка ваших идей с командой  Makeomatic<br>Если вы нашли наши идеи и их пути реализации умными и элегантными, тогда мы с радостью поможем решить ваши проблемы.</p>
<p>Вы можете нам написать письмо на getstarted@makeomatic.ru</p>
<p>Читайте так же статьи по теме:</p>
<ul>
<li><a href="https://makeomatic.ru/blog/2014/07/24/About_Distribut.io/">Доставка за границу - лучше, чем когда-либо!</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/images/elastic_distribut.png&quot; alt=&quot;Иллюстрация блокнота&quot;&gt;&lt;/p&gt;
&lt;p&gt;Решать проблемы, с которыми ежедневно сталкиваются люди и компании, независимо от их сложности, стало обыденной практикой для нас в Makeomatic. Но когда к нам за помощью обратился клиент, с более чем 15-ти летним опытом в оказании услуг международной доставки, мы оказались в тупике. У нас не было даже представления о том, насколько сложным, запутанным и обманчивым может стать процесс отправки чего-либо за рубеж.&lt;br&gt;Потребовалось значительное время, чтобы подробно изучить эту область и предложить клиенту решение. Мы решили положится на высокие технологии, такие как Elasticsearch, Angular.js и Node.js. В результате нам удалось получить простую систему поиска кодов системы описания и кодирования товаров.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="https://makeomatic.ru/blog/tags/Node-js/"/>
    
      <category term="AngularJS" scheme="https://makeomatic.ru/blog/tags/AngularJS/"/>
    
      <category term="ElasticSearch" scheme="https://makeomatic.ru/blog/tags/ElasticSearch/"/>
    
      <category term="ItProjects" scheme="https://makeomatic.ru/blog/tags/ItProjects/"/>
    
  </entry>
  
  <entry>
    <title>Дебаггинг приложения на AngularJS через консоль</title>
    <link href="https://makeomatic.ru/blog/2014/08/12/debugging_AngularJS_app/"/>
    <id>https://makeomatic.ru/blog/2014/08/12/debugging_AngularJS_app/</id>
    <published>2014-08-12T07:00:00.000Z</published>
    <updated>2016-01-08T17:55:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/images/debugging.jpg" alt="Иллюстрация блокнота"></p>
<p>При разработке приложений на AngularJS, сложно получить доступ к данным и сервисам, глубоко спрятанным в вашем приложении через JS консоль в Chrome, Firefox или Internet Explorer. Вот несколько простых фокусов, которые мы можем использовать, чтобы внимательно изучать и контролировать запущенное приложение через браузерную консоль, упрощая тестирование, видоизменение и даже программирования нашего приложения в реальном времени:</p>
<a id="more"></a>
<h4 id="1-Доступ-к-областям-видимости"><a href="#1-Доступ-к-областям-видимости" class="headerlink" title="1. Доступ к областям видимости"></a>1. Доступ к областям видимости</h4><p>Мы можем получать доступ к любым областям видимости (даже к изолированным) на странице всего одной строчкой js кода:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; angular.element(targetNode).scope()</div><div class="line">-&gt; ChildScope &#123;<span class="attr">$id</span>: <span class="string">"005"</span>, <span class="attr">this</span>: ChildScope, <span class="attr">$$listeners</span>: <span class="built_in">Object</span>, <span class="attr">$$listenerCount</span>: <span class="built_in">Object</span>, <span class="attr">$parent</span>: Scope…&#125;</div></pre></td></tr></table></figure>
<p>Или для изолированных областей видимости:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; angular.element(targetNode).isolateScope()</div><div class="line">-&gt; Scope &#123;<span class="attr">$id</span>: <span class="string">"009"</span>, <span class="attr">$$childTail</span>: ChildScope, <span class="attr">$$childHead</span>: ChildScope, <span class="attr">$$prevSibling</span>: ChildScope, <span class="attr">$$nextSibling</span>: Scope…&#125;</div></pre></td></tr></table></figure>
<p>Где <code>targetNode</code>- ссылка на <code>HTML Node</code>. Вы можете легко получить ссылку на одну из них через <code>document.querySelector()</code>.</p>
<h4 id="2-Исследование-иерархии-областей-видимости"><a href="#2-Исследование-иерархии-областей-видимости" class="headerlink" title="2. Исследование иерархии областей видимости"></a>2. Исследование иерархии областей видимости</h4><p>Иногда нам нужно увидеть как области видимости выглядят на странице, чтобы эффективно дебажить наше приложение. <a href="https://chrome.google.com/webstore/detail/angularjs-batarang/ighdmehidhipcmcojjgiloacoafjmpfk?hl=en" target="_blank" rel="external">AngularJS Batarang</a> - это Chrome расширение, которое показывает иерархию областей видимости в реальном времени и имеет некоторые другие полезные функции.</p>
<h4 id="3-Использование-любого-сервиса"><a href="#3-Использование-любого-сервиса" class="headerlink" title="3. Использование любого сервиса"></a>3. Использование любого сервиса</h4><p>Мы можем получить ссылку на любой сервис, используя функцию элемента <code>injector</code>, где <code>ngApp</code> определен, или косвенно, через любой элемент с <code>ng-scope</code> классом: </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; angular.element(<span class="built_in">document</span>.querySelector(<span class="string">'html'</span>)).injector().get(<span class="string">'MyService'</span>)</div><div class="line">-&gt; <span class="built_in">Object</span> &#123;<span class="attr">undo</span>: <span class="function"><span class="keyword">function</span>, <span class="title">redo</span>: <span class="title">function</span>, <span class="title">_pushAction</span>: <span class="title">function</span>, <span class="title">newDocument</span>: <span class="title">function</span>, <span class="title">init</span>: <span class="title">function</span>…&#125;</span></div><div class="line">// <span class="title">Or</span> <span class="title">slightly</span> <span class="title">more</span> <span class="title">generic</span></div><div class="line">&gt; <span class="title">angular</span>.<span class="title">element</span>(<span class="params">document.querySelector(<span class="string">'.ng-scope'</span></span>)).<span class="title">injector</span>(<span class="params"></span>).<span class="title">get</span>(<span class="params"><span class="string">'MyService'</span></span>)</div></pre></td></tr></table></figure>
<p>Тогда мы можем вызывать методы в этом сервисе, как если бы мы внедрили его как зависимость.</p>
<h4 id="4-Доступ-к-контроллеру-директивы"><a href="#4-Доступ-к-контроллеру-директивы" class="headerlink" title="4. Доступ к контроллеру директивы"></a>4. Доступ к контроллеру директивы</h4><p>Некоторые директивы определяют контроллер с дополнительной (часто общей) функциональностью. Чтобы получить доступ к экземпляру контроллера для данной директивы из консоли, просто используйте функцию <code>controller()</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; angular.element(<span class="string">'my-pages'</span>).controller()</div><div class="line">-&gt; Constructor &#123;&#125;</div></pre></td></tr></table></figure>
<p>Следующий пример более продвинут и не используется так часто</p>
<h4 id="5-Функции-Chrome-консоли"><a href="#5-Функции-Chrome-консоли" class="headerlink" title="5. Функции Chrome консоли"></a>5. Функции Chrome консоли</h4><p>У Chrome есть множество <a href="https://developer.chrome.com/devtools/docs/commandline-api" target="_blank" rel="external">удобных фич</a> для поиска ошибок браузерных приложений из консоли. Здесь несколько лучших из них для Angular разработки:</p>
<p>$0 - $4: Доступ к 5 последним выбранным DOM элементам в окне инспектора. Это удобно для получения доступа к областям видимости выбранных элементов:  </p>
<p><code>angular.element($0).scope()</code><br><code>$(selector)</code> и <code>$$(selector)</code>: быстрая замена для <code>querySelector()</code> и <code>querySelectorAll</code>, соответственно.</p>
<h5 id="Заключение"><a href="#Заключение" class="headerlink" title="Заключение"></a>Заключение</h5><p>С несколькими простыми фокусами мы можем получить доступ к данным для любой области видимости на странице, изучить иерархию области видимости, внедрять сервисы и контролировать директивы.<br>Так что в следующий раз, когда вы захотите внести небольшие корректировки, проверьте вашу работу или проконтролируйте AngularJS приложение через консоль, я надеюсь вы вспомните эти команды и найдете их полезными как и я!</p>
<p>По мотивам <a href="http://ionicframework.com/blog/angularjs-console/" target="_blank" rel="external">Max Lynch</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/images/debugging.jpg&quot; alt=&quot;Иллюстрация блокнота&quot;&gt;&lt;/p&gt;
&lt;p&gt;При разработке приложений на AngularJS, сложно получить доступ к данным и сервисам, глубоко спрятанным в вашем приложении через JS консоль в Chrome, Firefox или Internet Explorer. Вот несколько простых фокусов, которые мы можем использовать, чтобы внимательно изучать и контролировать запущенное приложение через браузерную консоль, упрощая тестирование, видоизменение и даже программирования нашего приложения в реальном времени:&lt;/p&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="https://makeomatic.ru/blog/tags/Javascript/"/>
    
      <category term="AngularJS" scheme="https://makeomatic.ru/blog/tags/AngularJS/"/>
    
  </entry>
  
</feed>
