<!DOCTYPE html><!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="ru"> <![endif]--><!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8" lang="ru"> <![endif]--><!--[if IE 8]>         <html class="no-js lt-ie9" lang="ru"> <![endif]--><!--[if gt IE 8]><!--> <html class="no-js" lang="ru"> <!--<![endif]--><head prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb# article: http://ogp.me/ns/article#"> <meta charset="utf-8">  <title>RabbitMQ: Простая и эффективная очередь сообщений | Блог Makeomatic: разработка сайтов и мобильных приложений</title> <meta name="author" content="Makeomatic">  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"> <!-- For third-generation iPad with high-resolution Retina display: --> <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144x144-precomposed.png"> <!-- For iPhone with high-resolution Retina display running iOS ≥ 7: --> <link rel="apple-touch-icon-precomposed" sizes="120x120" href="/apple-touch-icon-120x120-precomposed.png"> <!-- For iPhone with high-resolution Retina display running iOS ≤ 6: --> <link rel="apple-touch-icon-precomposed" sizes="114x114" href="/apple-touch-icon-114x114-precomposed.png"> <!-- For first- and second-generation iPad: --> <link rel="apple-touch-icon-precomposed" sizes="72x72" href="/apple-touch-icon-72x72-precomposed.png"> <!-- For non-Retina iPhone, iPod Touch, and Android 2.1+ devices: --> <link rel="apple-touch-icon-precomposed" href="/apple-touch-icon-precomposed.png"> <meta name="description" content="В этой статье рассмотрим, как работает RabbitMQ, а также как и для чего её можно использовать в проектах на Node.js Очереди сообщенийЧто такое очередь сообщений (message queue)? Это некая структура да">
<meta name="keywords" content="Node.js,RabbitMQ">
<meta property="og:type" content="article">
<meta property="og:title" content="RabbitMQ: Простая и эффективная очередь сообщений">
<meta property="og:url" content="https://makeomatic.ru/blog/2013/10/16/RabbitMQ/index.html">
<meta property="og:site_name" content="Блог Makeomatic: разработка сайтов и мобильных приложений">
<meta property="og:description" content="В этой статье рассмотрим, как работает RabbitMQ, а также как и для чего её можно использовать в проектах на Node.js Очереди сообщенийЧто такое очередь сообщений (message queue)? Это некая структура да">
<meta property="og:updated_time" content="2016-01-08T17:55:51.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RabbitMQ: Простая и эффективная очередь сообщений">
<meta name="twitter:description" content="В этой статье рассмотрим, как работает RabbitMQ, а также как и для чего её можно использовать в проектах на Node.js Очереди сообщенийЧто такое очередь сообщений (message queue)? Это некая структура да">
<meta name="twitter:creator" content="@makeomatic">
<link rel="publisher" href="https://plus.google.com/+MakeomaticRu">   <link href='//fonts.googleapis.com/css?family=Roboto:300,700&subset=latin,cyrillic,cyrillic-ext' rel='stylesheet' type='text/css'>  <link rel="stylesheet" href="/css/app.min.2.3.1.css">  <script src="/js/vendor/modernizr-2.6.2-respond-1.1.0.min.js"></script> <!-- place this in your head tag --> <!-- <script src='https://js.tito.io/v1' async></script> --> <!-- <link rel="stylesheet" type="text/css" href='https://css.tito.io/v1' /> --></head><body data-spy="scroll" data-target=".navbar" data-offset="150"><!--[if lt IE 8]><p class="chromeframe">Вы используете <strong>устаревший</strong> браузер. Пожалуйста <a href="http://browsehappy.com/">обновите ваш браузер</a> или <a href="http://www.google.com/chromeframe/?redirect=true">активируйте Google Chrome Frame</a>, чтобы улучшить ваши впечатления от посещения сайта.</p><![endif]--><header class="navbar navbar-inverse navbar-fixed-top"> <div class="navbar-inner"> <div class="container"> <div class="social-desktop"> <a class="fcb" href="https://www.facebook.com/makeomatic"> <i class="fa fa-facebook"></i> </a> <a class="vk" href="https://vk.com/makeomatic"> <i class="fa fa-vk"></i> </a> <a class="twt" href="https://twitter.com/MakeOmatic"> <i class="fa fa-twitter"></i> </a> <a class="gp" href="https://google.com/+MakeomaticRu"> <i class="fa fa-google-plus-square"></i> </a> </div> <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </a> <a class="brand" href="/">makeomatic</a> <div class="nav-collapse collapse"> <ul class="nav">   <li class='active '> <a href="/blog" > Блог  </a>  </li>   <li class=' dropdown'> <a href="/team" data-target="#" class="dropdown-toggle" data-toggle="dropdown"> Команда  <b class='caret'></b>  </a>  <ul class='dropdown-menu'>   <li> <a href="/team#vyacheslavgusev">Вячеслав Гусев</a> </li>   <li> <a href="/team#vitaliiaminev">Виталий Аминев</a> </li>   <li> <a href="/team#annaamineva">Анна Аминева</a> </li>   <li> <a href="/team#andreiafoninskii">Андрей Афонинский</a> </li>   <li> <a href="/team#aleksandrkremenets">Александр Кременец</a> </li>   <li> <a href="/team#dmitriigorbunov">Дмитрий Горбунов</a> </li>   <li> <a href="/team#evgeniipoyarkov">Евгений Поярков</a> </li>   <li> <a href="/team#ilyaovsyannikov">Илья Овсянников</a> </li>  </ul>  </li>   <li class=' '> <a href="/#about" > О нас  </a>  </li>   <li class=' dropdown'> <a href="/#portfolio" data-target="#" class="dropdown-toggle" data-toggle="dropdown"> Портфолио  <b class='caret'></b>  </a>  <ul class='dropdown-menu'>   <li> <a href="/#Distribut.io">Distribut.io</a> </li>   <li> <a href="/#Recordi">Recordi</a> </li>   <li> <a href="/#Photobot">Photobot</a> </li>   <li> <a href="/#BrainsApp">BrainsApp</a> </li>   <li> <a href="/#FabrikaTepla">FabrikaTepla</a> </li>   <li> <a href="/#SpeakGeo">SpeakGeo</a> </li>   <li> <a href="/#OpenInclude">OpenInclude</a> </li>   <li> <a href="/#LIVEONE">LIVEONE</a> </li>   <li> <a href="/#FitCafe">FitCafe</a> </li>  </ul>  </li>   <li class=' '> <a href="/#tech" > Технологии  </a>  </li>   <li class=' '> <a href="#contacts" > Контакты  </a>  </li>  </ul> </div><!--/.nav-collapse --> <div class='send-brief' > <a href='#brief' role='button' data-toggle='modal'> <i class='background'></i> <span>Заполнить бриф</span> </a> </div> <h4 class='phone-desktop'> Звоните: +7 (495) 79-222-44 </h4> </div> </div></header><div class="icon-up visible-desktop" id="up" title="наверх"></div><section class="container blog" id='blog'> <h1 class='outlined-caption text-center'> <a href='/blog'>Блог Makeomatic: разработка сайтов и мобильных приложений</a> </h1>  <div class='row'> <div class='span10'><article class="post"> <div class="post-content"> <header class='post-header'>   <h2 class="title">RabbitMQ: Простая и эффективная очередь сообщений</h2> <p class='muted'>что такое RabbitMQ и его применение</p>   <div class="icon"></div> <time datetime="2013-10-16T07:00:00.000Z"> Oct 16 2013 </time>   <div class="tags"> | Категории: <a href="/blog/tags/Node-js/">Node.js</a>, <a href="/blog/tags/RabbitMQ/">RabbitMQ</a> </div> <span class='author'><img src='//www.gravatar.com/avatar/3a2726c7eb6c74fec78f3a106a06e119?s=20' /> Дмитрий Горбунов</span>  </header> <section class="body">  <p>В этой статье рассмотрим, как работает RabbitMQ, а также как и для чего её можно использовать в проектах на Node.js</p>
<h2 id="Очереди-сообщений"><a href="#Очереди-сообщений" class="headerlink" title="Очереди сообщений"></a>Очереди сообщений</h2><p>Что такое очередь сообщений (<code>message queue</code>)? Это некая структура данных, которая обеспечивает хранение и передачу двоичных данных (<code>blobs</code>) между различными участниками системы. Очереди сообщений практически всегда используются в крупных системах, благодаря важным преимуществам.</p>
<ul>
<li><strong><em>Независимость</em></strong> компонентов системы друг от друга. Благодаря использованию очереди, компоненты взаимодействуют через некий общий интерфейс, но ничего не знают о существовании друг друга.</li>
<li><strong><em>Экономия ресурсов</em></strong> достигается вследствие возможности разумно распределять информацию, поступающую в очередь от одних процессов, между другими процессами, осуществляющими её обработку. Кроме того, благодаря тому, что нет необходимости промежуточного хранения необработанных данных, достигается дополнительная экономия ресурсов.</li>
<li><strong><em>Надежность</em></strong> очередей достигается благодаря возможности накапливать сообщения, амортизируя недостаток вычислительных возможностей системы, а также благодаря независимости компонентов. Помимо этого очередь может аккомодировать сбои отдельных компонентов, осуществляя доставку «опоздавших» сообщений после восстановления.</li>
<li>И, наконец, <strong><em>гарантия последовательной обработки</em></strong>, позволяющая точно контролировать потоки данных в системе и запускать асинхронную обработку там, где это необходимо, не беспокоясь, что одна операция выполнится раньше другой, от результата которой она зависит.</li>
</ul>
<p>Учитывая огромную важность очередей для надёжных и гибких систем обработки данных, была даже разработана спецификация протокола — AMQP, на основе которой разрабатывается несколько приложений, выполняющих функцию очереди — так называемых «<strong>брокеров</strong>». Аналогия с биржевыми процессами будет прослеживаться и в дальнейшем. Мы рассмотрим брокер RabbitMQ, авторами которого и создан протокол AMQP.<br><a id="more"></a></p>
<h2 id="Почему-RabbitMQ"><a href="#Почему-RabbitMQ" class="headerlink" title="Почему RabbitMQ?"></a>Почему RabbitMQ?</h2><p>Причин несколько, но одна из основных — реализация приложения на платформе Erlang/OTP, гарантирующая максимальную стабильность и масштабируемость очереди, как ключевого узла всей системы. Другая причина — полная открытость приложения, распространяющегося по лицензии Mozilla Public License и реализация открытого протокола AMQP, библиотеки для которого существуют во всех основных языках и платформах программирования. В том числе и для Node.js</p>
<h2 id="Основные-понятия"><a href="#Основные-понятия" class="headerlink" title="Основные понятия"></a>Основные понятия</h2><h3 id="Брокер"><a href="#Брокер" class="headerlink" title="Брокер"></a>Брокер</h3><p>Под брокером мы будем понимать сам сервер RabbitMQ. Брокер может быть один, брокеров может быть несколько, объединённых в общий кластер. Брокер занимается непосредственно передачей сообщений. Однако на внутреннем уровне происходит намного больше процессов, нежели просто передача байтиков по сети.</p>
<h3 id="Очередь"><a href="#Очередь" class="headerlink" title="Очередь"></a>Очередь</h3><p>Очередь — основной логический компонент брокера. Именно из очереди клиент (<code>consumer</code>) забирает сообщения. Другое дело, что очередь не единственный участник обмена.</p>
<h3 id="Биржа"><a href="#Биржа" class="headerlink" title="Биржа"></a>Биржа</h3><p>Биржа (<strong>exchange</strong>, иногда переводится как «обмен») играет важнейшую роль в направлении сообщений от отправителя (<code>producer</code>) к клиенту (<em>consumer</em>, он же потребитель). Дело в том, что именно благодаря бирже, поступающее от отправителя сообщение направляется в нужную очередь. Кроме того, у сообщения может присутствовать метка (<code>routingKey</code>) (ключ м<br>Это наиболее важная строчка, в которой мы сообщаем брокеру, что сообщение было принято, полностью обработано и его можно безопасно удалить из очереди. Если такое подтверждение брокеру не отправить, то сообщение никогда не будет удалено из очереди и постепенно брокер заполнит всю оперативную память сервера. Будьте внимательны — это одна из самых частых ошибок при работе с очередью.</p>
<p><strong>Важно</strong>: отправляйте <code>ack</code> только когда сообщение <em>действительно</em> полностью обработано и его можно удалить. Это будет гарантировать две вещи:</p>
<ul>
<li>Не будет потерянных сообщений</li>
<li>Очередь сможет распределять нагрузку максимально честно, т.к. пока от клиента не придёт подтверждение, что обработка завершена, новое сообщение ему отправлено не будет</li>
</ul>
<p><strong>Важно</strong>: если сообщение обработать невозможно по техническим или каким-то другим причинам у вас есть два варианта.</p>
<ul>
<li>Всё равно отправить <code>ack</code> и навсегда потерять сообщение</li>
<li>Вызывать <code>channel.nack</code>, отказавшись принимать и обрабатывать сообщение, тогда очередь добавит сообщение в конец и со временем оно снова будет отправлено на обработку (возможно другому клиенту)</li>
</ul>
<p><strong>Обратите внимание: брокер по-умолчанию сам распределяет нагрузку между клиентами, вам ничего не нужно для этого делать. Один у вас клиент, или пятьдесят — брокеру всё равно.</strong></p>
<h3 id="Publish-Subscribe-он-же-Broadcast"><a href="#Publish-Subscribe-он-же-Broadcast" class="headerlink" title="Publish-Subscribe (он же Broadcast)"></a>Publish-Subscribe (он же Broadcast)</h3><p>Никто не запрещает отправлять сообщения <em>сразу всем</em> клиентам, а не по алгоритму round-robin. Это позволяет использовать очередь в качестве сервера pubsub. Всё, что для этого нужно сделать — определить биржу типа <strong>fanout</strong>. Делается это в вызове <code>assertExchange</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">channel.assertExchange(<span class="string">"incoming"</span>, <span class="string">"fanout"</span>)</div></pre></td></tr></table></figure>
<p>Как видно, тип биржи передаётся вторым параметром. Поменяйте код отправителя и клиентов (помните, что определения бирж и очередей должны совпадать), как показано выше и попробуйте запустить несколько клиентов. Посмотрите, как будут распределяться сообщения теперь.</p>
<p>Всего одно маленькое дополнение — и совершенно изменившийся алгоритм работы. Как видите, для того, чтобы менять поведение брокера, вовсе не нужно лезть в глубокие настройки сервера. Достаточно слегка поменять код.</p>
<h3 id="Маршрутизация-по-шаблону"><a href="#Маршрутизация-по-шаблону" class="headerlink" title="Маршрутизация по шаблону"></a>Маршрутизация по шаблону</h3><p>Как вы заметили, тип биржи определяет алгоритм работы брокера. Типом по-умолчанию является direct. Этот тип отправляет сообщения в чётком соответствии с <code>routingKey</code>, биржей и очередью. Тип <code>fanout</code> осуществляет доставку сообщений всем и сразу. А вот тип topic позволяет избирательно доставлять сообщения по шаблону, передаваемому всё в том же <code>routingKey</code>. Только формат этого параметра теперь становится особенным.</p>
<p>Метка должна содержать несколько слов, разделённых точкой. Например: «a.b» или «animals.feline.tiger». Должна присутствовать по крайней мере одна точка. Максимальный размер метки — 255 байт. Обратите внимание: не символов, байт. Если вы используете символы Unicode, то имейте это ввиду.</p>
<p>Существует два особых знака, которые используются в routingKey <em>при привязке очереди к бирже по метке</em> (и только тогда, но не при отправке!):</p>
<ul>
<li>«*», обозначающая <em>ровно одно слово</em> (например: «animals.feline.*» — подойдёт к «animals.feline.tiger», но не к «animals.feline.leopard.panther»)</li>
<li>«#», обозначающий <em>ноль или более слов</em> (например: «animals.#» — подойдёт и к «animals.feline» и к «animals.canine.wolf»)</li>
</ul>
<p>Следующая привязка</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">channel.bindQueue(<span class="string">"messages"</span>, <span class="string">"incoming"</span>, <span class="string">"animals.feline.*"</span>)</div></pre></td></tr></table></figure>
<p>Позволит нам принимать все сообщения о животных из семейства кошачьих, не имеющих подвидов.</p>
<p>Ну а следующее сообщение будет получено клиентом, который добавил вышестоящую привязку:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">channel.publish(<span class="string">"incoming"</span>, <span class="string">"animals.feline.tiger"</span>, <span class="keyword">new</span> Buffer(<span class="string">"Rroarrrr!"</span>))</div></pre></td></tr></table></figure>
<p>Зато такое сообщение им принято не будет:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">channel.publish(<span class="string">"incoming"</span>, <span class="string">"animals.feline.cat.domestic"</span>, <span class="keyword">new</span> Buffer(<span class="string">"Meow!"</span>))</div></pre></td></tr></table></figure>
<h3 id="Remote-Procedure-Call"><a href="#Remote-Procedure-Call" class="headerlink" title="Remote Procedure Call"></a>Remote Procedure Call</h3><p>Иногда возникает потребность передать сообщение обработчику <strong><em>И</em></strong> дождаться ответа. Этот сценарий описывает систему «удалённого вызова процедур». Такая система тоже вполне может быть построена с помощью RabbitMQ. Посмотрим, как это сделать.</p>
<h4 id="Клиент"><a href="#Клиент" class="headerlink" title="Клиент"></a>Клиент</h4><p>На клиенте всё очень просто: в вызов publish добавляется специальная опция replyTo, значением которой является имя очереди, в которой клиент будет ожидать ответ. Обратите внимание, что в данном случае клиент обращается к серверу именно через publish, поскольку он хочет вызвать удалённую процедуру, находящуюся на сервере. В данном сценарии отправителем будет являться клиент, а потребителем — сервер. Затем их роли поменяются местами, когда сервер отправит клиенту ответ.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">channel.publish(<span class="string">"api"</span>, <span class="string">"calculate"</span>, <span class="keyword">new</span> Buffer(<span class="string">"2 + 3"</span>), &#123;<span class="attr">replyTo</span>: <span class="string">"api-reply"</span>, <span class="attr">correlationId</span>: <span class="string">"calculate-1"</span>&#125;)</div></pre></td></tr></table></figure>
<p>Подразумевается, что очередь “api-reply” существует. Однако здесь следует заметить вот что: поскольку клиент ожидает ответ на конкретный вызов, то очередь, в которую придёт ответ должна быть уникальна. Для этой ситуации предусмотрена опция <code>exclusive: true</code> в вызове <code>assertQueue</code> — она гарантирует, что данная очередь будет доступна исключительно вызывавшему <code>assertQueue</code> клиенту и видна только в пределах канала связи. Мы могли бы создавать такую эксклюзивную очередь для <em>каждого</em> отдельного вызова RPC. Но это было бы крайне неэффективно (зато очень просто в реализации). Более выгодным вариантом является создание одной очереди на клиента<br>маршрутизации), которая дополнительно повлияет на решение брокера о том, в какую очередь сообщение будет отправлено.</p>
<p>Обратите внимание: очередь вторична по отношению к бирже. Именно биржа определяет, куда пойдёт сообщение, в какую очередь. Клиенты же могут принимать сообщения только из очереди, поэтому если вы не хотите разбираться с кучей проблем и передать всю маршрутизацию сообщений брокеру — имейте следующее в виду: <em>если вы хотите отделить одни сообщения от других, их нужно разместить в разных очередях</em>.</p>
<p>Другими словами, сообщения в одной очереди должны быть одинаковы по структуре, чтобы вы могли корректно и без усилий распределять их по системе. Рассматривайте очередь как набор элементов одинакового типа.</p>
<h2 id="Варианты-работы"><a href="#Варианты-работы" class="headerlink" title="Варианты работы"></a>Варианты работы</h2><h3 id="Прямая-передача"><a href="#Прямая-передача" class="headerlink" title="Прямая передача"></a>Прямая передача</h3><p>В этом варианте в самом простом случае у нас один клиент и один отправитель. Отправитель шлёт сообщение в очередь, клиент слушает очередь, достаёт из неё сообщения и обрабатывает их. Рассмотрим как это работает на следующем примере.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> rabbit = <span class="built_in">require</span>(<span class="string">"amqplib"</span>).connect()</div><div class="line">rabbit.then(<span class="function"><span class="keyword">function</span>(<span class="params">connection</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> ok = connection.createChannel()</div><div class="line"></div><div class="line">	ok.then(<span class="function"><span class="keyword">function</span>(<span class="params">channel</span>) </span>&#123;</div><div class="line">		<span class="comment">// durable: true is set by default</span></div><div class="line">		channel.assertQueue(<span class="string">"messages"</span>)</div><div class="line">		channel.assertExchange(<span class="string">"incoming"</span>)</div><div class="line">		channel.bindQueue(<span class="string">"messages"</span>, <span class="string">"incoming"</span>, <span class="string">"mda"</span>)</div><div class="line"></div><div class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</div><div class="line">			channel.publish(<span class="string">"incoming"</span>, <span class="string">"mda"</span>, <span class="keyword">new</span> Buffer(<span class="string">"Hello "</span> + i), &#123;<span class="attr">deliveryMode</span>: <span class="literal">true</span>&#125;)</div><div class="line">	&#125;)</div><div class="line"></div><div class="line">	<span class="keyword">return</span> ok</div><div class="line">&#125;).then(<span class="literal">null</span>, <span class="built_in">console</span>.log)</div></pre></td></tr></table></figure>
<p>Для работы с RabbitMQ в Node.js лучше всего использовать библиотеку <code>amqplib</code>, реализующую соответствующий протокол. В этом случае вы можете использовать любой брокер, который соответствует этому протоколу.</p>
<p>Библиотека вносит ещё один элемент в работу с очередью: канал. Однако это не более чем просто канал связи между брокером и общающимся с ним компонентом системы. Не следует рассматривать его как часть брокера или очереди сообщений.</p>
<h3 id="Связь-с-брокером-и-создание-канала"><a href="#Связь-с-брокером-и-создание-канала" class="headerlink" title="Связь с брокером и создание канала"></a>Связь с брокером и создание канала</h3><p>Рассмотрим по порядку, что происходит после установления связи с брокером и создания канала.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">channel.assertQueue(<span class="string">"messages"</span>)</div><div class="line">channel.assertExchange(<span class="string">"incoming"</span>)</div></pre></td></tr></table></figure>
<p>Два этих вызова обеспечивают существование очереди и биржи. Каждая очередь и биржа создаётся лишь один раз, а вызовы никак не влияют на уже существующие объекты. Очередь можно создать с дополнительными параметрами, важнейшим из которых является параметр <code>durable</code> — он влияет на то, будут ли сообщения в очереди сохранены в случае падения брокера. По-умолчанию в данной библиотеке этот параметр установлен в <code>true</code>. Подробнее обо всех параметрах создания очереди и биржи можно прочесть в документации к библиотеке. Отметим лишь, что в дальнейших примерах мы воспользуемся разными типами бирж.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">channel.bindQueue(<span class="string">"messages"</span>, <span class="string">"incoming"</span>, <span class="string">"mda"</span>)</div></pre></td></tr></table></figure>
<p>Этот вызов осуществляет привязку очереди к бирже и сообщению с конкретным <code>routingKey</code>: очередь messages привязывается к бирже <code>incoming</code>, которая должна передавать в эту очередь сообщения с меткой <code>mda</code>. Теперь мы можем либо принимать сообщения из этой очереди, будучи уверенными, что наш клиент через конкретный данный канал будет получать лишь сообщения с меткой <code>mda</code>, переданные через биржу <code>incoming</code>. Либо передавать сообщения в биржу incoming с меткой <code>mda</code>, зная, что они попадут в очередь <code>messages</code>. Если мы попытаемся передать сообщение с другой меткой, оно уйдёт в <code>/dev/null</code>, поскольку мы привязали лишь одну конкретную метку. Если мы попытаемся передать сообщение в несуществующую биржу, оно уйдёт в <code>/dev/null</code>, если привязать биржу к несуществующей очереди — тоже.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">channel.publish(<span class="string">"incoming"</span>, <span class="string">"mda"</span>, <span class="keyword">new</span> Buffer(<span class="string">"Hello "</span> + i), &#123;<span class="attr">deliveryMode</span>: <span class="literal">true</span>&#125;)</div></pre></td></tr></table></figure>
<p>Далее мы в цикле передаём сто сообщений бирже <code>incoming</code> с меткой <code>mda</code> (она же <code>routingKey</code>) и опцией <code>deliveryMode: true</code>, означающей что сообщение будет сохранено в очереди, если брокер выйдет из строя на время. Следует заметить, что сохранение сообщения на диск — операция медленная, и брокер может упасть в её процессе. Так что абсолютной надёжности эта опция не даёт.</p>
<p>Сто сообщений мы передаём для демонстрации масштабирования системы исключительно средствами брокера, что очень просто и безболезненно.</p>
<h3 id="Клиент-для-тестирования-отправителя"><a href="#Клиент-для-тестирования-отправителя" class="headerlink" title="Клиент для тестирования отправителя"></a>Клиент для тестирования отправителя</h3><p>Рассмотрим клиент, который нам нужен для тестирования отправителя. Запустим два или даже три таких клиента, после чего запустим отправителя, и убедимся, что все сообщения были распределены между клиентами максимально честно, по алгоритму round-robin.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> rabbit = <span class="built_in">require</span>(<span class="string">"amqplib"</span>).connect()</div><div class="line">rabbit.then(<span class="function"><span class="keyword">function</span>(<span class="params">connection</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> ok = connection.createChannel()</div><div class="line"></div><div class="line">	ok.then(<span class="function"><span class="keyword">function</span>(<span class="params">channel</span>) </span>&#123;</div><div class="line">		<span class="comment">// durable: true is set by default</span></div><div class="line">		channel.assertQueue(<span class="string">"messages"</span>)</div><div class="line">		channel.assertExchange(<span class="string">"incoming"</span>)</div><div class="line">		channel.bindQueue(<span class="string">"messages"</span>, <span class="string">"incoming"</span>, <span class="string">"mda"</span>)</div><div class="line"></div><div class="line">		channel.consume(<span class="string">"messages"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</div><div class="line">			<span class="built_in">console</span>.log(message.content.toString())</div><div class="line"></div><div class="line">			channel.ack(message)</div><div class="line">		&#125;)</div><div class="line">	&#125;)</div><div class="line"></div><div class="line">	<span class="keyword">return</span> ok</div><div class="line">&#125;).then(<span class="literal">null</span>, <span class="built_in">console</span>.log)</div></pre></td></tr></table></figure>
<p><strong>Обратите внимание</strong>: насколько код клиента похож на код отправителя. Отличается лишь то, что вместо отправки сообщений, мы принимаем их. Как было сказано выше, принимать сообщения можно лишь из очереди (так же как отправлять — только на биржу).</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">channel.ack(message)</div></pre></td></tr></table></figure>
<p><em>Однако в этом случае возникает вопрос</em>: как отделить ответ на один вызов от другого? Для этой ситуации предназначен ещё один параметр вызова <code>publish</code>: <code>correlationId</code>. Он принимает строковое значение и возвращается в ответе от сервера, чтобы клиент мог на его основе определить, результат какого вызова он получил только что. Его можно генерировать случайным образом. Если же клиенту приходит ответ с неизвестным <code>correlationId</code>, то его можно смело игнорировать. Такое может случиться из-за рассинхронизации сервера и брокера, например, в случае падения сервера.</p>
<h3 id="Общий-алгоритм-работы"><a href="#Общий-алгоритм-работы" class="headerlink" title="Общий алгоритм работы"></a>Общий алгоритм работы</h3><ol>
<li>При запуске клиент создаёт эксклюзивную для себя очередь</li>
<li>Для каждого вызова клиент отправляет дополнительные параметры: <code>replyTo</code> и <code>correlationId</code>. Последний должен быть уникален для вызова.</li>
<li>Сервер слушает очередь, в которую отправляются вызовы от клиентов (обратите внимание, это <em>не</em> <code>replyTo</code>, а ещё одна отдельная очередь, общая для всех клиентов и сервера)</li>
<li>При поступлении запроса, сервер обрабатывает его и отправляет ответ в очередь <code>replyTo</code> вместе с <code>correlationId</code>, полученными от клиента в запросе</li>
<li>Клиент слушает очередь <code>replyTo</code>, при поступлении туда сообщения, он соотносит <code>correlationId</code> с имеющейся у него таблицей вызовов и обрабатывает результат</li>
</ol>
<p><strong>Замечание</strong>: если отправить сообщение через <code>publish</code> с пустым значением имени «биржи», а в качестве <code>routingKey</code> указать значение <code>replyTo</code>, то сообщение уйдёт по назначению:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">channel.publish(<span class="string">""</span>, request.properties.replyTo, <span class="keyword">new</span> Buffer(<span class="string">"5"</span>), &#123;<span class="attr">correlationId</span>: request.properties.correlationId&#125;)</div></pre></td></tr></table></figure>
<p>Аналогично можно отправлять сообщения и с клиента в очередь <code>rpc</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">channel.publish(<span class="string">""</span>, <span class="string">"rpc"</span>, <span class="keyword">new</span> Buffer(<span class="string">"2 + 3"</span>), &#123;<span class="attr">replyTo</span>: <span class="string">"rpc-reply-1"</span>, <span class="attr">correlationId</span>: <span class="string">"calculate-1"</span>&#125;)</div></pre></td></tr></table></figure>
<p>Читайте так же статьи по теме:</p>
<ul>
<li><a href="https://makeomatic.ru/blog/2014/03/17/Sharing_modules/">Совместное использование модулей между NodeJS и AngularJS</a></li>
</ul>
  </section> <footer class='post-footer clearfix'>   <div class="addthis_toolbox addthis_default_style pull-right"> <a class="addthis_button_facebook"></a> <a class="addthis_button_twitter"></a> <a class="addthis_button_vk"></a> <a class="addthis_button_compact"></a> <a class="addthis_counter addthis_bubble_style"></a></div><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>  </footer> </div></article><section id="comment"> <h3 class="title">Комментарии</h3> <div id="disqus_thread"> <noscript>Включите Javascript, чтобы просмотреть <a href="//disqus.com/?ref_noscript">комментарии с помощью Disqus.</a></noscript> </div></section></div> <aside class="span2">  <div class="widget tag"> <h3 class="title">Тэги</h3> <ul class="unstyled">  <li> <span class='badge'>31</span> <a href="/blog/tags/AngularJS/"> AngularJS </a> </li>  <li> <span class='badge'>2</span> <a href="/blog/tags/CSS/"> CSS </a> </li>  <li> <span class='badge'>1</span> <a href="/blog/tags/Chef/"> Chef </a> </li>  <li> <span class='badge'>1</span> <a href="/blog/tags/Coffee-script/"> Coffee-script </a> </li>  <li> <span class='badge'>1</span> <a href="/blog/tags/Cordova/"> Cordova </a> </li>  <li> <span class='badge'>5</span> <a href="/blog/tags/ElasticSearch/"> ElasticSearch </a> </li>  <li> <span class='badge'>5</span> <a href="/blog/tags/FAQ/"> FAQ </a> </li>  <li> <span class='badge'>2</span> <a href="/blog/tags/GitHub/"> GitHub </a> </li>  <li> <span class='badge'>2</span> <a href="/blog/tags/HTML5/"> HTML5 </a> </li>  <li> <span class='badge'>2</span> <a href="/blog/tags/ItProjects/"> ItProjects </a> </li>  <li> <span class='badge'>30</span> <a href="/blog/tags/Javascript/"> Javascript </a> </li>  <li> <span class='badge'>1</span> <a href="/blog/tags/Mongoose/"> Mongoose </a> </li>  <li> <span class='badge'>11</span> <a href="/blog/tags/Node-js/"> Node.js </a> </li>  <li> <span class='badge'></span> <a href="/blog/tags/NodeJS/"> NodeJS </a> </li>  <li> <span class='badge'>1</span> <a href="/blog/tags/Objective-C/"> Objective-C </a> </li>  <li> <span class='badge'>1</span> <a href="/blog/tags/PhoneGap/"> PhoneGap </a> </li>  <li> <span class='badge'>1</span> <a href="/blog/tags/RabbitMQ/"> RabbitMQ </a> </li>  <li> <span class='badge'>2</span> <a href="/blog/tags/SEO/"> SEO </a> </li>  <li> <span class='badge'>3</span> <a href="/blog/tags/SQL/"> SQL </a> </li>  <li> <span class='badge'>1</span> <a href="/blog/tags/YAC2014/"> YAC2014 </a> </li>  <li> <span class='badge'>1</span> <a href="/blog/tags/bash/"> bash </a> </li>  <li> <span class='badge'>1</span> <a href="/blog/tags/iOS7/"> iOS7 </a> </li>  <li> <span class='badge'>2</span> <a href="/blog/tags/jQuery/"> jQuery </a> </li>  <li> <span class='badge'>1</span> <a href="/blog/tags/Бизнес-модель/"> Бизнес модель </a> </li>  <li> <span class='badge'>4</span> <a href="/blog/tags/Для-новичков/"> Для новичков </a> </li>  <li> <span class='badge'>1</span> <a href="/blog/tags/Жизнь-компании/"> Жизнь компании </a> </li>  </ul></div></aside> </div></section> <!-- /container --><footer id='contacts' class='footer-main'> <div class='callback'> <div class='container'> <div class='row'> <div class='span12'> <h2 class='xlarge'>Есть вопросы или предложения?</h2> <p class='outlined-caption'>закажите обратный звонок и наш менеджер перезвонит вам</p> <form method='POST' action='/brief' id='callback'> <ul class='hidden error'></ul> <input type="text" name='name' placeholder="Как к вам обратиться?" class='span12' required /> <input type="text" name='phone' placeholder="По какому номеру звонить?" class='span6' /> <input type="email" name='email' placeholder="E-mail (опционально)" class='span6 pull-right' /> <textarea name='question' placeholder="Ваш вопрос (опционально)" class='span12'></textarea> <button type="submit" class='blue-plank'>Заказать звонок</button> </form> </div> </div> </div> </div> <div class='container'> <div class='row'> <div class='span6'> <h4 class='footer-caption'>Разделы сайта</h4> <ul class="nav inline">  <li><a href="/blog">Блог</a></li>  <li><a href="/team">Команда</a></li>  <li><a href="#about">О нас</a></li>  <li><a href="#portfolio">Портфолио</a></li>  <li><a href="#tech">Технологии</a></li>  <li><a href="#contacts">Контакты</a></li>  <li><a href='https://github.com/AVVSDevelopment/avvs.co'>Проект на GitHub</a></li> </ul> <p class='copyright'>Makeomatic, (c) 2012-2016<br/>Разработка сайтов и мобильных приложений</p> </div> <div class='span6 blue-line'> <h4 class='footer-caption'>Контакты</h4> <p> тел: +7 (495) 79-222-44 </p> <p> e-mail: <a href="mailto:getstarted@makeomatic.ru">getstarted@makeomatic.ru</a> </p> <address> Россия, Москва, Ленинский пр-т, дом 30а<br/>индекс: 111555 </address> <div class="social"> <a class="fcb fa-stack fa-lg" href="https://www.facebook.com/makeomatic"> <i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-facebook fa-stack-1x fa-inverse"></i> </a> <a class="fa-stack fa-lg" href="http://vk.com/makeomatic"> <i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-vk fa-stack-1x fa-inverse"></i> </a> <a class="twt fa-stack fa-lg" href="https://twitter.com/MakeOmatic"> <i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-twitter fa-stack-1x fa-inverse"></i> </a> <a class="gp fa-stack fa-lg" href="https://google.com/+MakeomaticRu"> <i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-google-plus fa-stack-1x fa-inverse"></i> </a> </div> </div> </div> </div></footer><div class="modal hide fade brief" id='brief'> <div class="modal-body"> <div class='text-center'> <h2 class='brief-header outlined-caption'>Расскажите нам о вашем проекте</h2> <p class='small'> Коротко опишите ваши идеи или просто прикрепите файл с готовым ТЗ.<br/> Мы свяжемся с вами в течение 1 дня и подробно расскажем о том, как мы можем вам помочь. </p> </div> <form method='POST' action='/brief' class='callback'> <input type="text" name='name' placeholder="Как к вам обратиться?" class='span10' required /> <input type="text" name='phone' placeholder="По какому номеру звонить?" class='span5' /> <input type="email" name='email' placeholder="E-mail (опционально)" class='span5 pull-right' /> <textarea name='question' placeholder="Краткое описание вашего проекта" class='span7'></textarea> <div class='dropbox pull-right' id='dropbox' ></div> <button class="blue-plank pull-right" type='submit'>Отправить</button> </form> </div></div><!-- scripts --><script src="/js/app.min.2.3.1.js" charset="UTF-8" ></script><!-- end scripts --><script type="text/javascript">var disqus_shortname = 'makeomatic';(function(){ var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);}());</script><!-- Yandex.Metrika counter --><script type="text/javascript">(function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter15629977 = new Ya.Metrika({id:15629977, webvisor:true, clickmap:true, trackLinks:true, accurateTrackBounce:true, trackHash:true, ut:"noindex"}); } catch(e) { } }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f, false); } else { f(); } })(document, window, "yandex_metrika_callbacks");</script><noscript><div><img src="//mc.yandex.ru/watch/15629977?ut=noindex" style="position:absolute; left:-9999px;" alt="" /></div></noscript><!-- /Yandex.Metrika counter --><!-- google analytics --><script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-40638966-1', 'makeomatic.ru'); ga('send', 'pageview');</script></body></html>